diff -burN orig.newlib-1.15.0/.cvsignore newlib-1.15.0/.cvsignore
--- orig.newlib-1.15.0/.cvsignore	2001-10-30 11:20:01.000000000 -0400
+++ newlib-1.15.0/.cvsignore	1969-12-31 20:00:00.000000000 -0400
@@ -1,32 +0,0 @@
-*-all
-*-co
-*-dirs
-*-done
-*-install-info
-*-src
-*-stamp-*
-*-tagged
-blockit
-cfg-paper.info
-config.status
-configure.aux
-configure.cp
-configure.cps
-configure.dvi
-configure.fn
-configure.fns
-configure.ky
-configure.kys
-configure.log
-configure.pg
-configure.pgs
-configure.toc
-configure.tp
-configure.tps
-configure.vr
-configure.vrs
-dir.info
-Makefile
-lost+found
-update.out
-update.sourceware
diff -burN orig.newlib-1.15.0/libgloss/spu/access.c newlib-1.15.0/libgloss/spu/access.c
--- orig.newlib-1.15.0/libgloss/spu/access.c	2006-12-13 15:42:56.000000000 -0400
+++ newlib-1.15.0/libgloss/spu/access.c	2007-06-12 16:59:18.000000000 -0300
@@ -29,7 +29,6 @@
 
 */
 
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -41,9 +40,8 @@
         sys.pathname = (unsigned int) pathname;
         sys.mode = mode;
 
-        _send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_ACCESS, &sys);
+        __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_ACCESS, &sys);
 
-        errno = psys_out->err;
         return ( psys_out->rc);
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/close.c newlib-1.15.0/libgloss/spu/close.c
--- orig.newlib-1.15.0/libgloss/spu/close.c	2006-08-30 16:06:48.000000000 -0300
+++ newlib-1.15.0/libgloss/spu/close.c	2007-06-12 16:59:18.000000000 -0300
@@ -30,7 +30,6 @@
 Author: Andreas Neukoetter (ti95neuk@de.ibm.com)
 */
 
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -41,9 +40,8 @@
 
 	sys.file = file;
 
-        _send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_CLOSE, &sys);
+        __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_CLOSE, &sys);
 
-        errno = psys_out->err;
         return ( psys_out->rc);
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/dup.c newlib-1.15.0/libgloss/spu/dup.c
--- orig.newlib-1.15.0/libgloss/spu/dup.c	2006-12-13 15:42:56.000000000 -0400
+++ newlib-1.15.0/libgloss/spu/dup.c	2007-06-12 16:59:18.000000000 -0300
@@ -29,7 +29,6 @@
 
 */
 
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -40,9 +39,8 @@
 
         sys.oldfd = oldfd;
 
-        _send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_DUP, &sys);
+        __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_DUP, &sys);
 
-        errno = psys_out->err;
         return ( psys_out->rc);
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/fstat.c newlib-1.15.0/libgloss/spu/fstat.c
--- orig.newlib-1.15.0/libgloss/spu/fstat.c	2006-08-30 16:06:48.000000000 -0300
+++ newlib-1.15.0/libgloss/spu/fstat.c	2007-06-12 16:59:18.000000000 -0300
@@ -31,7 +31,6 @@
 */
 
 #include <sys/stat.h>
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -44,7 +43,7 @@
         sys.file = file;
         sys.ptr = ( unsigned int )&pjstat;
 
-        _send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_FSTAT, &sys);
+        __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_FSTAT, &sys);
 
         pstat->st_dev = pjstat.dev;
         pstat->st_ino = pjstat.ino;
@@ -61,7 +60,6 @@
         pstat->st_ctime = pjstat.ctime;
 
 
-        errno = psys_out->err;
         return( psys_out->rc );
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/ftruncate.c newlib-1.15.0/libgloss/spu/ftruncate.c
--- orig.newlib-1.15.0/libgloss/spu/ftruncate.c	2006-12-13 15:42:56.000000000 -0400
+++ newlib-1.15.0/libgloss/spu/ftruncate.c	2007-06-12 16:59:18.000000000 -0300
@@ -29,7 +29,6 @@
 
 */
 #include <unistd.h>
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -41,9 +40,8 @@
 	sys.file = file;
 	sys.length = length;
 
-	_send_to_ppe(JSRE_POSIX1_SIGNALCODE, JSRE_FTRUNCATE, &sys);
+	__send_to_ppe(JSRE_POSIX1_SIGNALCODE, JSRE_FTRUNCATE, &sys);
 
-	errno = psys_out->err;
 	return ( psys_out->rc);
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/gettimeofday.c newlib-1.15.0/libgloss/spu/gettimeofday.c
--- orig.newlib-1.15.0/libgloss/spu/gettimeofday.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/libgloss/spu/gettimeofday.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,49 @@
+/*
+(C) Copyright IBM Corp. 2007
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+    * Neither the name of IBM nor the names of its contributors may be
+used to endorse or promote products derived from this software without
+specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#include <unistd.h>
+#include <errno.h>
+#include <sys/time.h>
+#include "jsre.h"
+
+int
+gettimeofday (struct timeval *tv, struct timezone *tz)
+{
+	syscall_gettimeofday_t sys;
+	syscall_out_t *psys_out = ( syscall_out_t* )&sys;
+
+	sys.tv = (unsigned int)tv;
+	sys.tz = (unsigned int)tz;
+
+	__send_to_ppe(JSRE_POSIX1_SIGNALCODE, JSRE_GETTIMEOFDAY, &sys);
+
+	return (psys_out->rc);
+}
diff -burN orig.newlib-1.15.0/libgloss/spu/jsre.h newlib-1.15.0/libgloss/spu/jsre.h
--- orig.newlib-1.15.0/libgloss/spu/jsre.h	2006-12-13 15:42:56.000000000 -0400
+++ newlib-1.15.0/libgloss/spu/jsre.h	2007-06-12 16:59:18.000000000 -0300
@@ -56,6 +56,7 @@
 
 #define JSRE_CLOSE 2
 #define JSRE_FSTAT 4
+#define JSRE_GETTIMEOFDAY 7
 #define JSRE_LSEEK 9
 #define JSRE_OPEN 15
 #define JSRE_READ 16
@@ -137,6 +138,14 @@
 
 typedef struct
 {
+	unsigned int	tv;
+	unsigned int	pad0[ 3 ];
+	unsigned int	tz;
+	unsigned int	pad1[ 3 ];
+} syscall_gettimeofday_t;
+
+typedef struct
+{
 	unsigned int	time;
 	unsigned int	pad0[ 3 ];
 } syscall_time_t;
@@ -186,6 +195,6 @@
     unsigned int ctime;
 } jsre_stat_t;
 
-void _send_to_ppe (unsigned int signalcode, unsigned int opcode, void *data);
+#include <sys/send_to_ppe.h>
 
 #endif
diff -burN orig.newlib-1.15.0/libgloss/spu/lseek.c newlib-1.15.0/libgloss/spu/lseek.c
--- orig.newlib-1.15.0/libgloss/spu/lseek.c	2006-08-30 16:06:48.000000000 -0300
+++ newlib-1.15.0/libgloss/spu/lseek.c	2007-06-12 16:59:18.000000000 -0300
@@ -31,7 +31,6 @@
 */
 
 #include <unistd.h>
-#include <errno.h>
 #include "jsre.h"
 
 off_t
@@ -55,9 +54,8 @@
 			break;
 	}
 
-	_send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_LSEEK, &sys);
+	__send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_LSEEK, &sys);
 
-        errno = psys_out->err;
         return ( psys_out->rc);
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/Makefile.in newlib-1.15.0/libgloss/spu/Makefile.in
--- orig.newlib-1.15.0/libgloss/spu/Makefile.in	2006-12-13 15:42:56.000000000 -0400
+++ newlib-1.15.0/libgloss/spu/Makefile.in	2007-06-12 16:59:18.000000000 -0300
@@ -56,7 +56,7 @@
 # object files needed
 OBJS = syscalls.o exit.o sbrk.o close.o fstat.o getpid.o isatty.o \
 	kill.o lseek.o open.o read.o unlink.o write.o stat.o \
-	ftruncate.o dup.o access.o time.o
+	ftruncate.o dup.o access.o gettimeofday.o
 
 # Object files specific to particular targets.
 EVALOBJS = ${OBJS}
diff -burN orig.newlib-1.15.0/libgloss/spu/open.c newlib-1.15.0/libgloss/spu/open.c
--- orig.newlib-1.15.0/libgloss/spu/open.c	2006-08-30 16:06:48.000000000 -0300
+++ newlib-1.15.0/libgloss/spu/open.c	2007-06-12 16:59:18.000000000 -0300
@@ -32,7 +32,6 @@
 
 #include <stdarg.h>
 #include <fcntl.h>
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -81,9 +80,8 @@
                   sys.mode = 0;
           }
 
-        _send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_OPEN, &sys);
+        __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_OPEN, &sys);
 
-        errno = psys_out->err;
         return ( psys_out->rc);
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/read.c newlib-1.15.0/libgloss/spu/read.c
--- orig.newlib-1.15.0/libgloss/spu/read.c	2006-08-30 16:06:48.000000000 -0300
+++ newlib-1.15.0/libgloss/spu/read.c	2007-06-12 16:59:18.000000000 -0300
@@ -31,7 +31,6 @@
 */
 
 #include <fcntl.h>
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -44,9 +43,8 @@
 	sys.ptr = ( unsigned int )ptr;
 	sys.len = len;
 
-	_send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_READ, &sys);
+	__send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_READ, &sys);
 
-        errno = psys_out->err;
         return ( psys_out->rc);
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/sbrk.c newlib-1.15.0/libgloss/spu/sbrk.c
--- orig.newlib-1.15.0/libgloss/spu/sbrk.c	2006-08-16 18:15:03.000000000 -0300
+++ newlib-1.15.0/libgloss/spu/sbrk.c	2007-06-12 16:59:18.000000000 -0300
@@ -32,6 +32,7 @@
 
 #include <sys/types.h>
 #include <errno.h>
+#include <spu_intrinsics.h>
 
 extern int errno;
 
@@ -44,15 +45,34 @@
 {
 	static caddr_t heap_ptr = NULL;
 	caddr_t base;
+	vector unsigned int sp_reg, sp_delta;
+	vector unsigned int *sp_ptr;
+
+	/* The stack pointer register.  */
+	volatile register vector unsigned int sp_r1 __asm__("1");
 
 	if (heap_ptr == NULL)
-	  {
 		  heap_ptr = (caddr_t) & _end;
-	  }
+	
 	if (((RAMSIZE - STACKSIZE) - (int) heap_ptr) >= increment)
 	  {
 		  base = heap_ptr;
 		  heap_ptr += increment;
+	    
+	    sp_delta = (vector unsigned int) spu_insert (increment, spu_splats (0), 1);
+
+	    /* Subtract sp_delta from the SP limit (word 1).  */
+	    sp_r1 = spu_sub (sp_r1, sp_delta);
+	    
+	    /* Fix-up backchain.  */
+	    sp_ptr = (vector unsigned int *) spu_extract (sp_r1, 0);
+	    do
+	      {
+		sp_reg = *sp_ptr;
+		*sp_ptr = (vector unsigned int) spu_sub (sp_reg, sp_delta);
+	      }
+	    while ((sp_ptr = (vector unsigned int *) spu_extract (sp_reg, 0)));
+
 		  return (base);
 	  }
 	else
diff -burN orig.newlib-1.15.0/libgloss/spu/stat.c newlib-1.15.0/libgloss/spu/stat.c
--- orig.newlib-1.15.0/libgloss/spu/stat.c	2006-12-18 12:43:31.000000000 -0400
+++ newlib-1.15.0/libgloss/spu/stat.c	2007-06-12 16:59:18.000000000 -0300
@@ -32,7 +32,6 @@
 
 #include <stdarg.h>
 #include <fcntl.h>
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -45,7 +44,7 @@
 	sys.pathname = (unsigned int)pathname;
 	sys.ptr = ( unsigned int )&pjstat;
 
-	_send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_STAT, &sys);
+	__send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_STAT, &sys);
 
 	pstat->st_dev = pjstat.dev;
 	pstat->st_ino = pjstat.ino;
@@ -61,7 +60,6 @@
 	pstat->st_mtime = pjstat.mtime;
 	pstat->st_ctime = pjstat.ctime;
 
-	errno = psys_out->err;
 	return( psys_out->rc );
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/syscalls.c newlib-1.15.0/libgloss/spu/syscalls.c
--- orig.newlib-1.15.0/libgloss/spu/syscalls.c	2006-11-22 17:20:31.000000000 -0400
+++ newlib-1.15.0/libgloss/spu/syscalls.c	2007-06-12 16:59:18.000000000 -0300
@@ -29,11 +29,12 @@
 
 Author: Andreas Neukoetter (ti95neuk@de.ibm.com)
 */
+#include <errno.h>
 #include <spu_intrinsics.h>
 #include "jsre.h"
 
 void
-_send_to_ppe (unsigned int signalcode, unsigned int opcode, void *data)
+__send_to_ppe (unsigned int signalcode, unsigned int opcode, void *data)
 {
 
 	unsigned int	combined = ( ( opcode<<24 )&0xff000000 ) | ( ( unsigned int )data & 0x00ffffff );
@@ -47,6 +48,7 @@
 
         void (*f) (void) = (void *) &stopfunc;
         asm ("sync");
-        return (f ());
+        f ();
+        errno = ((unsigned int *) data)[3];
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/time.c newlib-1.15.0/libgloss/spu/time.c
--- orig.newlib-1.15.0/libgloss/spu/time.c	2006-12-13 15:42:56.000000000 -0400
+++ newlib-1.15.0/libgloss/spu/time.c	1969-12-31 20:00:00.000000000 -0400
@@ -1,49 +0,0 @@
-/*
-(C) Copyright IBM Corp. 2005, 2006
-
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-    * Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-    * Neither the name of IBM nor the names of its contributors may be
-used to endorse or promote products derived from this software without
-specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
-
-*/
-
-#include <unistd.h>
-#include <errno.h>
-#include "jsre.h"
-
-time_t
-time (time_t *t)
-{
-	syscall_time_t sys;
-	syscall_out_t   *psys_out = ( syscall_out_t* )&sys;
-
-	sys.time = t;
-
-	_send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_TIME, &sys);
-
-	errno = psys_out->err;
-	return ( psys_out->rc);
-}
-
diff -burN orig.newlib-1.15.0/libgloss/spu/unlink.c newlib-1.15.0/libgloss/spu/unlink.c
--- orig.newlib-1.15.0/libgloss/spu/unlink.c	2006-08-30 16:06:48.000000000 -0300
+++ newlib-1.15.0/libgloss/spu/unlink.c	2007-06-12 16:59:18.000000000 -0300
@@ -30,7 +30,6 @@
 Author: Andreas Neukoetter (ti95neuk@de.ibm.com)
 */
 
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -41,9 +40,8 @@
 
 	sys.pathname = ( unsigned int )pathname;
 
-        _send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_UNLINK, &sys);
+        __send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_UNLINK, &sys);
 
-        errno = psys_out->err;
         return ( psys_out->rc);
 }
 
diff -burN orig.newlib-1.15.0/libgloss/spu/write.c newlib-1.15.0/libgloss/spu/write.c
--- orig.newlib-1.15.0/libgloss/spu/write.c	2006-08-30 16:06:48.000000000 -0300
+++ newlib-1.15.0/libgloss/spu/write.c	2007-06-12 16:59:18.000000000 -0300
@@ -31,7 +31,6 @@
 */
 
 #include <fcntl.h>
-#include <errno.h>
 #include "jsre.h"
 
 int
@@ -44,9 +43,8 @@
 	sys.ptr = ( unsigned int )ptr;
 	sys.len = len;
 
-	_send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_WRITE, &sys);
+	__send_to_ppe (JSRE_POSIX1_SIGNALCODE, JSRE_WRITE, &sys);
 
-        errno = psys_out->err;
         return ( psys_out->rc);
 }
 
diff -burN orig.newlib-1.15.0/newlib/configure.host newlib-1.15.0/newlib/configure.host
--- orig.newlib-1.15.0/newlib/configure.host	2006-12-18 17:49:14.000000000 -0400
+++ newlib-1.15.0/newlib/configure.host	2007-06-12 16:59:18.000000000 -0300
@@ -256,8 +256,9 @@
 	machine_dir=z8k
 	;;
   spu)
+	libm_machine_dir=spu
 	machine_dir=spu
-	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections "
+	newlib_cflags="${newlib_cflags} -D_IEEE_LIBM -ffunction-sections -fdata-sections "
 	;;
   *)
 	echo '***' "Newlib does not support CPU ${host_cpu}" 1>&2
@@ -441,6 +442,7 @@
 	;;
   spu-*-*)
 	default_newlib_io_long_long="yes"
+	default_newlib_atexit_dynamic_alloc="no"
 	;;
   strongarm-*-*)
 	sys_dir=arm
diff -burN orig.newlib-1.15.0/newlib/libc/include/fenv.h newlib-1.15.0/newlib/libc/include/fenv.h
--- orig.newlib-1.15.0/newlib/libc/include/fenv.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/include/fenv.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+  (C) Copyright 2006, 2007
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <sys/fenv.h>
+
+/* Exception */
+void feclearexcept(int excepts);
+void fegetexceptflag(fexcept_t *flagp, int excepts);
+void feraiseexcept(int excepts);
+void fesetexceptflag(const fexcept_t *flagp, int excepts);
+int fetestexcept(int excepts);
+
+/* Rounding mode */
+int fegetround(void);
+int fesetround(int rounding_mode);
+
+/* Float environment */
+void fegetenv(fenv_t *envp);
+int feholdexcept(fenv_t *envp);
+void fesetenv(const fenv_t *envp);
+void feupdateenv(const fenv_t *envp);
diff -burN orig.newlib-1.15.0/newlib/libc/include/math.h newlib-1.15.0/newlib/libc/include/math.h
--- orig.newlib-1.15.0/newlib/libc/include/math.h	2006-11-30 19:40:12.000000000 -0400
+++ newlib-1.15.0/newlib/libc/include/math.h	2007-06-12 16:59:18.000000000 -0300
@@ -4,6 +4,7 @@
 
 #include <sys/reent.h>
 #include <machine/ieeefp.h>
+#include <limits.h>
 #include "_ansi.h"
 
 _BEGIN_STD_C
@@ -106,6 +107,9 @@
 
 /* ISO C99 types and macros. */
 
+#define FP_ILOGB0	INT_MIN
+#define FP_ILOGBNAN	INT_MAX
+
 #ifndef FLT_EVAL_METHOD
 #define FLT_EVAL_METHOD 0
 typedef float float_t;
diff -burN orig.newlib-1.15.0/newlib/libc/include/sys/fenv.h newlib-1.15.0/newlib/libc/include/sys/fenv.h
--- orig.newlib-1.15.0/newlib/libc/include/sys/fenv.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/include/sys/fenv.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1 @@
+#error This platform does not support fenv
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/c99ppe.h newlib-1.15.0/newlib/libc/machine/spu/c99ppe.h
--- orig.newlib-1.15.0/newlib/libc/machine/spu/c99ppe.h	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/c99ppe.h	2007-06-12 16:59:18.000000000 -0300
@@ -95,23 +95,19 @@
   unsigned int slot[4];
 };
 
-static void
-send_to_ppe(int signalcode, int opcode, void *data)
-{
+#include <sys/send_to_ppe.h>
 
-	unsigned int	combined = ( ( opcode<<24 )&0xff000000 ) | ( ( unsigned int )data & 0x00ffffff );
-	struct spe_reg128* ret = data;
+static FILE* translate_fp(FILE* source)
+{
 
-        vector unsigned int stopfunc = {
-                signalcode,     /* stop 0x210x*/
-                (unsigned int) combined,
-                0x4020007f,     /* nop */
-                0x35000000      /* bi $0 */
-        };
+  if(source == stdin){
+    return (FILE*)SPE_STDIN;
+  } else if(source == stdout){
+    return (FILE*)SPE_STDOUT;
+  } else if(source == stderr){
+    return (FILE*)SPE_STDERR;
+  } else {
+    return source;
+  }
 
-        void (*f) (void) = (void *) &stopfunc;
-        asm ("sync":::"memory");
-        f();
-	errno = ret->slot[3];
-	return;
 }
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/clearerr.c newlib-1.15.0/newlib/libc/machine/spu/clearerr.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/clearerr.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/clearerr.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,18 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+#undef clearerr
+
+_VOID
+_DEFUN (clearerr, (fp),
+	FILE * fp)
+
+{
+  FILE* myfp;
+  myfp = translate_fp(fp);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_CLEARERR, &myfp);
+
+  return;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fclose.c newlib-1.15.0/newlib/libc/machine/spu/fclose.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fclose.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fclose.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,27 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+int
+_DEFUN (fclose, (fp),
+	FILE * fp)
+{
+  FILE* myfp;
+  int* ret;
+
+  myfp = translate_fp(fp);
+  ret = (int*) &myfp;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FCLOSE, &myfp);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/feof.c newlib-1.15.0/newlib/libc/machine/spu/feof.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/feof.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/feof.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,20 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#undef feof
+
+int
+_DEFUN (feof, (fp),
+	FILE * fp)
+{
+  int* result;
+  FILE* myfp;
+  result = (int*)&myfp;
+  myfp = translate_fp(fp);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FEOF, &myfp);
+
+
+  return *result;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/ferror.c newlib-1.15.0/newlib/libc/machine/spu/ferror.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/ferror.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/ferror.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#undef feof
+
+#undef ferror
+
+int
+_DEFUN (ferror, (fp),
+	FILE * fp)
+{
+  int* result;
+  FILE* myfp;
+  myfp = translate_fp(fp);
+  result = (int*)&myfp;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FERROR, &myfp);
+
+
+  return *result;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fflush.c newlib-1.15.0/newlib/libc/machine/spu/fflush.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fflush.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fflush.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,19 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+int
+_DEFUN (fflush, (fp),
+	FILE * fp)
+{
+  int* result;
+  FILE* myfp;
+  result = (int*)&myfp;
+
+  myfp = translate_fp(fp);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FFLUSH, &myfp);
+
+
+  return *result;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fgetc.c newlib-1.15.0/newlib/libc/machine/spu/fgetc.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fgetc.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fgetc.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,19 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+int
+_DEFUN (fgetc, (fp),
+	FILE * fp)
+{
+  int* result;
+  FILE* myfp;
+  result = (int*)&myfp;
+  myfp = translate_fp(fp);
+
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FGETC, &myfp);
+
+
+  return *result;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fgetpos.c newlib-1.15.0/newlib/libc/machine/spu/fgetpos.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fgetpos.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fgetpos.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,28 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  FILE * fp;
+  unsigned int pad0[ 3 ];
+  _fpos_t * pos;
+} c99_fgetpos_t;
+
+int
+_DEFUN (fgetpos, (fp, pos),
+	FILE * fp _AND
+	_fpos_t * pos)
+{
+  c99_fgetpos_t args;
+  int* result;
+  result = (int*)&fp;
+
+  args.fp = translate_fp(fp);
+  args.pos = pos;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FGETPOS, &args);
+
+
+  return *result;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fgets.c newlib-1.15.0/newlib/libc/machine/spu/fgets.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fgets.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fgets.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,31 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  char *buf;
+  unsigned int pad0[3];
+  int n;
+  unsigned int pad1[3];
+  FILE *fp;
+} c99_fgets_t;
+
+char *
+_DEFUN (fgets, (buf, n, fp),
+	char *buf _AND
+	int n _AND
+	FILE * fp)
+{
+  char** ret;
+  c99_fgets_t args;
+  args.buf = buf;
+  args.n = n;
+  args.fp = translate_fp(fp);
+  ret = (char**) &args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FGETS, &args);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fileno.c newlib-1.15.0/newlib/libc/machine/spu/fileno.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fileno.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fileno.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,21 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+
+int
+_DEFUN (fileno, (fp),
+	FILE *fp)
+
+{
+  FILE* myfp;
+  int *ret = (int*)&myfp;
+
+
+  myfp = translate_fp(fp);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FILENO, &myfp);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fopen.c newlib-1.15.0/newlib/libc/machine/spu/fopen.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fopen.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fopen.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,39 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  char* fp;
+  unsigned int pad0[ 3 ];
+  char* mode;
+  unsigned int pad1[ 3 ];
+} c99_fopen_t;
+
+#ifndef _REENT_ONLY
+FILE *
+_DEFUN (fopen, (file, mode),
+	_CONST char *file _AND
+	_CONST char *mode)
+{
+  FILE** ret;
+  c99_fopen_t args;
+  args.fp = file;
+  args.mode = mode;
+  ret = (FILE**) &args;
+
+  /*  ret = vfprintf (_stdout_r (_REENT), fmt, ap);*/
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FOPEN, &args);
+
+  return *ret;
+}
+
+#endif /* ! _REENT_ONLY */
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fprintf.c newlib-1.15.0/newlib/libc/machine/spu/fprintf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fprintf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fprintf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,42 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  FILE * fp;
+  unsigned int pad0[ 3 ];
+  char* fmt;
+  unsigned int pad1[ 3 ];
+  va_list ap;
+} c99_fprintf_t;
+
+int
+fprintf(FILE * fp, _CONST char *fmt,...)
+{
+  int* ret;
+  c99_fprintf_t args;
+  ret = (int*) &args;
+
+  args.fp = translate_fp(fp);
+  args.fmt = (char*) fmt;
+
+#ifdef _HAVE_STDC
+  va_start (args.ap, args.fmt);
+#else
+  va_start (args.ap);
+#endif
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VFPRINTF, &args);
+
+  va_end (args.ap);
+  return *ret;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fputc.c newlib-1.15.0/newlib/libc/machine/spu/fputc.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fputc.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fputc.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,30 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  int ch;
+  unsigned int pad0[ 3 ];
+  FILE* fp;
+  unsigned int pad1[ 3 ];
+} c99_fputc_t;
+
+int
+fputc (c, fp)
+     int c;
+     register FILE *fp;
+{
+  int* ret;
+  c99_fputc_t args;
+  args.ch = c;
+  args.fp = translate_fp(fp);
+  ret = (int*)&args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FPUTC, &args);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fputs.c newlib-1.15.0/newlib/libc/machine/spu/fputs.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fputs.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fputs.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,30 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  char* s;
+  unsigned int pad0[ 3 ];
+  FILE* fp;
+  unsigned int pad1[ 3 ];
+} c99_fputs_t;
+
+int
+_DEFUN (fputs, (s, fp),
+	char _CONST * s _AND
+	FILE * fp)
+{
+  int* ret;
+  c99_fputs_t args;
+  args.s = s;
+  args.fp = translate_fp(fp);
+  ret = (int*)&args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FPUTS, &args);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fread.c newlib-1.15.0/newlib/libc/machine/spu/fread.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fread.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fread.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,36 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  char* buf;
+  unsigned int pad0[ 3 ];
+  size_t size;
+  unsigned int pad1[ 3 ];
+  size_t count;
+  unsigned int pad2[ 3 ];
+  FILE *fp;
+} c99_fread_t;
+
+size_t
+_DEFUN (fread, (buf, size, count, fp),
+	_PTR buf _AND
+	size_t size _AND
+	size_t count _AND
+	FILE * fp)
+{
+  size_t* ret;
+  c99_fread_t args;
+  args.buf = buf;
+  args.size = size;
+  args.count = count;
+  args.fp = translate_fp(fp);
+  ret = (size_t*) &args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FREAD, &args);
+
+  return *ret;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/freopen.c newlib-1.15.0/newlib/libc/machine/spu/freopen.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/freopen.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/freopen.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,32 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  char *file;
+  unsigned int pad0[ 3 ];
+  char *mode;
+  unsigned int pad1[ 3 ];
+  FILE *fp;
+} c99_freopen_t;
+
+FILE *
+_DEFUN (freopen, (file, mode, fp),
+	const char *file _AND
+	const char *mode _AND
+	FILE *fp)
+{
+  FILE **ret;
+  c99_freopen_t args;
+  args.file = file;
+  args.mode = mode;
+  args.fp = translate_fp(fp);
+  ret = (FILE**) &args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FREOPEN, &args);
+
+  return *ret;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fscanf.c newlib-1.15.0/newlib/libc/machine/spu/fscanf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fscanf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fscanf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,42 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  FILE * fp;
+  unsigned int pad0[ 3 ];
+  char* fmt;
+  unsigned int pad1[ 3 ];
+  va_list ap;
+} c99_vfscanf_t;
+
+fscanf(FILE *fp, _CONST char *fmt, ...)
+{
+  int* ret;
+  c99_vfscanf_t args;
+  ret = (int*) &args;
+
+  args.fp = translate_fp(fp);
+  args.fmt = (char*) fmt;
+#ifdef _HAVE_STDC
+  va_start (args.ap, args.fmt);
+#else
+  va_start (args.ap);
+#endif
+
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VFSCANF, &args);
+
+  va_end (args.ap);
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fseek.c newlib-1.15.0/newlib/libc/machine/spu/fseek.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fseek.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fseek.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,33 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  FILE* fp;
+  unsigned int pad0[ 3 ];
+  long offset;
+  unsigned int pad1[ 3 ];
+  int whence;
+} c99_fseek_t;
+
+int
+_DEFUN (fseek, (fp, offset, whence),
+     register FILE *fp _AND
+     long offset _AND
+     int whence)
+{
+  int* ret;
+  c99_fseek_t args;
+  args.fp = translate_fp(fp);
+  args.offset = offset;
+  args.whence = whence;
+  ret = (int*)&args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FSEEK, &args);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fsetpos.c newlib-1.15.0/newlib/libc/machine/spu/fsetpos.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fsetpos.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fsetpos.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,29 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  FILE* fp;
+  unsigned int pad0[ 3 ];
+  _fpos_t *pos;
+} c99_fsetpos_t;
+
+int
+_DEFUN (fsetpos, (iop, pos),
+	FILE * iop _AND
+	_CONST _fpos_t * pos)
+{
+  int* ret;
+  c99_fsetpos_t args;
+  args.fp = translate_fp(iop);
+  args.pos = pos;
+  ret = (int*)&args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FSETPOS, &args);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/ftell.c newlib-1.15.0/newlib/libc/machine/spu/ftell.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/ftell.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/ftell.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,20 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+
+long
+_DEFUN (ftell, (fp),
+	FILE * fp)
+{
+  FILE* myfp;
+  long *ret = (long*)&myfp;
+
+  myfp = translate_fp(fp);
+
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FTELL, &myfp);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/fwrite.c newlib-1.15.0/newlib/libc/machine/spu/fwrite.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/fwrite.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/fwrite.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,36 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  char* buf;
+  unsigned int pad0[ 3 ];
+  size_t size;
+  unsigned int pad1[ 3 ];
+  size_t count;
+  unsigned int pad2[ 3 ];
+  FILE *fp;
+} c99_fwrite_t;
+
+size_t
+_DEFUN (fwrite, (buf, size, count, fp),
+	_CONST _PTR buf _AND
+	size_t size _AND
+	size_t count _AND
+	FILE * fp)
+{
+  size_t* ret;
+  c99_fwrite_t args;
+  args.buf = buf;
+  args.size = size;
+  args.count = count;
+  args.fp = translate_fp(fp);
+  ret = (size_t*) &args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_FWRITE, &args);
+
+  return *ret;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/getc.c newlib-1.15.0/newlib/libc/machine/spu/getc.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/getc.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/getc.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,24 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+/*
+ * A subroutine version of the macro getc.
+ */
+
+#undef getc
+
+int
+getc (fp)
+     FILE *fp;
+{
+  int* ret;
+  FILE* myfp;
+  ret = (int*)&myfp;
+
+  myfp = translate_fp(fp);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_GETC, &myfp);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/getchar.c newlib-1.15.0/newlib/libc/machine/spu/getchar.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/getchar.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/getchar.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,16 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#undef getchar
+
+int
+getchar ()
+{
+  int ret;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_GETCHAR, &ret);
+
+  return ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/gets.c newlib-1.15.0/newlib/libc/machine/spu/gets.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/gets.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/gets.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,16 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+char *
+gets (buf)
+     char *buf;
+{
+
+  /* The return value gets written over buf
+   */
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_GETS, &buf);
+
+  return buf;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/Makefile.am newlib-1.15.0/newlib/libc/machine/spu/Makefile.am
--- orig.newlib-1.15.0/newlib/libc/machine/spu/Makefile.am	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/Makefile.am	2007-06-12 16:59:18.000000000 -0300
@@ -8,7 +8,8 @@
 
 AM_CCASFLAGS = $(INCLUDES)
 
-lib_a_SOURCES = setjmp.S memcpy.c memmove.c memset.c strcat.c strchr.c strcmp.c strcpy.c strcspn.c strlen.c strncat.c strncmp.c strncpy.c strpbrk.c strrchr.c strspn.c strxfrm.c printf.c perror.c putchar.c puts.c vsnprintf.c vprintf.c vsprintf.c
+lib_a_SOURCES = setjmp.S memcpy.c memmove.c memset.c strcat.c strchr.c strcmp.c strcpy.c strcspn.c strlen.c strncat.c strncmp.c strncpy.c strpbrk.c strrchr.c strspn.c strxfrm.c printf.c perror.c putchar.c puts.c vsnprintf.c vprintf.c vsprintf.c clearerr.c fclose.c feof.c ferror.c fflush.c fgetc.c fgetpos.c fgets.c fileno.c fopen.c fprintf.c fputc.c fputs.c fread.c freopen.c fscanf.c fseek.c fsetpos.c ftell.c fwrite.c getc.c getchar.c gets.c putc.c remove.c rename.c rewind.c scanf.c setbuf.c setvbuf.c snprintf.c sprintf.c sscanf.c tmpfile.c tmpnam.c ungetc.c vfprintf.c vfscanf.c vscanf.c vsscanf.c wbuf.c
+
 
 lib_a_CCASFLAGS = $(AM_CCASFLAGS)
 lib_a_CFLAGS = $(AM_CFLAGS)
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/Makefile.in newlib-1.15.0/newlib/libc/machine/spu/Makefile.in
--- orig.newlib-1.15.0/newlib/libc/machine/spu/Makefile.in	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/Makefile.in	2007-06-12 16:59:18.000000000 -0300
@@ -51,7 +51,27 @@
 	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
 	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
 	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
-	$(srcdir)/../../../../compile
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile
 subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../../../acinclude.m4 \
@@ -77,7 +97,28 @@
 	lib_a-strxfrm.$(OBJEXT) lib_a-printf.$(OBJEXT) \
 	lib_a-perror.$(OBJEXT) lib_a-putchar.$(OBJEXT) \
 	lib_a-puts.$(OBJEXT) lib_a-vsnprintf.$(OBJEXT) \
-	lib_a-vprintf.$(OBJEXT) lib_a-vsprintf.$(OBJEXT)
+	lib_a-vprintf.$(OBJEXT) lib_a-vsprintf.$(OBJEXT) \
+	lib_a-clearerr.$(OBJEXT) lib_a-fclose.$(OBJEXT) \
+	lib_a-feof.$(OBJEXT) lib_a-ferror.$(OBJEXT) \
+	lib_a-fflush.$(OBJEXT) lib_a-fgetc.$(OBJEXT) \
+	lib_a-fgetpos.$(OBJEXT) lib_a-fgets.$(OBJEXT) \
+	lib_a-fileno.$(OBJEXT) lib_a-fopen.$(OBJEXT) \
+	lib_a-fprintf.$(OBJEXT) lib_a-fputc.$(OBJEXT) \
+	lib_a-fputs.$(OBJEXT) lib_a-fread.$(OBJEXT) \
+	lib_a-freopen.$(OBJEXT) lib_a-fscanf.$(OBJEXT) \
+	lib_a-fseek.$(OBJEXT) lib_a-fsetpos.$(OBJEXT) \
+	lib_a-ftell.$(OBJEXT) lib_a-fwrite.$(OBJEXT) \
+	lib_a-getc.$(OBJEXT) lib_a-getchar.$(OBJEXT) \
+	lib_a-gets.$(OBJEXT) lib_a-putc.$(OBJEXT) \
+	lib_a-remove.$(OBJEXT) lib_a-rename.$(OBJEXT) \
+	lib_a-rewind.$(OBJEXT) lib_a-scanf.$(OBJEXT) \
+	lib_a-setbuf.$(OBJEXT) lib_a-setvbuf.$(OBJEXT) \
+	lib_a-snprintf.$(OBJEXT) lib_a-sprintf.$(OBJEXT) \
+	lib_a-sscanf.$(OBJEXT) lib_a-tmpfile.$(OBJEXT) \
+	lib_a-tmpnam.$(OBJEXT) lib_a-ungetc.$(OBJEXT) \
+	lib_a-vfprintf.$(OBJEXT) lib_a-vfscanf.$(OBJEXT) \
+	lib_a-vscanf.$(OBJEXT) lib_a-vsscanf.$(OBJEXT) \
+	lib_a-wbuf.$(OBJEXT)
 lib_a_OBJECTS = $(am_lib_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir)
 depcomp =
@@ -202,7 +243,7 @@
 INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS)
 noinst_LIBRARIES = lib.a
 AM_CCASFLAGS = $(INCLUDES)
-lib_a_SOURCES = setjmp.S memcpy.c memmove.c memset.c strcat.c strchr.c strcmp.c strcpy.c strcspn.c strlen.c strncat.c strncmp.c strncpy.c strpbrk.c strrchr.c strspn.c strxfrm.c printf.c perror.c putchar.c puts.c vsnprintf.c vprintf.c vsprintf.c
+lib_a_SOURCES = setjmp.S memcpy.c memmove.c memset.c strcat.c strchr.c strcmp.c strcpy.c strcspn.c strlen.c strncat.c strncmp.c strncpy.c strpbrk.c strrchr.c strspn.c strxfrm.c printf.c perror.c putchar.c puts.c vsnprintf.c vprintf.c vsprintf.c clearerr.c fclose.c feof.c ferror.c fflush.c fgetc.c fgetpos.c fgets.c fileno.c fopen.c fprintf.c fputc.c fputs.c fread.c freopen.c fscanf.c fseek.c fsetpos.c ftell.c fwrite.c getc.c getchar.c gets.c putc.c remove.c rename.c rewind.c scanf.c setbuf.c setvbuf.c snprintf.c sprintf.c sscanf.c tmpfile.c tmpnam.c ungetc.c vfprintf.c vfscanf.c vscanf.c vsscanf.c wbuf.c
 lib_a_CCASFLAGS = $(AM_CCASFLAGS)
 lib_a_CFLAGS = $(AM_CFLAGS)
 ACLOCAL_AMFLAGS = -I ../../.. 
@@ -414,6 +455,252 @@
 
 lib_a-vsprintf.obj: vsprintf.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vsprintf.obj `if test -f 'vsprintf.c'; then $(CYGPATH_W) 'vsprintf.c'; else $(CYGPATH_W) '$(srcdir)/vsprintf.c'; fi`
+
+lib_a-clearerr.o: clearerr.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-clearerr.o `test -f 'clearerr.c' || echo '$(srcdir)/'`clearerr.c
+
+lib_a-clearerr.obj: clearerr.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-clearerr.obj `if test -f 'clearerr.c'; then $(CYGPATH_W) 'clearerr.c'; else $(CYGPATH_W) '$(srcdir)/clearerr.c'; fi`
+
+lib_a-fclose.o: fclose.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fclose.o `test -f 'fclose.c' || echo '$(srcdir)/'`fclose.c
+
+lib_a-fclose.obj: fclose.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fclose.obj `if test -f 'fclose.c'; then $(CYGPATH_W) 'fclose.c'; else $(CYGPATH_W) '$(srcdir)/fclose.c'; fi`
+
+lib_a-feof.o: feof.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feof.o `test -f 'feof.c' || echo '$(srcdir)/'`feof.c
+
+lib_a-feof.obj: feof.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feof.obj `if test -f 'feof.c'; then $(CYGPATH_W) 'feof.c'; else $(CYGPATH_W) '$(srcdir)/feof.c'; fi`
+
+lib_a-ferror.o: ferror.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ferror.o `test -f 'ferror.c' || echo '$(srcdir)/'`ferror.c
+
+lib_a-ferror.obj: ferror.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ferror.obj `if test -f 'ferror.c'; then $(CYGPATH_W) 'ferror.c'; else $(CYGPATH_W) '$(srcdir)/ferror.c'; fi`
+
+lib_a-fflush.o: fflush.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fflush.o `test -f 'fflush.c' || echo '$(srcdir)/'`fflush.c
+
+lib_a-fflush.obj: fflush.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fflush.obj `if test -f 'fflush.c'; then $(CYGPATH_W) 'fflush.c'; else $(CYGPATH_W) '$(srcdir)/fflush.c'; fi`
+
+lib_a-fgetc.o: fgetc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fgetc.o `test -f 'fgetc.c' || echo '$(srcdir)/'`fgetc.c
+
+lib_a-fgetc.obj: fgetc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fgetc.obj `if test -f 'fgetc.c'; then $(CYGPATH_W) 'fgetc.c'; else $(CYGPATH_W) '$(srcdir)/fgetc.c'; fi`
+
+lib_a-fgetpos.o: fgetpos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fgetpos.o `test -f 'fgetpos.c' || echo '$(srcdir)/'`fgetpos.c
+
+lib_a-fgetpos.obj: fgetpos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fgetpos.obj `if test -f 'fgetpos.c'; then $(CYGPATH_W) 'fgetpos.c'; else $(CYGPATH_W) '$(srcdir)/fgetpos.c'; fi`
+
+lib_a-fgets.o: fgets.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fgets.o `test -f 'fgets.c' || echo '$(srcdir)/'`fgets.c
+
+lib_a-fgets.obj: fgets.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fgets.obj `if test -f 'fgets.c'; then $(CYGPATH_W) 'fgets.c'; else $(CYGPATH_W) '$(srcdir)/fgets.c'; fi`
+
+lib_a-fileno.o: fileno.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fileno.o `test -f 'fileno.c' || echo '$(srcdir)/'`fileno.c
+
+lib_a-fileno.obj: fileno.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fileno.obj `if test -f 'fileno.c'; then $(CYGPATH_W) 'fileno.c'; else $(CYGPATH_W) '$(srcdir)/fileno.c'; fi`
+
+lib_a-fopen.o: fopen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fopen.o `test -f 'fopen.c' || echo '$(srcdir)/'`fopen.c
+
+lib_a-fopen.obj: fopen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fopen.obj `if test -f 'fopen.c'; then $(CYGPATH_W) 'fopen.c'; else $(CYGPATH_W) '$(srcdir)/fopen.c'; fi`
+
+lib_a-fprintf.o: fprintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fprintf.o `test -f 'fprintf.c' || echo '$(srcdir)/'`fprintf.c
+
+lib_a-fprintf.obj: fprintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fprintf.obj `if test -f 'fprintf.c'; then $(CYGPATH_W) 'fprintf.c'; else $(CYGPATH_W) '$(srcdir)/fprintf.c'; fi`
+
+lib_a-fputc.o: fputc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fputc.o `test -f 'fputc.c' || echo '$(srcdir)/'`fputc.c
+
+lib_a-fputc.obj: fputc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fputc.obj `if test -f 'fputc.c'; then $(CYGPATH_W) 'fputc.c'; else $(CYGPATH_W) '$(srcdir)/fputc.c'; fi`
+
+lib_a-fputs.o: fputs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fputs.o `test -f 'fputs.c' || echo '$(srcdir)/'`fputs.c
+
+lib_a-fputs.obj: fputs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fputs.obj `if test -f 'fputs.c'; then $(CYGPATH_W) 'fputs.c'; else $(CYGPATH_W) '$(srcdir)/fputs.c'; fi`
+
+lib_a-fread.o: fread.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fread.o `test -f 'fread.c' || echo '$(srcdir)/'`fread.c
+
+lib_a-fread.obj: fread.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fread.obj `if test -f 'fread.c'; then $(CYGPATH_W) 'fread.c'; else $(CYGPATH_W) '$(srcdir)/fread.c'; fi`
+
+lib_a-freopen.o: freopen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-freopen.o `test -f 'freopen.c' || echo '$(srcdir)/'`freopen.c
+
+lib_a-freopen.obj: freopen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-freopen.obj `if test -f 'freopen.c'; then $(CYGPATH_W) 'freopen.c'; else $(CYGPATH_W) '$(srcdir)/freopen.c'; fi`
+
+lib_a-fscanf.o: fscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fscanf.o `test -f 'fscanf.c' || echo '$(srcdir)/'`fscanf.c
+
+lib_a-fscanf.obj: fscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fscanf.obj `if test -f 'fscanf.c'; then $(CYGPATH_W) 'fscanf.c'; else $(CYGPATH_W) '$(srcdir)/fscanf.c'; fi`
+
+lib_a-fseek.o: fseek.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fseek.o `test -f 'fseek.c' || echo '$(srcdir)/'`fseek.c
+
+lib_a-fseek.obj: fseek.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fseek.obj `if test -f 'fseek.c'; then $(CYGPATH_W) 'fseek.c'; else $(CYGPATH_W) '$(srcdir)/fseek.c'; fi`
+
+lib_a-fsetpos.o: fsetpos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fsetpos.o `test -f 'fsetpos.c' || echo '$(srcdir)/'`fsetpos.c
+
+lib_a-fsetpos.obj: fsetpos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fsetpos.obj `if test -f 'fsetpos.c'; then $(CYGPATH_W) 'fsetpos.c'; else $(CYGPATH_W) '$(srcdir)/fsetpos.c'; fi`
+
+lib_a-ftell.o: ftell.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ftell.o `test -f 'ftell.c' || echo '$(srcdir)/'`ftell.c
+
+lib_a-ftell.obj: ftell.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ftell.obj `if test -f 'ftell.c'; then $(CYGPATH_W) 'ftell.c'; else $(CYGPATH_W) '$(srcdir)/ftell.c'; fi`
+
+lib_a-fwrite.o: fwrite.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fwrite.o `test -f 'fwrite.c' || echo '$(srcdir)/'`fwrite.c
+
+lib_a-fwrite.obj: fwrite.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fwrite.obj `if test -f 'fwrite.c'; then $(CYGPATH_W) 'fwrite.c'; else $(CYGPATH_W) '$(srcdir)/fwrite.c'; fi`
+
+lib_a-getc.o: getc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getc.o `test -f 'getc.c' || echo '$(srcdir)/'`getc.c
+
+lib_a-getc.obj: getc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getc.obj `if test -f 'getc.c'; then $(CYGPATH_W) 'getc.c'; else $(CYGPATH_W) '$(srcdir)/getc.c'; fi`
+
+lib_a-getchar.o: getchar.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getchar.o `test -f 'getchar.c' || echo '$(srcdir)/'`getchar.c
+
+lib_a-getchar.obj: getchar.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getchar.obj `if test -f 'getchar.c'; then $(CYGPATH_W) 'getchar.c'; else $(CYGPATH_W) '$(srcdir)/getchar.c'; fi`
+
+lib_a-gets.o: gets.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gets.o `test -f 'gets.c' || echo '$(srcdir)/'`gets.c
+
+lib_a-gets.obj: gets.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gets.obj `if test -f 'gets.c'; then $(CYGPATH_W) 'gets.c'; else $(CYGPATH_W) '$(srcdir)/gets.c'; fi`
+
+lib_a-putc.o: putc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-putc.o `test -f 'putc.c' || echo '$(srcdir)/'`putc.c
+
+lib_a-putc.obj: putc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-putc.obj `if test -f 'putc.c'; then $(CYGPATH_W) 'putc.c'; else $(CYGPATH_W) '$(srcdir)/putc.c'; fi`
+
+lib_a-remove.o: remove.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-remove.o `test -f 'remove.c' || echo '$(srcdir)/'`remove.c
+
+lib_a-remove.obj: remove.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-remove.obj `if test -f 'remove.c'; then $(CYGPATH_W) 'remove.c'; else $(CYGPATH_W) '$(srcdir)/remove.c'; fi`
+
+lib_a-rename.o: rename.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rename.o `test -f 'rename.c' || echo '$(srcdir)/'`rename.c
+
+lib_a-rename.obj: rename.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rename.obj `if test -f 'rename.c'; then $(CYGPATH_W) 'rename.c'; else $(CYGPATH_W) '$(srcdir)/rename.c'; fi`
+
+lib_a-rewind.o: rewind.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rewind.o `test -f 'rewind.c' || echo '$(srcdir)/'`rewind.c
+
+lib_a-rewind.obj: rewind.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rewind.obj `if test -f 'rewind.c'; then $(CYGPATH_W) 'rewind.c'; else $(CYGPATH_W) '$(srcdir)/rewind.c'; fi`
+
+lib_a-scanf.o: scanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-scanf.o `test -f 'scanf.c' || echo '$(srcdir)/'`scanf.c
+
+lib_a-scanf.obj: scanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-scanf.obj `if test -f 'scanf.c'; then $(CYGPATH_W) 'scanf.c'; else $(CYGPATH_W) '$(srcdir)/scanf.c'; fi`
+
+lib_a-setbuf.o: setbuf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-setbuf.o `test -f 'setbuf.c' || echo '$(srcdir)/'`setbuf.c
+
+lib_a-setbuf.obj: setbuf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-setbuf.obj `if test -f 'setbuf.c'; then $(CYGPATH_W) 'setbuf.c'; else $(CYGPATH_W) '$(srcdir)/setbuf.c'; fi`
+
+lib_a-setvbuf.o: setvbuf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-setvbuf.o `test -f 'setvbuf.c' || echo '$(srcdir)/'`setvbuf.c
+
+lib_a-setvbuf.obj: setvbuf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-setvbuf.obj `if test -f 'setvbuf.c'; then $(CYGPATH_W) 'setvbuf.c'; else $(CYGPATH_W) '$(srcdir)/setvbuf.c'; fi`
+
+lib_a-snprintf.o: snprintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-snprintf.o `test -f 'snprintf.c' || echo '$(srcdir)/'`snprintf.c
+
+lib_a-snprintf.obj: snprintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-snprintf.obj `if test -f 'snprintf.c'; then $(CYGPATH_W) 'snprintf.c'; else $(CYGPATH_W) '$(srcdir)/snprintf.c'; fi`
+
+lib_a-sprintf.o: sprintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sprintf.o `test -f 'sprintf.c' || echo '$(srcdir)/'`sprintf.c
+
+lib_a-sprintf.obj: sprintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sprintf.obj `if test -f 'sprintf.c'; then $(CYGPATH_W) 'sprintf.c'; else $(CYGPATH_W) '$(srcdir)/sprintf.c'; fi`
+
+lib_a-sscanf.o: sscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sscanf.o `test -f 'sscanf.c' || echo '$(srcdir)/'`sscanf.c
+
+lib_a-sscanf.obj: sscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sscanf.obj `if test -f 'sscanf.c'; then $(CYGPATH_W) 'sscanf.c'; else $(CYGPATH_W) '$(srcdir)/sscanf.c'; fi`
+
+lib_a-tmpfile.o: tmpfile.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-tmpfile.o `test -f 'tmpfile.c' || echo '$(srcdir)/'`tmpfile.c
+
+lib_a-tmpfile.obj: tmpfile.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-tmpfile.obj `if test -f 'tmpfile.c'; then $(CYGPATH_W) 'tmpfile.c'; else $(CYGPATH_W) '$(srcdir)/tmpfile.c'; fi`
+
+lib_a-tmpnam.o: tmpnam.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-tmpnam.o `test -f 'tmpnam.c' || echo '$(srcdir)/'`tmpnam.c
+
+lib_a-tmpnam.obj: tmpnam.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-tmpnam.obj `if test -f 'tmpnam.c'; then $(CYGPATH_W) 'tmpnam.c'; else $(CYGPATH_W) '$(srcdir)/tmpnam.c'; fi`
+
+lib_a-ungetc.o: ungetc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ungetc.o `test -f 'ungetc.c' || echo '$(srcdir)/'`ungetc.c
+
+lib_a-ungetc.obj: ungetc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ungetc.obj `if test -f 'ungetc.c'; then $(CYGPATH_W) 'ungetc.c'; else $(CYGPATH_W) '$(srcdir)/ungetc.c'; fi`
+
+lib_a-vfprintf.o: vfprintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vfprintf.o `test -f 'vfprintf.c' || echo '$(srcdir)/'`vfprintf.c
+
+lib_a-vfprintf.obj: vfprintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vfprintf.obj `if test -f 'vfprintf.c'; then $(CYGPATH_W) 'vfprintf.c'; else $(CYGPATH_W) '$(srcdir)/vfprintf.c'; fi`
+
+lib_a-vfscanf.o: vfscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vfscanf.o `test -f 'vfscanf.c' || echo '$(srcdir)/'`vfscanf.c
+
+lib_a-vfscanf.obj: vfscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vfscanf.obj `if test -f 'vfscanf.c'; then $(CYGPATH_W) 'vfscanf.c'; else $(CYGPATH_W) '$(srcdir)/vfscanf.c'; fi`
+
+lib_a-vscanf.o: vscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vscanf.o `test -f 'vscanf.c' || echo '$(srcdir)/'`vscanf.c
+
+lib_a-vscanf.obj: vscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vscanf.obj `if test -f 'vscanf.c'; then $(CYGPATH_W) 'vscanf.c'; else $(CYGPATH_W) '$(srcdir)/vscanf.c'; fi`
+
+lib_a-vsscanf.o: vsscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vsscanf.o `test -f 'vsscanf.c' || echo '$(srcdir)/'`vsscanf.c
+
+lib_a-vsscanf.obj: vsscanf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vsscanf.obj `if test -f 'vsscanf.c'; then $(CYGPATH_W) 'vsscanf.c'; else $(CYGPATH_W) '$(srcdir)/vsscanf.c'; fi`
+
+lib_a-wbuf.o: wbuf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wbuf.o `test -f 'wbuf.c' || echo '$(srcdir)/'`wbuf.c
+
+lib_a-wbuf.obj: wbuf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wbuf.obj `if test -f 'wbuf.c'; then $(CYGPATH_W) 'wbuf.c'; else $(CYGPATH_W) '$(srcdir)/wbuf.c'; fi`
 uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/perror.c newlib-1.15.0/newlib/libc/machine/spu/perror.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/perror.c	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/perror.c	2007-06-12 16:59:18.000000000 -0300
@@ -7,7 +7,7 @@
 	_CONST char *s)
 
 {
-  send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PERROR, &s);
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PERROR, &s);
 
   return;
 }
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/printf.c newlib-1.15.0/newlib/libc/machine/spu/printf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/printf.c	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/printf.c	2007-06-12 16:59:18.000000000 -0300
@@ -45,7 +45,7 @@
 
 
   /*  ret = vfprintf (_stdout_r (_REENT), fmt, ap);*/
-  send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VPRINTF, &args);
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VPRINTF, &args);
 
   va_end (args.ap);
   return *ret;
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/putc.c newlib-1.15.0/newlib/libc/machine/spu/putc.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/putc.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/putc.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,32 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  int ch;
+  unsigned int pad0[ 3 ];
+  FILE* fp;
+  unsigned int pad1[ 3 ];
+} c99_putc_t;
+
+#undef putc
+
+int
+putc (c, fp)
+     int c;
+     register FILE *fp;
+{
+  int* ret;
+  c99_putc_t args;
+  args.ch = c;
+  args.fp = translate_fp(fp);
+  ret = (int*)&args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PUTC, &args);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/putchar.c newlib-1.15.0/newlib/libc/machine/spu/putchar.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/putchar.c	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/putchar.c	2007-06-12 16:59:18.000000000 -0300
@@ -10,7 +10,7 @@
 {
   /* c gets overwritten before return */
 
-  send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PUTCHAR, &c);
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PUTCHAR, &c);
 
   return c;
 }
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/puts.c newlib-1.15.0/newlib/libc/machine/spu/puts.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/puts.c	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/puts.c	2007-06-12 16:59:18.000000000 -0300
@@ -9,7 +9,7 @@
 
   /* The return value gets written over s
    */
-  send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PUTS, &s);
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_PUTS, &s);
 
   return (int)s;
 }
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/remove.c newlib-1.15.0/newlib/libc/machine/spu/remove.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/remove.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/remove.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,16 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+int
+remove (filename)
+     _CONST char *filename;
+{
+
+  /* The return value gets written over buf
+   */
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_REMOVE, &filename);
+
+  return (int)filename;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/rename.c newlib-1.15.0/newlib/libc/machine/spu/rename.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/rename.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/rename.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,29 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  char *old;
+  unsigned int pad0[ 3 ];
+  char *new;
+  unsigned int pad1[ 3 ];
+} c99_rename_t;
+
+int
+rename (old, new)
+     _CONST char *old;
+     _CONST char *new;
+{
+  int *ret;
+  c99_rename_t args;
+  args.old = old;
+  args.new = new;
+  ret = (int*) &args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_RENAME, &args);
+
+  return *ret;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/rewind.c newlib-1.15.0/newlib/libc/machine/spu/rewind.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/rewind.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/rewind.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,16 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+void
+_DEFUN (rewind, (fp),
+	FILE * fp)
+{
+  FILE* myfp;
+  myfp = translate_fp(fp);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_REWIND, &myfp);
+
+  return;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/scanf.c newlib-1.15.0/newlib/libc/machine/spu/scanf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/scanf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/scanf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,39 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  char* fmt;
+  unsigned int pad0[ 3 ];
+  va_list ap;
+} c99_vscanf_t;
+
+scanf(_CONST char *fmt, ...)
+{
+  int* ret;
+  c99_vscanf_t args;
+  ret = (int*) &args;
+
+  args.fmt = (char*) fmt;
+#ifdef _HAVE_STDC
+  va_start (args.ap, args.fmt);
+#else
+  va_start (args.ap);
+#endif
+
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSCANF, &args);
+
+  va_end (args.ap);
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/setbuf.c newlib-1.15.0/newlib/libc/machine/spu/setbuf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/setbuf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/setbuf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,28 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  FILE* fp;
+  unsigned int pad0[ 3 ];
+  char *buf;
+  unsigned int pad1[ 3 ];
+} c99_setbuf_t;
+
+void
+_DEFUN (setbuf, (fp, buf),
+	FILE * fp _AND
+	char *buf)
+{
+  c99_setbuf_t args;
+  args.fp = translate_fp(fp);
+  args.buf = buf;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_SETBUF, &args);
+
+  return;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/setvbuf.c newlib-1.15.0/newlib/libc/machine/spu/setvbuf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/setvbuf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/setvbuf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,38 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  FILE* fp;
+  unsigned int pad0[ 3 ];
+  char *buf;
+  unsigned int pad1[ 3 ];
+  int mode;
+  unsigned int pad2[ 3 ];
+  size_t size;
+  unsigned int pad3[ 3 ];
+} c99_setvbuf_t;
+
+int
+_DEFUN (setvbuf, (fp, buf, mode, size),
+	FILE * fp _AND
+	char *buf _AND
+	int mode _AND
+	size_t size)
+{
+  int* ret;
+  c99_setvbuf_t args;
+  args.fp = translate_fp(fp);
+  args.buf = buf;
+  args.mode = mode;
+  args.size = size;
+  ret = (int*)&args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_SETVBUF, &args);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/snprintf.c newlib-1.15.0/newlib/libc/machine/spu/snprintf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/snprintf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/snprintf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,46 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  char* str;
+  unsigned int pad0[ 3 ];
+  size_t size;
+  unsigned int pad1[ 3 ];
+  char* fmt;
+  unsigned int pad2[ 3 ];
+  va_list ap;
+} c99_snprintf_t;
+
+_DEFUN(snprintf, (str, size, fmt),
+       char *str   _AND
+       size_t size _AND
+       _CONST char *fmt _DOTS)
+{
+  int* ret;
+  c99_snprintf_t args;
+  ret = (int*) &args;
+
+  args.str = str;
+  args.size = size;
+  args.fmt = fmt;
+#ifdef _HAVE_STDC
+  va_start (args.ap, args.fmt);
+#else
+  va_start (args.ap);
+#endif
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSNPRINTF, &args);
+
+  va_end (args.ap);
+  return *ret;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/sprintf.c newlib-1.15.0/newlib/libc/machine/spu/sprintf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/sprintf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/sprintf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,42 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  char* str;
+  unsigned int pad0[ 3 ];
+  char* fmt;
+  unsigned int pad1[ 3 ];
+  va_list ap;
+} c99_sprintf_t;
+
+_DEFUN(sprintf, (str, fmt),
+       char *str _AND
+       _CONST char *fmt _DOTS)
+{
+  int* ret;
+  c99_sprintf_t args;
+  ret = (int*) &args;
+
+  args.str = str;
+  args.fmt = fmt;
+#ifdef _HAVE_STDC
+  va_start (args.ap, args.fmt);
+#else
+  va_start (args.ap);
+#endif
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSPRINTF, &args);
+
+  va_end (args.ap);
+  return *ret;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/sscanf.c newlib-1.15.0/newlib/libc/machine/spu/sscanf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/sscanf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/sscanf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,44 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  char* str;
+  unsigned int pad0[ 3 ];
+  char* fmt;
+  unsigned int pad1[ 3 ];
+  va_list ap;
+} c99_sscanf_t;
+
+int
+_DEFUN(sscanf, (str, fmt),
+       _CONST char *str _AND
+       _CONST char *fmt _DOTS)
+{
+  int* ret;
+  c99_sscanf_t args;
+  ret = (int*) &args;
+
+  args.str = str;
+  args.fmt = fmt;
+#ifdef _HAVE_STDC
+  va_start (args.ap, args.fmt);
+#else
+  va_start (args.ap);
+#endif
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSSCANF, &args);
+
+  va_end (args.ap);
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/strxfrm.c newlib-1.15.0/newlib/libc/machine/spu/strxfrm.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/strxfrm.c	2006-10-27 20:02:00.000000000 -0300
+++ newlib-1.15.0/newlib/libc/machine/spu/strxfrm.c	2007-06-12 16:59:18.000000000 -0300
@@ -34,6 +34,7 @@
 #include <stddef.h>
 #include <string.h>
 
+#define min(a, b)  (a) < (b) ? (a) : (b)
 
 /* The strxfrm() function transforms the src string into a form such that
  * the result of strcmp() on two strings that have been transformed with
@@ -54,13 +55,7 @@
   size_t len;
 
   len = strlen(src);
+  (void)memcpy((void *)dest, (void *)src, min(n,len + 1));
 
-  /* Since the destination is indeterminant if n is less than of equal
-   * to the string length, we skip performing the copy (altogether) in
-   * this case.
-   */
-  if (n > len) {
-    (void)memcpy((void *)dest, (void *)src, n);
-  }
-  return (len);
+  return len;
 }
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/sys/fenv.h newlib-1.15.0/newlib/libc/machine/spu/sys/fenv.h
--- orig.newlib-1.15.0/newlib/libc/machine/spu/sys/fenv.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/sys/fenv.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,120 @@
+/* -------------------------------------------------------------- */
+/* (C) Copyright 2001,2006                                       */
+/* International Business Machines Corporation,                   */
+/* Sony Computer Entertainment Incorporated,                      */
+/* Toshiba Corporation.                                           */
+/*                                                                */
+/* All Rights Reserved.                                           */
+/* -------------------------------------------------------------- */
+#ifndef _FENV_H
+#define _FENV_H
+
+/*
+ * The exception macros are such that the functions to pack/unpack them
+ * will map a 32 bit fenv_t from/to the 128 bit fpscr.
+ *
+ * Suffixes:
+ * _SNGL: single precision
+ * _DBL:  double precision
+ * _N:    element number, no suffix for element 0.
+ */
+
+#define FE_OVERFLOW_SNGL	0x08000000
+#define FE_UNDERFLOW_SNGL	0x04000000
+#define FE_DIFF_SNGL		0x02000000
+#define FE_DIVBYZERO_SNGL	0x00000040
+
+#define FE_OVERFLOW_SNGL_1	0x00040000
+#define FE_UNDERFLOW_SNGL_1	0x00020000
+#define FE_DIFF_SNGL_1		0x00010000
+#define FE_DIVBYZERO_SNGL_1	0x00000020
+
+#define FE_OVERFLOW_SNGL_2	0x00000200
+#define FE_UNDERFLOW_SNGL_2	0x00000100
+#define FE_DIFF_SNGL_2		0x00000080
+#define FE_DIVBYZERO_SNGL_2	0x00000010
+
+#define FE_OVERFLOW_SNGL_3	0x00000004
+#define FE_UNDERFLOW_SNGL_3	0x00000002
+#define FE_DIFF_SNGL_3		0x00000001
+#define FE_DIVBYZERO_SNGL_3	0x00000008
+
+#define FE_ALL_EXCEPT_SNGL	(FE_OVERFLOW_SNGL | FE_UNDERFLOW_SNGL \
+				| FE_DIFF_SNGL | FE_DIVBYZERO_SNGL)
+#define FE_ALL_EXCEPT_SNGL_1	(FE_OVERFLOW_SNGL_1 | FE_UNDERFLOW_SNGL_1 \
+				| FE_DIFF_SNGL_1 | FE_DIVBYZERO_SNGL_1)
+#define FE_ALL_EXCEPT_SNGL_2	(FE_OVERFLOW_SNGL_2 | FE_UNDERFLOW_SNGL_2 \
+				| FE_DIFF_SNGL_2 | FE_DIVBYZERO_SNGL_2)
+#define FE_ALL_EXCEPT_SNGL_3	(FE_OVERFLOW_SNGL_3 | FE_UNDERFLOW_SNGL_3 \
+				| FE_DIFF_SNGL_3 | FE_DIVBYZERO_SNGL_3)
+
+#define FE_OVERFLOW_DBL		0x01000000
+#define FE_UNDERFLOW_DBL	0x00800000
+#define FE_INEXACT_DBL		0x00400000
+#define FE_INVALID_DBL		0x00200000
+#define FE_NC_NAN_DBL 		0x00100000
+#define FE_NC_DENORM_DBL	0x00080000
+
+#define FE_OVERFLOW_DBL_1	0x00008000
+#define FE_UNDERFLOW_DBL_1	0x00004000
+#define FE_INEXACT_DBL_1	0x00002000
+#define FE_INVALID_DBL_1	0x00001000
+#define FE_NC_NAN_DBL_1 	0x00000800
+#define FE_NC_DENORM_DBL_1 	0x00000400
+
+#define FE_ALL_EXCEPT_DBL	(FE_OVERFLOW_DBL | FE_UNDERFLOW_DBL | \
+				FE_INEXACT_DBL | FE_INVALID_DBL | \
+				FE_NC_NAN_DBL | FE_NC_DENORM_DBL)
+#define FE_ALL_EXCEPT_DBL_1	(FE_OVERFLOW_DBL_1 | FE_UNDERFLOW_DBL_1 | \
+				FE_INEXACT_DBL_1 | FE_INVALID_DBL_1 | \
+				FE_NC_NAN_DBL_1 | FE_NC_DENORM_DBL_1)
+
+#define FE_ALL_EXCEPT	        (FE_ALL_EXCEPT_SNGL | FE_ALL_EXCEPT_SNGL_1 | \
+				FE_ALL_EXCEPT_SNGL_2 | FE_ALL_EXCEPT_SNGL_3 | \
+				FE_ALL_EXCEPT_DBL | FE_ALL_EXCEPT_DBL_1)
+
+/*
+ * Warning: some of these are single and some double precision only,
+ * because of the hardware implementation.
+ */
+#define FE_DIVBYZERO		(FE_DIVBYZERO_SNGL | FE_DIVBYZERO_SNGL_1 | \
+				FE_DIVBYZERO_SNGL_2 | FE_DIVBYZERO_SNGL_3)
+#define FE_INEXACT		(FE_INEXACT_DBL | FE_INEXACT_DBL_1)
+#define FE_INVALID		(FE_INVALID_DBL | FE_INVALID_DBL_1)
+#define FE_NC_NAN		(FE_NC_NAN_DBL | FE_NC_NAN_DBL_1)
+#define FE_NC_DENORM		(FE_NC_DENORM_DBL | FE_NC_DENORM_DBL_1)
+
+/*
+ * __FE_ROUND_ELE_n values are set so that they can easily be used as a
+ * mask when setting the fpscr. These tell us whether we are setting the
+ * round mode for a specific element (double precision floating point
+ * only, so there are only two elements).
+ */
+#define __FE_ROUND_ELE_0	0xc00
+#define __FE_ROUND_ELE_1	0x300
+
+/*
+ * The following map directly to round values in the fpscr.
+ */
+#define __FE_SPU_TONEAREST	0
+#define __FE_SPU_TOWARDZERO	1
+#define __FE_SPU_UPWARD		2
+#define __FE_SPU_DOWNWARD	3
+
+#define FE_TONEAREST	(__FE_ROUND_ELE_0 | (__FE_SPU_TONEAREST << 2))
+#define FE_TOWARDZERO	(__FE_ROUND_ELE_0 | (__FE_SPU_TOWARDZERO << 2))
+#define FE_UPWARD	(__FE_ROUND_ELE_0 | (__FE_SPU_UPWARD << 2))
+#define FE_DOWNWARD	(__FE_ROUND_ELE_0 | (__FE_SPU_DOWNWARD << 2))
+
+#define FE_TONEAREST_1	(__FE_ROUND_ELE_1 | __FE_SPU_TONEAREST)
+#define FE_TOWARDZERO_1	(__FE_ROUND_ELE_1 | __FE_SPU_TOWARDZERO)
+#define FE_UPWARD_1	(__FE_ROUND_ELE_1 | __FE_SPU_UPWARD)
+#define FE_DOWNWARD_1	(__FE_ROUND_ELE_1 | __FE_SPU_DOWNWARD)
+
+typedef unsigned int fexcept_t;
+typedef unsigned int fenv_t;
+
+extern const fenv_t __fe_dfl_env;
+#define FE_DFL_ENV	(&__fe_dfl_env)
+
+#endif /* fenv.h */
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/sys/send_to_ppe.h newlib-1.15.0/newlib/libc/machine/spu/sys/send_to_ppe.h
--- orig.newlib-1.15.0/newlib/libc/machine/spu/sys/send_to_ppe.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/sys/send_to_ppe.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#ifndef __SEND_TO_PPE_H_
+#define __SEND_TO_PPE_H_
+
+void __send_to_ppe(unsigned int signalcode, unsigned int opcode, void *data);
+
+#endif /* __SEND_TO_PPE_H_ */
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/tmpfile.c newlib-1.15.0/newlib/libc/machine/spu/tmpfile.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/tmpfile.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/tmpfile.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,14 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+FILE *
+_DEFUN_VOID (tmpfile)
+{
+  FILE* ret;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_TMPFILE, &ret);
+
+  return ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/tmpnam.c newlib-1.15.0/newlib/libc/machine/spu/tmpnam.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/tmpnam.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/tmpnam.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,16 @@
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+char *
+_DEFUN (tmpnam, (s),
+	char *s)
+{
+  char **ret = &s;
+  /* The return value gets written over buf
+   */
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_TMPNAM, &s);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/ungetc.c newlib-1.15.0/newlib/libc/machine/spu/ungetc.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/ungetc.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/ungetc.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,30 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+typedef struct
+{
+  int c;
+  unsigned int pad0[ 3 ];
+  FILE* fp;
+  unsigned int pad1[ 3 ];
+} c99_ungetc_t;
+
+int
+ungetc (c, fp)
+     int c;
+     register FILE *fp;
+{
+  int* ret;
+  c99_ungetc_t args;
+  args.c = c;
+  args.fp = translate_fp(fp);
+  ret = (int*)&args;
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_UNGETC, &args);
+
+  return *ret;
+}
+
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/vfprintf.c newlib-1.15.0/newlib/libc/machine/spu/vfprintf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/vfprintf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/vfprintf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,43 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  FILE * fp;
+  unsigned int pad0[ 3 ];
+  char* fmt;
+  unsigned int pad1[ 3 ];
+  va_list ap;
+} c99_vfprintf_t;
+
+#ifndef _REENT_ONLY
+
+int
+_DEFUN (vfprintf, (fp, fmt0, ap),
+	FILE * fp _AND
+	_CONST char *fmt0 _AND
+	va_list ap)
+{
+  int* ret;
+  c99_vfprintf_t args;
+  ret = (int*) &args;
+
+  args.fp = translate_fp(fp);
+  args.fmt = (char*) fmt0;
+  va_copy(args.ap,ap);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VFPRINTF, &args);
+
+  return *ret;
+}
+
+#endif /* ! _REENT_ONLY */
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/vfscanf.c newlib-1.15.0/newlib/libc/machine/spu/vfscanf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/vfscanf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/vfscanf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,43 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  FILE * fp;
+  unsigned int pad0[ 3 ];
+  char* fmt;
+  unsigned int pad1[ 3 ];
+  va_list ap;
+} c99_vfscanf_t;
+
+#ifndef _REENT_ONLY
+
+int
+_DEFUN (vfscanf, (fp, fmt, ap),
+    FILE *fp _AND
+    _CONST char *fmt _AND
+    va_list ap)
+{
+  int* ret;
+  c99_vfscanf_t args;
+  ret = (int*) &args;
+
+  args.fp = translate_fp(fp);
+  args.fmt = (char*) fmt;
+  va_copy(args.ap,ap);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VFSCANF, &args);
+
+  return *ret;
+}
+
+#endif /* ! _REENT_ONLY */
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/vprintf.c newlib-1.15.0/newlib/libc/machine/spu/vprintf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/vprintf.c	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/vprintf.c	2007-06-12 16:59:18.000000000 -0300
@@ -31,7 +31,7 @@
   args.fmt = (char*) fmt;
   va_copy(args.ap,ap);
 
-  send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VPRINTF, &args);
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VPRINTF, &args);
 
   return *ret;
 }
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/vscanf.c newlib-1.15.0/newlib/libc/machine/spu/vscanf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/vscanf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/vscanf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,39 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  char* fmt;
+  unsigned int pad0[ 3 ];
+  va_list ap;
+} c99_vscanf_t;
+
+#ifndef _REENT_ONLY
+
+int
+_DEFUN (vscanf, (fmt, ap),
+     _CONST char *fmt _AND
+     va_list ap)
+{
+  int* ret;
+  c99_vscanf_t args;
+  ret = (int*) &args;
+
+  args.fmt = (char*) fmt;
+  va_copy(args.ap,ap);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSCANF, &args);
+
+  return *ret;
+}
+
+#endif /* ! _REENT_ONLY */
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/vsnprintf.c newlib-1.15.0/newlib/libc/machine/spu/vsnprintf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/vsnprintf.c	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/vsnprintf.c	2007-06-12 16:59:18.000000000 -0300
@@ -39,7 +39,7 @@
   args.fmt = fmt;
   va_copy(args.ap,ap);
 
-  send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSNPRINTF, &args);
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSNPRINTF, &args);
 
   return *ret;
 }
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/vsprintf.c newlib-1.15.0/newlib/libc/machine/spu/vsprintf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/vsprintf.c	2006-12-18 16:39:02.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/vsprintf.c	2007-06-12 16:59:18.000000000 -0300
@@ -33,7 +33,7 @@
   args.fmt = (char*) fmt;
   va_copy(args.ap,ap);
 
-  send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSPRINTF, &args);
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSPRINTF, &args);
 
   return *ret;
 }
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/vsscanf.c newlib-1.15.0/newlib/libc/machine/spu/vsscanf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/vsscanf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/vsscanf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,39 @@
+
+#include <_ansi.h>
+#include <stdio.h>
+
+#include "c99ppe.h"
+
+#ifdef _HAVE_STDC
+#include <stdarg.h>
+#else
+#include <varargs.h>
+#endif
+
+typedef struct
+{
+  char *str;
+  unsigned int pad0[ 3 ];
+  char *fmt;
+  unsigned int pad1[ 3 ];
+  va_list ap;
+} c99_vsscanf_t;
+
+int
+_DEFUN (vsscanf, (str, fmt, ap),
+    _CONST char *str _AND
+    _CONST char *fmt _AND
+    va_list ap)
+{
+  int* ret;
+  c99_vsscanf_t args;
+  ret = (int*) &args;
+
+  args.str = str;
+  args.fmt = (char*) fmt;
+  va_copy(args.ap,ap);
+
+  __send_to_ppe(SPE_C99_SIGNALCODE, SPE_C99_VSSCANF, &args);
+
+  return *ret;
+}
diff -burN orig.newlib-1.15.0/newlib/libc/machine/spu/wbuf.c newlib-1.15.0/newlib/libc/machine/spu/wbuf.c
--- orig.newlib-1.15.0/newlib/libc/machine/spu/wbuf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/machine/spu/wbuf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,9 @@
+#include <stdio.h>
+
+int
+_DEFUN(__swbuf, (c, fp),
+       int c _AND
+       FILE *fp)
+{
+  return fputc(c, fp);
+}
diff -burN orig.newlib-1.15.0/newlib/libc/reent/gettimeofdayr.c newlib-1.15.0/newlib/libc/reent/gettimeofdayr.c
--- orig.newlib-1.15.0/newlib/libc/reent/gettimeofdayr.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/reent/gettimeofdayr.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,76 @@
+/* Reentrant version of gettimeofday system call
+   This implementation just calls the times/gettimeofday system calls.
+   Gettimeofday may not be available on all targets.  It's presence
+   here is dubious.  Consider it for internal use only.  */
+
+#include <reent.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <_syslist.h>
+
+/* Some targets provides their own versions of these functions.  Those
+   targets should define REENTRANT_SYSCALLS_PROVIDED in TARGET_CFLAGS.  */
+
+#ifdef _REENT_ONLY
+#ifndef REENTRANT_SYSCALLS_PROVIDED
+#define REENTRANT_SYSCALLS_PROVIDED
+#endif
+#endif
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+
+int _dummy_time_syscalls = 1;
+
+#else
+
+/* We use the errno variable used by the system dependent layer.  */
+#undef errno
+extern int errno;
+
+/*
+FUNCTION
+	<<_gettimeofday_r>>---Reentrant version of gettimeofday
+
+INDEX
+	_gettimeofday_r
+
+ANSI_SYNOPSIS
+	#include <reent.h>
+	#include <time.h>
+	int _gettimeofday_r(struct _reent *<[ptr]>,
+		struct timeval *<[ptimeval]>,
+		struct timezone *<[ptimezone]>);
+
+TRAD_SYNOPSIS
+	#include <reent.h>
+	#include <time.h>
+	int _gettimeofday_r(<[ptr]>, <[ptimeval]>, <[ptimezone]>)
+	struct _reent *<[ptr]>;
+	struct timeval *<[ptimeval]>;
+	struct timezone *<[ptimezone]>;
+
+DESCRIPTION
+	This is a reentrant version of <<gettimeofday>>.  It
+	takes a pointer to the global data block, which holds
+	<<errno>>.
+
+	This function is only available for a few targets.
+	Check libc.a to see if its available on yours.
+*/
+
+int
+_DEFUN (_gettimeofday_r, (ptr, ptimeval, ptimezone),
+     struct _reent *ptr _AND
+     struct timeval *ptimeval _AND
+     struct timezone *ptimezone)
+{
+  int ret;
+
+  errno = 0;
+  if ((ret = _gettimeofday (ptimeval, ptimezone)) == -1 && errno != 0)
+    ptr->_errno = errno;
+  return ret;
+}
+
+#endif /* ! defined (REENTRANT_SYSCALLS_PROVIDED) */
diff -burN orig.newlib-1.15.0/newlib/libc/reent/Makefile.am newlib-1.15.0/newlib/libc/reent/Makefile.am
--- orig.newlib-1.15.0/newlib/libc/reent/Makefile.am	2006-05-01 19:01:02.000000000 -0300
+++ newlib-1.15.0/newlib/libc/reent/Makefile.am	2007-06-12 16:59:18.000000000 -0300
@@ -36,6 +36,7 @@
 	fcntlr.c \
 	fstatr.c \
 	getreent.c \
+	gettimeofdayr.c \
 	linkr.c \
 	lseekr.c \
 	openr.c \
@@ -44,7 +45,7 @@
 	signgam.c \
 	sbrkr.c \
 	statr.c \
-	timer.c \
+	timesr.c \
 	unlinkr.c \
 	writer.c
 
@@ -69,6 +70,7 @@
 	execr.def \
 	fcntlr.def \
 	fstatr.def \
+	gettimeofdayr.def \
 	linkr.def \
 	lseekr.def \
 	openr.def \
@@ -76,7 +78,7 @@
 	signalr.def \
 	sbrkr.def \
 	statr.def \
-	timer.def \
+	timesr.def \
 	unlinkr.def \
 	$(STDIO64_DEFS) \
 	writer.def
diff -burN orig.newlib-1.15.0/newlib/libc/reent/Makefile.in newlib-1.15.0/newlib/libc/reent/Makefile.in
--- orig.newlib-1.15.0/newlib/libc/reent/Makefile.in	2006-12-18 16:32:47.000000000 -0400
+++ newlib-1.15.0/newlib/libc/reent/Makefile.in	2007-06-12 16:59:18.000000000 -0300
@@ -55,12 +55,12 @@
 am__objects_1 = lib_a-closer.$(OBJEXT) lib_a-reent.$(OBJEXT) \
 	lib_a-impure.$(OBJEXT) lib_a-fcntlr.$(OBJEXT) \
 	lib_a-fstatr.$(OBJEXT) lib_a-getreent.$(OBJEXT) \
-	lib_a-linkr.$(OBJEXT) lib_a-lseekr.$(OBJEXT) \
-	lib_a-openr.$(OBJEXT) lib_a-readr.$(OBJEXT) \
-	lib_a-signalr.$(OBJEXT) lib_a-signgam.$(OBJEXT) \
-	lib_a-sbrkr.$(OBJEXT) lib_a-statr.$(OBJEXT) \
-	lib_a-timer.$(OBJEXT) lib_a-unlinkr.$(OBJEXT) \
-	lib_a-writer.$(OBJEXT)
+	lib_a-gettimeofdayr.$(OBJEXT) lib_a-linkr.$(OBJEXT) \
+	lib_a-lseekr.$(OBJEXT) lib_a-openr.$(OBJEXT) \
+	lib_a-readr.$(OBJEXT) lib_a-signalr.$(OBJEXT) \
+	lib_a-signgam.$(OBJEXT) lib_a-sbrkr.$(OBJEXT) \
+	lib_a-statr.$(OBJEXT) lib_a-timesr.$(OBJEXT) \
+	lib_a-unlinkr.$(OBJEXT) lib_a-writer.$(OBJEXT)
 @HAVE_STDIO64_DIR_TRUE@am__objects_2 = lib_a-fstat64r.$(OBJEXT) \
 @HAVE_STDIO64_DIR_TRUE@	lib_a-lseek64r.$(OBJEXT) \
 @HAVE_STDIO64_DIR_TRUE@	lib_a-open64r.$(OBJEXT)
@@ -77,8 +77,9 @@
 LTLIBRARIES = $(noinst_LTLIBRARIES)
 libreent_la_LIBADD =
 am__objects_6 = closer.lo reent.lo impure.lo fcntlr.lo fstatr.lo \
-	getreent.lo linkr.lo lseekr.lo openr.lo readr.lo signalr.lo \
-	signgam.lo sbrkr.lo statr.lo timer.lo unlinkr.lo writer.lo
+	getreent.lo gettimeofdayr.lo linkr.lo lseekr.lo openr.lo \
+	readr.lo signalr.lo signgam.lo sbrkr.lo statr.lo timesr.lo \
+	unlinkr.lo writer.lo
 @HAVE_STDIO64_DIR_TRUE@am__objects_7 = fstat64r.lo lseek64r.lo \
 @HAVE_STDIO64_DIR_TRUE@	open64r.lo
 am__objects_8 = $(am__objects_7)
@@ -271,6 +272,7 @@
 	fcntlr.c \
 	fstatr.c \
 	getreent.c \
+	gettimeofdayr.c \
 	linkr.c \
 	lseekr.c \
 	openr.c \
@@ -279,7 +281,7 @@
 	signgam.c \
 	sbrkr.c \
 	statr.c \
-	timer.c \
+	timesr.c \
 	unlinkr.c \
 	writer.c
 
@@ -297,6 +299,7 @@
 	execr.def \
 	fcntlr.def \
 	fstatr.def \
+	gettimeofdayr.def \
 	linkr.def \
 	lseekr.def \
 	openr.def \
@@ -304,7 +307,7 @@
 	signalr.def \
 	sbrkr.def \
 	statr.def \
-	timer.def \
+	timesr.def \
 	unlinkr.def \
 	$(STDIO64_DEFS) \
 	writer.def
@@ -416,6 +419,12 @@
 lib_a-getreent.obj: getreent.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getreent.obj `if test -f 'getreent.c'; then $(CYGPATH_W) 'getreent.c'; else $(CYGPATH_W) '$(srcdir)/getreent.c'; fi`
 
+lib_a-gettimeofdayr.o: gettimeofdayr.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gettimeofdayr.o `test -f 'gettimeofdayr.c' || echo '$(srcdir)/'`gettimeofdayr.c
+
+lib_a-gettimeofdayr.obj: gettimeofdayr.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gettimeofdayr.obj `if test -f 'gettimeofdayr.c'; then $(CYGPATH_W) 'gettimeofdayr.c'; else $(CYGPATH_W) '$(srcdir)/gettimeofdayr.c'; fi`
+
 lib_a-linkr.o: linkr.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-linkr.o `test -f 'linkr.c' || echo '$(srcdir)/'`linkr.c
 
@@ -464,11 +473,11 @@
 lib_a-statr.obj: statr.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-statr.obj `if test -f 'statr.c'; then $(CYGPATH_W) 'statr.c'; else $(CYGPATH_W) '$(srcdir)/statr.c'; fi`
 
-lib_a-timer.o: timer.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-timer.o `test -f 'timer.c' || echo '$(srcdir)/'`timer.c
+lib_a-timesr.o: timesr.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-timesr.o `test -f 'timesr.c' || echo '$(srcdir)/'`timesr.c
 
-lib_a-timer.obj: timer.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-timer.obj `if test -f 'timer.c'; then $(CYGPATH_W) 'timer.c'; else $(CYGPATH_W) '$(srcdir)/timer.c'; fi`
+lib_a-timesr.obj: timesr.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-timesr.obj `if test -f 'timesr.c'; then $(CYGPATH_W) 'timesr.c'; else $(CYGPATH_W) '$(srcdir)/timesr.c'; fi`
 
 lib_a-unlinkr.o: unlinkr.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-unlinkr.o `test -f 'unlinkr.c' || echo '$(srcdir)/'`unlinkr.c
diff -burN orig.newlib-1.15.0/newlib/libc/reent/timer.c newlib-1.15.0/newlib/libc/reent/timer.c
--- orig.newlib-1.15.0/newlib/libc/reent/timer.c	2003-06-03 16:48:07.000000000 -0300
+++ newlib-1.15.0/newlib/libc/reent/timer.c	1969-12-31 20:00:00.000000000 -0400
@@ -1,113 +0,0 @@
-/* Reentrant versions of times and gettimeofday system calls for the
-   clock and time ANSI C routines.
-   This implementation just calls the times/gettimeofday system calls.
-   Gettimeofday may not be available on all targets.  It's presence
-   here is dubious.  Consider it for internal use only.  */
-
-#include <reent.h>
-#include <time.h>
-#include <sys/time.h>
-#include <sys/times.h>
-#include <_syslist.h>
-
-/* Some targets provides their own versions of these functions.  Those
-   targets should define REENTRANT_SYSCALLS_PROVIDED in TARGET_CFLAGS.  */
-
-#ifdef _REENT_ONLY
-#ifndef REENTRANT_SYSCALLS_PROVIDED
-#define REENTRANT_SYSCALLS_PROVIDED
-#endif
-#endif
-
-#ifdef REENTRANT_SYSCALLS_PROVIDED
-
-int _dummy_time_syscalls = 1;
-
-#else
-
-/* We use the errno variable used by the system dependent layer.  */
-#undef errno
-extern int errno;
-
-/*
-FUNCTION
-	<<_times_r>>---Reentrant version of times
-	
-INDEX
-	_times_r
-
-ANSI_SYNOPSIS
-	#include <reent.h>
-	#include <sys/times.h>
-	clock_t _times_r(struct _reent *<[ptr]>, struct tms *<[ptms]>);
-
-TRAD_SYNOPSIS
-	#include <reent.h>
-	#include <sys/times.h>
-	clock_t _times_r(<[ptr]>, <[ptms]>)
-	struct _reent *<[ptr]>;
-	struct tms *<[ptms]>;
-
-DESCRIPTION
-	This is a reentrant version of <<times>>.  It
-	takes a pointer to the global data block, which holds
-	<<errno>>.
-*/
-
-clock_t
-_DEFUN (_times_r, (ptr, ptms),
-     struct _reent *ptr _AND
-     struct tms *ptms)
-{
-  clock_t ret;
-
-  ret = _times (ptms);
-  return ret;
-}
-
-/*
-FUNCTION
-	<<_gettimeofday_r>>---Reentrant version of gettimeofday
-	
-INDEX
-	_gettimeofday_r
-
-ANSI_SYNOPSIS
-	#include <reent.h>
-	#include <time.h>
-	int _gettimeofday_r(struct _reent *<[ptr]>,
-		struct timeval *<[ptimeval]>,
-		struct timezone *<[ptimezone]>);
-
-TRAD_SYNOPSIS
-	#include <reent.h>
-	#include <time.h>
-	int _gettimeofday_r(<[ptr]>, <[ptimeval]>, <[ptimezone]>)
-	struct _reent *<[ptr]>;
-	struct timeval *<[ptimeval]>;
-	struct timezone *<[ptimezone]>;
-
-DESCRIPTION
-	This is a reentrant version of <<gettimeofday>>.  It
-	takes a pointer to the global data block, which holds
-	<<errno>>.
-
-	This function is only available for a few targets.
-	Check libc.a to see if its available on yours.
-*/
-
-int
-_DEFUN (_gettimeofday_r, (ptr, ptimeval, ptimezone),
-     struct _reent *ptr _AND
-     struct timeval *ptimeval _AND
-     struct timezone *ptimezone)
-{
-  int ret;
-
-  errno = 0;
-  if ((ret = _gettimeofday (ptimeval, ptimezone)) == -1 && errno != 0)
-    ptr->_errno = errno;
-  return ret;
-}
-
-#endif /* ! defined (REENTRANT_SYSCALLS_PROVIDED) */
diff -burN orig.newlib-1.15.0/newlib/libc/reent/timesr.c newlib-1.15.0/newlib/libc/reent/timesr.c
--- orig.newlib-1.15.0/newlib/libc/reent/timesr.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libc/reent/timesr.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,63 @@
+/* Reentrant versions of times system calls */
+
+#include <reent.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <_syslist.h>
+
+/* Some targets provides their own versions of these functions.  Those
+   targets should define REENTRANT_SYSCALLS_PROVIDED in TARGET_CFLAGS.  */
+
+#ifdef _REENT_ONLY
+#ifndef REENTRANT_SYSCALLS_PROVIDED
+#define REENTRANT_SYSCALLS_PROVIDED
+#endif
+#endif
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+
+int _dummy_time_syscalls = 1;
+
+#else
+
+/* We use the errno variable used by the system dependent layer.  */
+#undef errno
+extern int errno;
+
+/*
+FUNCTION
+	<<_times_r>>---Reentrant version of times
+
+INDEX
+	_times_r
+
+ANSI_SYNOPSIS
+	#include <reent.h>
+	#include <sys/times.h>
+	clock_t _times_r(struct _reent *<[ptr]>, struct tms *<[ptms]>);
+
+TRAD_SYNOPSIS
+	#include <reent.h>
+	#include <sys/times.h>
+	clock_t _times_r(<[ptr]>, <[ptms]>)
+	struct _reent *<[ptr]>;
+	struct tms *<[ptms]>;
+
+DESCRIPTION
+	This is a reentrant version of <<times>>.  It
+	takes a pointer to the global data block, which holds
+	<<errno>>.
+*/
+
+clock_t
+_DEFUN (_times_r, (ptr, ptms),
+     struct _reent *ptr _AND
+     struct tms *ptms)
+{
+  clock_t ret;
+
+  ret = _times (ptms);
+  return ret;
+}
+#endif /* ! defined (REENTRANT_SYSCALLS_PROVIDED) */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/configure newlib-1.15.0/newlib/libm/machine/configure
--- orig.newlib-1.15.0/newlib/libm/machine/configure	2006-12-18 18:21:56.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/configure	2007-06-12 16:59:18.000000000 -0300
@@ -273,6 +273,7 @@
 
 ac_unique_file="i386"
 ac_subdirs_all="$ac_subdirs_all i386"
+ac_subdirs_all="$ac_subdirs_all spu"
 ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS MAY_SUPPLY_SYSCALLS_TRUE MAY_SUPPLY_SYSCALLS_FALSE newlib_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB READELF ac_ct_READELF MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CCAS CCASFLAGS NEWLIB_CFLAGS LDFLAGS ELIX_LEVEL_0_TRUE ELIX_LEVEL_0_FALSE ELIX_LEVEL_1_TRUE ELIX_LEVEL_1_FALSE ELIX_LEVEL_2_TRUE ELIX_LEVEL_2_FALSE ELIX_LEVEL_3_TRUE ELIX_LEVEL_3_FALSE ELIX_LEVEL_4_TRUE ELIX_LEVEL_4_FALSE USE_LIBTOOL_TRUE USE_LIBTOOL_FALSE OBJEXT oext aext lpfx libm_machine_dir machine_dir sys_dir CFLAGS CPPFLAGS ac_ct_CC EXEEXT LN_S LIBTOOL subdirs machlib HAVE_LIBM_MACHINE_DIR_TRUE HAVE_LIBM_MACHINE_DIR_FALSE LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
@@ -4629,7 +4630,7 @@
 case $host in
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 4632 "configure"' > conftest.$ac_ext
+  echo '#line 4633 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
@@ -4865,6 +4866,10 @@
 
 subdirs="$subdirs i386"
  ;;
+	spu)
+
+subdirs="$subdirs spu"
+ ;;
   esac;
   if test "${use_libtool}" = "yes"; then
     machlib=${libm_machine_dir}/lib${libm_machine_dir}.${aext}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/configure.in newlib-1.15.0/newlib/libm/machine/configure.in
--- orig.newlib-1.15.0/newlib/libm/machine/configure.in	2006-04-13 16:56:32.000000000 -0300
+++ newlib-1.15.0/newlib/libm/machine/configure.in	2007-06-12 16:59:18.000000000 -0300
@@ -25,6 +25,7 @@
 if test -n "${libm_machine_dir}"; then
   case ${libm_machine_dir} in
 	i386) AC_CONFIG_SUBDIRS(i386) ;;
+	spu) AC_CONFIG_SUBDIRS(spu) ;;
   esac;
   if test "${use_libtool}" = "yes"; then
     machlib=${libm_machine_dir}/lib${libm_machine_dir}.${aext}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/aclocal.m4 newlib-1.15.0/newlib/libm/machine/spu/aclocal.m4
--- orig.newlib-1.15.0/newlib/libm/machine/spu/aclocal.m4	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/aclocal.m4	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,880 @@
+# generated automatically by aclocal 1.9.5 -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005  Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_AUTOMAKE_VERSION(VERSION)
+# ----------------------------
+# Automake X.Y traces this macro to ensure aclocal.m4 has been
+# generated from the m4 files accompanying Automake X.Y.
+AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version="1.9"])
+
+# AM_SET_CURRENT_AUTOMAKE_VERSION
+# -------------------------------
+# Call AM_AUTOMAKE_VERSION so it can be traced.
+# This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
+	 [AM_AUTOMAKE_VERSION([1.9.5])])
+
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+#
+# Of course, Automake must honor this variable whenever it calls a
+# tool from the auxiliary directory.  The problem is that $srcdir (and
+# therefore $ac_aux_dir as well) can be either absolute or relative,
+# depending on how configure is run.  This is pretty annoying, since
+# it makes $ac_aux_dir quite unusable in subdirectories: in the top
+# source directory, any form will work fine, but in subdirectories a
+# relative path needs to be adjusted first.
+#
+# $ac_aux_dir/missing
+#    fails when called from a subdirectory if $ac_aux_dir is relative
+# $top_srcdir/$ac_aux_dir/missing
+#    fails if $ac_aux_dir is absolute,
+#    fails when called from a subdirectory in a VPATH build with
+#          a relative $ac_aux_dir
+#
+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
+# are both prefixed by $srcdir.  In an in-source build this is usually
+# harmless because $srcdir is `.', but things will broke when you
+# start a VPATH build or use an absolute $srcdir.
+#
+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
+#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
+# and then we would define $MISSING as
+#   MISSING="\${SHELL} $am_aux_dir/missing"
+# This will work as long as MISSING is not called from configure, because
+# unfortunately $(top_srcdir) has no meaning in configure.
+# However there are other variables, like CC, which are often used in
+# configure, and could therefore not use this "fixed" $ac_aux_dir.
+#
+# Another solution, used here, is to always expand $ac_aux_dir to an
+# absolute PATH.  The drawback is that using absolute paths prevent a
+# configured tree to be moved without reconfiguration.
+
+AC_DEFUN([AM_AUX_DIR_EXPAND],
+[dnl Rely on autoconf to set up CDPATH properly.
+AC_PREREQ([2.50])dnl
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+])
+
+# AM_CONDITIONAL                                            -*- Autoconf -*-
+
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 7
+
+# AM_CONDITIONAL(NAME, SHELL-CONDITION)
+# -------------------------------------
+# Define a conditional.
+AC_DEFUN([AM_CONDITIONAL],
+[AC_PREREQ(2.52)dnl
+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+AC_SUBST([$1_TRUE])
+AC_SUBST([$1_FALSE])
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi
+AC_CONFIG_COMMANDS_PRE(
+[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
+  AC_MSG_ERROR([[conditional "$1" was never defined.
+Usually this means the macro was only invoked conditionally.]])
+fi])])
+
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 8
+
+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
+
+# _AM_DEPENDENCIES(NAME)
+# ----------------------
+# See how the compiler implements dependency checking.
+# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# We try a few techniques and use that to set a single cache variable.
+#
+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
+# dependency, and given that the user is not expected to run this macro,
+# just rely on AC_PROG_CC.
+AC_DEFUN([_AM_DEPENDENCIES],
+[AC_REQUIRE([AM_SET_DEPDIR])dnl
+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
+AC_REQUIRE([AM_MAKE_INCLUDE])dnl
+AC_REQUIRE([AM_DEP_TRACK])dnl
+
+ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
+       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
+       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                   [depcc="$$1"   am_compiler_list=])
+
+AC_CACHE_CHECK([dependency style of $depcc],
+               [am_cv_$1_dependencies_compiler_type],
+[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_$1_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_$1_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_$1_dependencies_compiler_type=none
+fi
+])
+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
+AM_CONDITIONAL([am__fastdep$1], [
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
+])
+
+
+# AM_SET_DEPDIR
+# -------------
+# Choose a directory name for dependency files.
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+AC_DEFUN([AM_SET_DEPDIR],
+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
+])
+
+
+# AM_DEP_TRACK
+# ------------
+AC_DEFUN([AM_DEP_TRACK],
+[AC_ARG_ENABLE(dependency-tracking,
+[  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors])
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
+AC_SUBST([AMDEPBACKSLASH])
+])
+
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+#serial 3
+
+# _AM_OUTPUT_DEPENDENCY_COMMANDS
+# ------------------------------
+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
+[for mf in $CONFIG_FILES; do
+  # Strip MF so we end up with the name of the file.
+  mf=`echo "$mf" | sed -e 's/:.*$//'`
+  # Check whether this is an Automake generated Makefile or not.
+  # We used to match only the files named `Makefile.in', but
+  # some people rename them; so instead we look at the file content.
+  # Grep'ing the first line is not enough: some people post-process
+  # each Makefile.in and add a new line on top of each file to say so.
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
+    dirpart=`AS_DIRNAME("$mf")`
+  else
+    continue
+  fi
+  # Extract the definition of DEPDIR, am__include, and am__quote
+  # from the Makefile without running `make'.
+  DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+  test -z "$DEPDIR" && continue
+  am__include=`sed -n 's/^am__include = //p' < "$mf"`
+  test -z "am__include" && continue
+  am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+  # When using ansi2knr, U may be empty or an underscore; expand it
+  U=`sed -n 's/^U = //p' < "$mf"`
+  # Find all dependency output files, they are included files with
+  # $(DEPDIR) in their names.  We invoke sed twice because it is the
+  # simplest approach to changing $(DEPDIR) to its actual value in the
+  # expansion.
+  for file in `sed -n "
+    s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+       sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+    # Make sure the directory exists.
+    test -f "$dirpart/$file" && continue
+    fdir=`AS_DIRNAME(["$file"])`
+    AS_MKDIR_P([$dirpart/$fdir])
+    # echo "creating $dirpart/$file"
+    echo '# dummy' > "$dirpart/$file"
+  done
+done
+])# _AM_OUTPUT_DEPENDENCY_COMMANDS
+
+
+# AM_OUTPUT_DEPENDENCY_COMMANDS
+# -----------------------------
+# This macro should only be invoked once -- use via AC_REQUIRE.
+#
+# This code is only required when automatic dependency tracking
+# is enabled.  FIXME.  This creates each `.P' file that we will
+# need in order to bootstrap the dependency handling code.
+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
+[AC_CONFIG_COMMANDS([depfiles],
+     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
+     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
+])
+
+# Do all the work for Automake.                             -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 12
+
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
+
+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
+# AM_INIT_AUTOMAKE([OPTIONS])
+# -----------------------------------------------
+# The call with PACKAGE and VERSION arguments is the old style
+# call (pre autoconf-2.50), which is being phased out.  PACKAGE
+# and VERSION should now be passed to AC_INIT and removed from
+# the call to AM_INIT_AUTOMAKE.
+# We support both call styles for the transition.  After
+# the next Automake release, Autoconf can make the AC_INIT
+# arguments mandatory, and then we can depend on a new Autoconf
+# release and drop the old call support.
+AC_DEFUN([AM_INIT_AUTOMAKE],
+[AC_PREREQ([2.58])dnl
+dnl Autoconf wants to disallow AM_ names.  We explicitly allow
+dnl the ones we care about.
+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
+AC_REQUIRE([AC_PROG_INSTALL])dnl
+# test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" &&
+   test -f $srcdir/config.status; then
+  AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+AC_SUBST([CYGPATH_W])
+
+# Define the identity of the package.
+dnl Distinguish between old-style and new-style calls.
+m4_ifval([$2],
+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+ AC_SUBST([PACKAGE], [$1])dnl
+ AC_SUBST([VERSION], [$2])],
+[_AM_SET_OPTIONS([$1])dnl
+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
+
+_AM_IF_OPTION([no-define],,
+[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
+ AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+
+# Some tools Automake needs.
+AC_REQUIRE([AM_SANITY_CHECK])dnl
+AC_REQUIRE([AC_ARG_PROGRAM])dnl
+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
+AM_MISSING_PROG(AUTOCONF, autoconf)
+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
+AM_MISSING_PROG(AUTOHEADER, autoheader)
+AM_MISSING_PROG(MAKEINFO, makeinfo)
+AM_PROG_INSTALL_SH
+AM_PROG_INSTALL_STRIP
+AC_REQUIRE([AM_PROG_MKDIR_P])dnl
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
+              [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
+	      		     [_AM_PROG_TAR([v7])])])
+_AM_IF_OPTION([no-dependencies],,
+[AC_PROVIDE_IFELSE([AC_PROG_CC],
+                  [_AM_DEPENDENCIES(CC)],
+                  [define([AC_PROG_CC],
+                          defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_CXX],
+                  [_AM_DEPENDENCIES(CXX)],
+                  [define([AC_PROG_CXX],
+                          defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+])
+])
+
+
+# When config.status generates a header, we must update the stamp-h file.
+# This file resides in the same directory as the config header
+# that is generated.  The stamp files are numbered to have different names.
+
+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
+# loop where config.status creates the headers, so we can generate
+# our stamp files there.
+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
+[# Compute $1's index in $config_headers.
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $1 | $1:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $1" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_SH
+# ------------------
+# Define $install_sh.
+AC_DEFUN([AM_PROG_INSTALL_SH],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+install_sh=${install_sh-"$am_aux_dir/install-sh"}
+AC_SUBST(install_sh)])
+
+# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# Check whether the underlying file-system supports filenames
+# with a leading dot.  For instance MS-DOS doesn't.
+AC_DEFUN([AM_SET_LEADING_DOT],
+[rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+AC_SUBST([am__leading_dot])])
+
+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
+# From Jim Meyering
+
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+AC_DEFUN([AM_MAINTAINER_MODE],
+[AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
+  dnl maintainer-mode is disabled by default
+  AC_ARG_ENABLE(maintainer-mode,
+[  --enable-maintainer-mode  enable make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer],
+      USE_MAINTAINER_MODE=$enableval,
+      USE_MAINTAINER_MODE=no)
+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])
+  AM_CONDITIONAL(MAINTAINER_MODE, [test $USE_MAINTAINER_MODE = yes])
+  MAINT=$MAINTAINER_MODE_TRUE
+  AC_SUBST(MAINT)dnl
+]
+)
+
+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
+
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
+
+# AM_MAKE_INCLUDE()
+# -----------------
+# Check to see how make treats includes.
+AC_DEFUN([AM_MAKE_INCLUDE],
+[am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo done
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+AC_MSG_CHECKING([for style of include used by $am_make])
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
+fi
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
+rm -f confinc confmf
+])
+
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
+
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_MISSING_PROG(NAME, PROGRAM)
+# ------------------------------
+AC_DEFUN([AM_MISSING_PROG],
+[AC_REQUIRE([AM_MISSING_HAS_RUN])
+$1=${$1-"${am_missing_run}$2"}
+AC_SUBST($1)])
+
+
+# AM_MISSING_HAS_RUN
+# ------------------
+# Define MISSING if not defined so far and test if it supports --run.
+# If it does, set am_missing_run to use it, otherwise, to nothing.
+AC_DEFUN([AM_MISSING_HAS_RUN],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  AC_MSG_WARN([`missing' script is too old or missing])
+fi
+])
+
+# Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_MKDIR_P
+# ---------------
+# Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.
+#
+# Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories
+# created by `make install' are always world readable, even if the
+# installer happens to have an overly restrictive umask (e.g. 077).
+# This was a mistake.  There are at least two reasons why we must not
+# use `-m 0755':
+#   - it causes special bits like SGID to be ignored,
+#   - it may be too restrictive (some setups expect 775 directories).
+#
+# Do not use -m 0755 and let people choose whatever they expect by
+# setting umask.
+#
+# We cannot accept any implementation of `mkdir' that recognizes `-p'.
+# Some implementations (such as Solaris 8's) are not thread-safe: if a
+# parallel make tries to run `mkdir -p a/b' and `mkdir -p a/c'
+# concurrently, both version can detect that a/ is missing, but only
+# one can create it and the other will error out.  Consequently we
+# restrict ourselves to GNU make (using the --version option ensures
+# this.)
+AC_DEFUN([AM_PROG_MKDIR_P],
+[if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+  # We used to keeping the `.' as first argument, in order to
+  # allow $(mkdir_p) to be used without argument.  As in
+  #   $(mkdir_p) $(somedir)
+  # where $(somedir) is conditionally defined.  However this is wrong
+  # for two reasons:
+  #  1. if the package is installed by a user who cannot write `.'
+  #     make install will fail,
+  #  2. the above comment should most certainly read
+  #     $(mkdir_p) $(DESTDIR)$(somedir)
+  #     so it does not work when $(somedir) is undefined and
+  #     $(DESTDIR) is not.
+  #  To support the latter case, we have to write
+  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
+  #  so the `.' trick is pointless.
+  mkdir_p='mkdir -p --'
+else
+  # On NextStep and OpenStep, the `mkdir' command does not
+  # recognize any option.  It will interpret all options as
+  # directories to create, and then abort because `.' already
+  # exists.
+  for d in ./-p ./--version;
+  do
+    test -d $d && rmdir $d
+  done
+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
+  if test -f "$ac_aux_dir/mkinstalldirs"; then
+    mkdir_p='$(mkinstalldirs)'
+  else
+    mkdir_p='$(install_sh) -d'
+  fi
+fi
+AC_SUBST([mkdir_p])])
+
+# Helper functions for option handling.                     -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
+
+# _AM_MANGLE_OPTION(NAME)
+# -----------------------
+AC_DEFUN([_AM_MANGLE_OPTION],
+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
+
+# _AM_SET_OPTION(NAME)
+# ------------------------------
+# Set option NAME.  Presently that only means defining a flag for this option.
+AC_DEFUN([_AM_SET_OPTION],
+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+
+# _AM_SET_OPTIONS(OPTIONS)
+# ----------------------------------
+# OPTIONS is a space-separated list of Automake options.
+AC_DEFUN([_AM_SET_OPTIONS],
+[AC_FOREACH([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
+
+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
+# -------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+AC_DEFUN([_AM_IF_OPTION],
+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
+
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_SANITY_CHECK
+# ---------------
+AC_DEFUN([AM_SANITY_CHECK],
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
+   if test "$[*]" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$[*]" != "X $srcdir/configure conftest.file" \
+      && test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "$[2]" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+AC_MSG_RESULT(yes)])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_STRIP
+# ---------------------
+# One issue with vendor `install' (even GNU) is that you can't
+# specify the program used to strip binaries.  This is especially
+# annoying in cross-compiling environments, where the build's strip
+# is unlikely to handle the host's binaries.
+# Fortunately install-sh will honor a STRIPPROG variable, so we
+# always use install-sh in `make install-strip', and initialize
+# STRIPPROG with the value of the STRIP variable (set by the user).
+AC_DEFUN([AM_PROG_INSTALL_STRIP],
+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+if test "$cross_compiling" != no; then
+  AC_CHECK_TOOL([STRIP], [strip], :)
+fi
+INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
+AC_SUBST([INSTALL_STRIP_PROGRAM])])
+
+# Check how to create a tarball.                            -*- Autoconf -*-
+
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_PROG_TAR(FORMAT)
+# --------------------
+# Check how to create a tarball in format FORMAT.
+# FORMAT should be one of `v7', `ustar', or `pax'.
+#
+# Substitute a variable $(am__tar) that is a command
+# writing to stdout a FORMAT-tarball containing the directory
+# $tardir.
+#     tardir=directory && $(am__tar) > result.tar
+#
+# Substitute a variable $(am__untar) that extract such
+# a tarball read from stdin.
+#     $(am__untar) < result.tar
+AC_DEFUN([_AM_PROG_TAR],
+[# Always define AMTAR for backward compatibility.
+AM_MISSING_PROG([AMTAR], [tar])
+m4_if([$1], [v7],
+     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
+     [m4_case([$1], [ustar],, [pax],,
+              [m4_fatal([Unknown tar format])])
+AC_MSG_CHECKING([how to create a $1 tar archive])
+# Loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
+_am_tools=${am_cv_prog_tar_$1-$_am_tools}
+# Do not fold the above two line into one, because Tru64 sh and
+# Solaris sh will not grok spaces in the rhs of `-'.
+for _am_tool in $_am_tools
+do
+  case $_am_tool in
+  gnutar)
+    for _am_tar in tar gnutar gtar;
+    do
+      AM_RUN_LOG([$_am_tar --version]) && break
+    done
+    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+    am__untar="$_am_tar -xf -"
+    ;;
+  plaintar)
+    # Must skip GNU tar: if it does not support --format= it doesn't create
+    # ustar tarball either.
+    (tar --version) >/dev/null 2>&1 && continue
+    am__tar='tar chf - "$$tardir"'
+    am__tar_='tar chf - "$tardir"'
+    am__untar='tar xf -'
+    ;;
+  pax)
+    am__tar='pax -L -x $1 -w "$$tardir"'
+    am__tar_='pax -L -x $1 -w "$tardir"'
+    am__untar='pax -r'
+    ;;
+  cpio)
+    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+    am__untar='cpio -i -H $1 -d'
+    ;;
+  none)
+    am__tar=false
+    am__tar_=false
+    am__untar=false
+    ;;
+  esac
+
+  # If the value was cached, stop now.  We just wanted to have am__tar
+  # and am__untar set.
+  test -n "${am_cv_prog_tar_$1}" && break
+
+  # tar/untar a dummy directory, and stop if the command works
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  echo GrepMe > conftest.dir/file
+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest.dir
+  if test -s conftest.tar; then
+    AM_RUN_LOG([$am__untar <conftest.tar])
+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+  fi
+done
+rm -rf conftest.dir
+
+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+AC_SUBST([am__tar])
+AC_SUBST([am__untar])
+]) # _AM_PROG_TAR
+
+m4_include([../../../acinclude.m4])
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/cbrt_factors.c newlib-1.15.0/newlib/libm/machine/spu/cbrt_factors.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/cbrt_factors.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/cbrt_factors.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,21 @@
+/* --------------------------------------------------------------  */
+/* (C)Copyright 2001,2006,                                         */
+/* International Business Machines Corporation,                    */
+/* Sony Computer Entertainment, Incorporated,                      */
+/* Toshiba Corporation,                                            */
+/*                                                                 */
+/* All Rights Reserved.                                            */
+/* --------------------------------------------------------------  */
+/* PROLOG END TAG zYx                                              */
+
+/* The cbrt_factors array is used by double precision cube root
+ * functions. It contains the constants:
+ */
+
+double cbrt_factors[5] = {
+  0.629960524947436484311,	/* 2^(-2/3) */
+  0.793700525984099680699,	/* 2^(-1/3) */
+  1.0,				/* 2^(0)    */
+  1.259921049894873164666,	/* 2^(1/3)  */
+  1.587401051968199583441	/* 2^(2/3)  */
+};
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/configure newlib-1.15.0/newlib/libm/machine/spu/configure
--- orig.newlib-1.15.0/newlib/libm/machine/spu/configure	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/configure	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,4085 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59 for newlib 1.15.0.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME='newlib'
+PACKAGE_TARNAME='newlib'
+PACKAGE_VERSION='1.15.0'
+PACKAGE_STRING='newlib 1.15.0'
+PACKAGE_BUGREPORT=''
+
+ac_unique_file="Makefile.am"
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS MAY_SUPPLY_SYSCALLS_TRUE MAY_SUPPLY_SYSCALLS_FALSE newlib_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB READELF ac_ct_READELF MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CCAS CCASFLAGS NEWLIB_CFLAGS LDFLAGS ELIX_LEVEL_0_TRUE ELIX_LEVEL_0_FALSE ELIX_LEVEL_1_TRUE ELIX_LEVEL_1_FALSE ELIX_LEVEL_2_TRUE ELIX_LEVEL_2_FALSE ELIX_LEVEL_3_TRUE ELIX_LEVEL_3_FALSE ELIX_LEVEL_4_TRUE ELIX_LEVEL_4_FALSE USE_LIBTOOL_TRUE USE_LIBTOOL_FALSE OBJEXT oext aext lpfx libm_machine_dir machine_dir sys_dir LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CCAS_set=${CCAS+set}
+ac_env_CCAS_value=$CCAS
+ac_cv_env_CCAS_set=${CCAS+set}
+ac_cv_env_CCAS_value=$CCAS
+ac_env_CCASFLAGS_set=${CCASFLAGS+set}
+ac_env_CCASFLAGS_value=$CCASFLAGS
+ac_cv_env_CCASFLAGS_set=${CCASFLAGS+set}
+ac_cv_env_CCASFLAGS_value=$CCASFLAGS
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures newlib 1.15.0 to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of newlib 1.15.0:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-multilib         build many library versions (default)
+  --enable-target-optspace  optimize for space
+  --enable-malloc-debugging indicate malloc debugging requested
+  --enable-newlib-multithread        enable support for multiple threads
+  --enable-newlib-iconv     enable iconv library support
+  --enable-newlib-elix-level         supply desired elix library level (1-4)
+  --disable-newlib-io-float disable printf/scanf family float support
+  --disable-newlib-supplied-syscalls disable newlib from supplying syscalls
+  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors
+  --enable-maintainer-mode  enable make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer
+
+Some influential environment variables:
+  CCAS        assembler compiler command (defaults to CC)
+  CCASFLAGS   assembler compiler flags (defaults to CFLAGS)
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+newlib configure 1.15.0
+generated by GNU Autoconf 2.59
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by newlib $as_me 1.15.0, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+ac_aux_dir=
+for ac_dir in ../../../.. $srcdir/../../../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in ../../../.. $srcdir/../../../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in ../../../.. $srcdir/../../../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+am__api_version="1.9"
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+echo "$as_me:$LINENO: checking whether build environment is sane" >&5
+echo $ECHO_N "checking whether build environment is sane... $ECHO_C" >&6
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$*" != "X $srcdir/configure conftest.file" \
+      && test "$*" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      { { echo "$as_me:$LINENO: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" >&5
+echo "$as_me: error: ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" >&2;}
+   { (exit 1); exit 1; }; }
+   fi
+
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   { { echo "$as_me:$LINENO: error: newly created file is older than distributed files!
+Check your system clock" >&5
+echo "$as_me: error: newly created file is older than distributed files!
+Check your system clock" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+test "$program_prefix" != NONE &&
+  program_transform_name="s,^,$program_prefix,;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s,\$,$program_suffix,;$program_transform_name"
+# Double any \ or $.  echo might interpret backslashes.
+# By default was `s,x,x', remove it if useless.
+cat <<\_ACEOF >conftest.sed
+s/[\\$]/&&/g;s/;s,x,x,$//
+_ACEOF
+program_transform_name=`echo $program_transform_name | sed -f conftest.sed`
+rm conftest.sed
+
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+
+test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  { echo "$as_me:$LINENO: WARNING: \`missing' script is too old or missing" >&5
+echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+fi
+
+if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+  # We used to keeping the `.' as first argument, in order to
+  # allow $(mkdir_p) to be used without argument.  As in
+  #   $(mkdir_p) $(somedir)
+  # where $(somedir) is conditionally defined.  However this is wrong
+  # for two reasons:
+  #  1. if the package is installed by a user who cannot write `.'
+  #     make install will fail,
+  #  2. the above comment should most certainly read
+  #     $(mkdir_p) $(DESTDIR)$(somedir)
+  #     so it does not work when $(somedir) is undefined and
+  #     $(DESTDIR) is not.
+  #  To support the latter case, we have to write
+  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
+  #  so the `.' trick is pointless.
+  mkdir_p='mkdir -p --'
+else
+  # On NextStep and OpenStep, the `mkdir' command does not
+  # recognize any option.  It will interpret all options as
+  # directories to create, and then abort because `.' already
+  # exists.
+  for d in ./-p ./--version;
+  do
+    test -d $d && rmdir $d
+  done
+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
+  if test -f "$ac_aux_dir/mkinstalldirs"; then
+    mkdir_p='$(mkinstalldirs)'
+  else
+    mkdir_p='$(install_sh) -d'
+  fi
+fi
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_AWK+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AWK="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  echo "$as_me:$LINENO: result: $AWK" >&5
+echo "${ECHO_T}$AWK" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$AWK" && break
+done
+
+echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,:./+-,___p_,'`
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.make <<\_ACEOF
+all:
+	@echo 'ac_maketemp="$(MAKE)"'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftest.make 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftest.make
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  SET_MAKE=
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+DEPDIR="${am__leading_dot}deps"
+
+          ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo done
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+echo "$as_me:$LINENO: checking for style of include used by $am_make" >&5
+echo $ECHO_N "checking for style of include used by $am_make... $ECHO_C" >&6
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
+fi
+
+
+echo "$as_me:$LINENO: result: $_am_result" >&5
+echo "${ECHO_T}$_am_result" >&6
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking or --disable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then
+  enableval="$enable_dependency_tracking"
+
+fi;
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+
+
+if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+
+
+# Check whether --enable-multilib or --disable-multilib was given.
+if test "${enable_multilib+set}" = set; then
+  enableval="$enable_multilib"
+  case "${enableval}" in
+  yes) multilib=yes ;;
+  no)  multilib=no ;;
+  *)   { { echo "$as_me:$LINENO: error: bad value ${enableval} for multilib option" >&5
+echo "$as_me: error: bad value ${enableval} for multilib option" >&2;}
+   { (exit 1); exit 1; }; } ;;
+ esac
+else
+  multilib=yes
+fi;
+# Check whether --enable-target-optspace or --disable-target-optspace was given.
+if test "${enable_target_optspace+set}" = set; then
+  enableval="$enable_target_optspace"
+  case "${enableval}" in
+  yes) target_optspace=yes ;;
+  no)  target_optspace=no ;;
+  *)   { { echo "$as_me:$LINENO: error: bad value ${enableval} for target-optspace option" >&5
+echo "$as_me: error: bad value ${enableval} for target-optspace option" >&2;}
+   { (exit 1); exit 1; }; } ;;
+ esac
+else
+  target_optspace=
+fi;
+# Check whether --enable-malloc-debugging or --disable-malloc-debugging was given.
+if test "${enable_malloc_debugging+set}" = set; then
+  enableval="$enable_malloc_debugging"
+  case "${enableval}" in
+  yes) malloc_debugging=yes ;;
+  no)  malloc_debugging=no ;;
+  *)   { { echo "$as_me:$LINENO: error: bad value ${enableval} for malloc-debugging option" >&5
+echo "$as_me: error: bad value ${enableval} for malloc-debugging option" >&2;}
+   { (exit 1); exit 1; }; } ;;
+ esac
+else
+  malloc_debugging=
+fi;
+# Check whether --enable-newlib-multithread or --disable-newlib-multithread was given.
+if test "${enable_newlib_multithread+set}" = set; then
+  enableval="$enable_newlib_multithread"
+  case "${enableval}" in
+  yes) newlib_multithread=yes ;;
+  no)  newlib_multithread=no ;;
+  *)   { { echo "$as_me:$LINENO: error: bad value ${enableval} for newlib-multithread option" >&5
+echo "$as_me: error: bad value ${enableval} for newlib-multithread option" >&2;}
+   { (exit 1); exit 1; }; } ;;
+ esac
+else
+  newlib_multithread=yes
+fi;
+# Check whether --enable-newlib-iconv or --disable-newlib-iconv was given.
+if test "${enable_newlib_iconv+set}" = set; then
+  enableval="$enable_newlib_iconv"
+  if test "${newlib_iconv+set}" != set; then
+   case "${enableval}" in
+     yes) newlib_iconv=yes ;;
+     no)  newlib_iconv=no ;;
+     *)   { { echo "$as_me:$LINENO: error: bad value ${enableval} for newlib-iconv option" >&5
+echo "$as_me: error: bad value ${enableval} for newlib-iconv option" >&2;}
+   { (exit 1); exit 1; }; } ;;
+   esac
+ fi
+else
+  newlib_iconv=${newlib_iconv}
+fi;
+# Check whether --enable-newlib-elix-level or --disable-newlib-elix-level was given.
+if test "${enable_newlib_elix_level+set}" = set; then
+  enableval="$enable_newlib_elix_level"
+  case "${enableval}" in
+  0)   newlib_elix_level=0 ;;
+  1)   newlib_elix_level=1 ;;
+  2)   newlib_elix_level=2 ;;
+  3)   newlib_elix_level=3 ;;
+  4)   newlib_elix_level=4 ;;
+  *)   { { echo "$as_me:$LINENO: error: bad value ${enableval} for newlib-elix-level option" >&5
+echo "$as_me: error: bad value ${enableval} for newlib-elix-level option" >&2;}
+   { (exit 1); exit 1; }; } ;;
+ esac
+else
+  newlib_elix_level=0
+fi;
+# Check whether --enable-newlib-io-float or --disable-newlib-io-float was given.
+if test "${enable_newlib_io_float+set}" = set; then
+  enableval="$enable_newlib_io_float"
+  case "${enableval}" in
+  yes) newlib_io_float=yes ;;
+  no)  newlib_io_float=no ;;
+  *)   { { echo "$as_me:$LINENO: error: bad value ${enableval} for newlib-io-float option" >&5
+echo "$as_me: error: bad value ${enableval} for newlib-io-float option" >&2;}
+   { (exit 1); exit 1; }; } ;;
+ esac
+else
+  newlib_io_float=yes
+fi;
+# Check whether --enable-newlib-supplied-syscalls or --disable-newlib-supplied-syscalls was given.
+if test "${enable_newlib_supplied_syscalls+set}" = set; then
+  enableval="$enable_newlib_supplied_syscalls"
+  case "${enableval}" in
+  yes) newlib_may_supply_syscalls=yes ;;
+  no)  newlib_may_supply_syscalls=no ;;
+  *)   { { echo "$as_me:$LINENO: error: bad value ${enableval} for newlib-supplied-syscalls option" >&5
+echo "$as_me: error: bad value ${enableval} for newlib-supplied-syscalls option" >&2;}
+   { (exit 1); exit 1; }; } ;;
+ esac
+else
+  newlib_may_supply_syscalls=yes
+fi;
+
+
+if test x${newlib_may_supply_syscalls} = xyes; then
+  MAY_SUPPLY_SYSCALLS_TRUE=
+  MAY_SUPPLY_SYSCALLS_FALSE='#'
+else
+  MAY_SUPPLY_SYSCALLS_TRUE='#'
+  MAY_SUPPLY_SYSCALLS_FALSE=
+fi
+
+
+
+test -z "${with_target_subdir}" && with_target_subdir=.
+
+if test "${srcdir}" = "."; then
+  if test "${with_target_subdir}" != "."; then
+    newlib_basedir="${srcdir}/${with_multisrctop}../../../.."
+  else
+    newlib_basedir="${srcdir}/${with_multisrctop}../../.."
+  fi
+else
+  newlib_basedir="${srcdir}/../../.."
+fi
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+
+# test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" &&
+   test -f $srcdir/config.status; then
+  { { echo "$as_me:$LINENO: error: source directory already configured; run \"make distclean\" there first" >&5
+echo "$as_me: error: source directory already configured; run \"make distclean\" there first" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+
+
+# Define the identity of the package.
+ PACKAGE='newlib'
+ VERSION='1.15.0'
+
+
+# Some tools Automake needs.
+
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+
+
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
+
+
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+
+
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
+
+
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+
+install_sh=${install_sh-"$am_aux_dir/install-sh"}
+
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_STRIP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  echo "$as_me:$LINENO: result: $STRIP" >&5
+echo "${ECHO_T}$STRIP" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_STRIP" && ac_cv_prog_ac_ct_STRIP=":"
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+echo "${ECHO_T}$ac_ct_STRIP" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  STRIP=$ac_ct_STRIP
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.
+
+AMTAR=${AMTAR-"${am_missing_run}tar"}
+
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+
+
+
+
+
+
+# FIXME: We temporarily define our own version of AC_PROG_CC.  This is
+# copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We
+# are probably using a cross compiler, which will not be able to fully
+# link an executable.  This should really be fixed in autoconf
+# itself.
+
+
+
+
+
+
+
+# Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="gcc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+depcc="$CC"   am_compiler_list=
+
+echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
+echo $ECHO_N "checking dependency style of $depcc... $ECHO_C" >&6
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+echo "$as_me:$LINENO: result: $am_cv_CC_dependencies_compiler_type" >&5
+echo "${ECHO_T}$am_cv_CC_dependencies_compiler_type" >&6
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+
+
+if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable cc found in \$PATH" >&5
+echo "$as_me: error: no acceptable cc found in \$PATH" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+echo "$as_me:$LINENO: checking whether we are using GNU C" >&5
+echo $ECHO_N "checking whether we are using GNU C... $ECHO_C" >&6
+if test "${ac_cv_c_compiler_gnu+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+if { ac_try='${CC-cc} -E conftest.c'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } | egrep yes >/dev/null 2>&1; then
+  ac_cv_c_compiler_gnu=yes
+else
+  ac_cv_c_compiler_gnu=no
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
+
+if test $ac_cv_c_compiler_gnu = yes; then
+  GCC=yes
+  ac_test_CFLAGS="${CFLAGS+set}"
+  ac_save_CFLAGS="$CFLAGS"
+  CFLAGS=
+  ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+CFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_g+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_g=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_prog_cc_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+  if test "$ac_test_CFLAGS" = set; then
+    CFLAGS="$ac_save_CFLAGS"
+  elif test $ac_cv_prog_cc_g = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-O2"
+  fi
+else
+  GCC=
+  test "${CFLAGS+set}" = set || CFLAGS="-g"
+fi
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}as", so it can be a program name with args.
+set dummy ${ac_tool_prefix}as; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_AS+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$AS"; then
+  ac_cv_prog_AS="$AS" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AS="${ac_tool_prefix}as"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+AS=$ac_cv_prog_AS
+if test -n "$AS"; then
+  echo "$as_me:$LINENO: result: $AS" >&5
+echo "${ECHO_T}$AS" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_AS"; then
+  ac_ct_AS=$AS
+  # Extract the first word of "as", so it can be a program name with args.
+set dummy as; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_AS+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_AS"; then
+  ac_cv_prog_ac_ct_AS="$ac_ct_AS" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_AS="as"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_AS=$ac_cv_prog_ac_ct_AS
+if test -n "$ac_ct_AS"; then
+  echo "$as_me:$LINENO: result: $ac_ct_AS" >&5
+echo "${ECHO_T}$ac_ct_AS" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  AS=$ac_ct_AS
+else
+  AS="$ac_cv_prog_AS"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_AR+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  echo "$as_me:$LINENO: result: $AR" >&5
+echo "${ECHO_T}$AR" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_AR="ar"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  echo "$as_me:$LINENO: result: $ac_ct_AR" >&5
+echo "${ECHO_T}$ac_ct_AR" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  AR=$ac_ct_AR
+else
+  AR="$ac_cv_prog_AR"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  RANLIB=$ac_ct_RANLIB
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}readelf", so it can be a program name with args.
+set dummy ${ac_tool_prefix}readelf; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_READELF+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$READELF"; then
+  ac_cv_prog_READELF="$READELF" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_READELF="${ac_tool_prefix}readelf"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+READELF=$ac_cv_prog_READELF
+if test -n "$READELF"; then
+  echo "$as_me:$LINENO: result: $READELF" >&5
+echo "${ECHO_T}$READELF" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_READELF"; then
+  ac_ct_READELF=$READELF
+  # Extract the first word of "readelf", so it can be a program name with args.
+set dummy readelf; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_READELF+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_READELF"; then
+  ac_cv_prog_ac_ct_READELF="$ac_ct_READELF" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_READELF="readelf"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_prog_ac_ct_READELF" && ac_cv_prog_ac_ct_READELF=":"
+fi
+fi
+ac_ct_READELF=$ac_cv_prog_ac_ct_READELF
+if test -n "$ac_ct_READELF"; then
+  echo "$as_me:$LINENO: result: $ac_ct_READELF" >&5
+echo "${ECHO_T}$ac_ct_READELF" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  READELF=$ac_ct_READELF
+else
+  READELF="$ac_cv_prog_READELF"
+fi
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in
+  ./ | .// | /cC/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	    break 3
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+done
+
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL=$ac_install_sh
+  fi
+fi
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+# Hack to ensure that INSTALL won't be set to "../" with autoconf 2.13.  */
+ac_given_INSTALL=$INSTALL
+
+echo "$as_me:$LINENO: checking whether to enable maintainer-specific portions of Makefiles" >&5
+echo $ECHO_N "checking whether to enable maintainer-specific portions of Makefiles... $ECHO_C" >&6
+    # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then
+  enableval="$enable_maintainer_mode"
+  USE_MAINTAINER_MODE=$enableval
+else
+  USE_MAINTAINER_MODE=no
+fi;
+  echo "$as_me:$LINENO: result: $USE_MAINTAINER_MODE" >&5
+echo "${ECHO_T}$USE_MAINTAINER_MODE" >&6
+
+
+if test $USE_MAINTAINER_MODE = yes; then
+  MAINTAINER_MODE_TRUE=
+  MAINTAINER_MODE_FALSE='#'
+else
+  MAINTAINER_MODE_TRUE='#'
+  MAINTAINER_MODE_FALSE=
+fi
+
+  MAINT=$MAINTAINER_MODE_TRUE
+
+
+# By default we simply use the C compiler to build assembly code.
+
+test "${CCAS+set}" = set || CCAS=$CC
+test "${CCASFLAGS+set}" = set || CCASFLAGS=$CFLAGS
+
+
+
+
+# We need AC_EXEEXT to keep automake happy in cygnus mode.  However,
+# at least currently, we never actually build a program, so we never
+# need to use $(EXEEXT).  Moreover, the test for EXEEXT normally
+# fails, because we are probably configuring with a cross compiler
+# which can't create executables.  So we include AC_EXEEXT to keep
+# automake happy, but we don't execute it, since we don't care about
+# the result.
+if false; then
+
+  dummy_var=1
+fi
+
+. ${newlib_basedir}/configure.host
+
+newlib_cflags="${newlib_cflags} -fno-builtin"
+
+NEWLIB_CFLAGS=${newlib_cflags}
+
+
+LDFLAGS=${ldflags}
+
+
+
+
+if test x${newlib_elix_level} = x0; then
+  ELIX_LEVEL_0_TRUE=
+  ELIX_LEVEL_0_FALSE='#'
+else
+  ELIX_LEVEL_0_TRUE='#'
+  ELIX_LEVEL_0_FALSE=
+fi
+
+
+
+if test x${newlib_elix_level} = x1; then
+  ELIX_LEVEL_1_TRUE=
+  ELIX_LEVEL_1_FALSE='#'
+else
+  ELIX_LEVEL_1_TRUE='#'
+  ELIX_LEVEL_1_FALSE=
+fi
+
+
+
+if test x${newlib_elix_level} = x2; then
+  ELIX_LEVEL_2_TRUE=
+  ELIX_LEVEL_2_FALSE='#'
+else
+  ELIX_LEVEL_2_TRUE='#'
+  ELIX_LEVEL_2_FALSE=
+fi
+
+
+
+if test x${newlib_elix_level} = x3; then
+  ELIX_LEVEL_3_TRUE=
+  ELIX_LEVEL_3_FALSE='#'
+else
+  ELIX_LEVEL_3_TRUE='#'
+  ELIX_LEVEL_3_FALSE=
+fi
+
+
+
+if test x${newlib_elix_level} = x4; then
+  ELIX_LEVEL_4_TRUE=
+  ELIX_LEVEL_4_FALSE='#'
+else
+  ELIX_LEVEL_4_TRUE='#'
+  ELIX_LEVEL_4_FALSE=
+fi
+
+
+
+
+if test x${use_libtool} = xyes; then
+  USE_LIBTOOL_TRUE=
+  USE_LIBTOOL_FALSE='#'
+else
+  USE_LIBTOOL_TRUE='#'
+  USE_LIBTOOL_FALSE=
+fi
+
+
+# Hard-code OBJEXT.  Normally it is set by AC_OBJEXT, but we
+# use oext, which is set in configure.host based on the target platform.
+OBJEXT=${oext}
+
+
+
+
+
+
+
+
+
+
+
+          ac_config_files="$ac_config_files Makefile"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+#
+# If the first sed substitution is executed (which looks for macros that
+# take arguments), then we branch to the quote section.  Otherwise,
+# look for a macro that doesn't take arguments.
+cat >confdef2opt.sed <<\_ACEOF
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+d
+: quote
+s,[	 `~#$^&*(){}\\|;'"<>?],\\&,g
+s,\[,\\&,g
+s,\],\\&,g
+s,\$,$$,g
+p
+_ACEOF
+# We use echo to avoid assuming a particular line-breaking character.
+# The extra dot is to prevent the shell from consuming trailing
+# line-breaks from the sub-command output.  A line-break within
+# single-quotes doesn't work because, if this script is created in a
+# platform that uses two characters for line-breaks (e.g., DOS), tr
+# would break.
+ac_LF_and_DOT=`echo; echo .`
+DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr "$ac_LF_and_DOT" ' .'`
+rm -f confdef2opt.sed
+
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+if test -z "${MAY_SUPPLY_SYSCALLS_TRUE}" && test -z "${MAY_SUPPLY_SYSCALLS_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"MAY_SUPPLY_SYSCALLS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"MAY_SUPPLY_SYSCALLS\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ELIX_LEVEL_0_TRUE}" && test -z "${ELIX_LEVEL_0_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ELIX_LEVEL_0\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ELIX_LEVEL_0\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ELIX_LEVEL_1_TRUE}" && test -z "${ELIX_LEVEL_1_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ELIX_LEVEL_1\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ELIX_LEVEL_1\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ELIX_LEVEL_2_TRUE}" && test -z "${ELIX_LEVEL_2_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ELIX_LEVEL_2\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ELIX_LEVEL_2\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ELIX_LEVEL_3_TRUE}" && test -z "${ELIX_LEVEL_3_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ELIX_LEVEL_3\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ELIX_LEVEL_3\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${ELIX_LEVEL_4_TRUE}" && test -z "${ELIX_LEVEL_4_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"ELIX_LEVEL_4\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"ELIX_LEVEL_4\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${USE_LIBTOOL_TRUE}" && test -z "${USE_LIBTOOL_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"USE_LIBTOOL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"USE_LIBTOOL\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by newlib $as_me 1.15.0, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Configuration commands:
+$config_commands
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+newlib config.status 1.15.0
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+INSTALL="$INSTALL"
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+#
+# INIT-COMMANDS section.
+#
+
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+
+_ACEOF
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  "depfiles" ) CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@MAY_SUPPLY_SYSCALLS_TRUE@,$MAY_SUPPLY_SYSCALLS_TRUE,;t t
+s,@MAY_SUPPLY_SYSCALLS_FALSE@,$MAY_SUPPLY_SYSCALLS_FALSE,;t t
+s,@newlib_basedir@,$newlib_basedir,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+s,@CYGPATH_W@,$CYGPATH_W,;t t
+s,@PACKAGE@,$PACKAGE,;t t
+s,@VERSION@,$VERSION,;t t
+s,@ACLOCAL@,$ACLOCAL,;t t
+s,@AUTOCONF@,$AUTOCONF,;t t
+s,@AUTOMAKE@,$AUTOMAKE,;t t
+s,@AUTOHEADER@,$AUTOHEADER,;t t
+s,@MAKEINFO@,$MAKEINFO,;t t
+s,@install_sh@,$install_sh,;t t
+s,@STRIP@,$STRIP,;t t
+s,@ac_ct_STRIP@,$ac_ct_STRIP,;t t
+s,@INSTALL_STRIP_PROGRAM@,$INSTALL_STRIP_PROGRAM,;t t
+s,@mkdir_p@,$mkdir_p,;t t
+s,@AWK@,$AWK,;t t
+s,@SET_MAKE@,$SET_MAKE,;t t
+s,@am__leading_dot@,$am__leading_dot,;t t
+s,@AMTAR@,$AMTAR,;t t
+s,@am__tar@,$am__tar,;t t
+s,@am__untar@,$am__untar,;t t
+s,@CC@,$CC,;t t
+s,@DEPDIR@,$DEPDIR,;t t
+s,@am__include@,$am__include,;t t
+s,@am__quote@,$am__quote,;t t
+s,@AMDEP_TRUE@,$AMDEP_TRUE,;t t
+s,@AMDEP_FALSE@,$AMDEP_FALSE,;t t
+s,@AMDEPBACKSLASH@,$AMDEPBACKSLASH,;t t
+s,@CCDEPMODE@,$CCDEPMODE,;t t
+s,@am__fastdepCC_TRUE@,$am__fastdepCC_TRUE,;t t
+s,@am__fastdepCC_FALSE@,$am__fastdepCC_FALSE,;t t
+s,@AS@,$AS,;t t
+s,@ac_ct_AS@,$ac_ct_AS,;t t
+s,@AR@,$AR,;t t
+s,@ac_ct_AR@,$ac_ct_AR,;t t
+s,@RANLIB@,$RANLIB,;t t
+s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+s,@READELF@,$READELF,;t t
+s,@ac_ct_READELF@,$ac_ct_READELF,;t t
+s,@MAINTAINER_MODE_TRUE@,$MAINTAINER_MODE_TRUE,;t t
+s,@MAINTAINER_MODE_FALSE@,$MAINTAINER_MODE_FALSE,;t t
+s,@MAINT@,$MAINT,;t t
+s,@CCAS@,$CCAS,;t t
+s,@CCASFLAGS@,$CCASFLAGS,;t t
+s,@NEWLIB_CFLAGS@,$NEWLIB_CFLAGS,;t t
+s,@LDFLAGS@,$LDFLAGS,;t t
+s,@ELIX_LEVEL_0_TRUE@,$ELIX_LEVEL_0_TRUE,;t t
+s,@ELIX_LEVEL_0_FALSE@,$ELIX_LEVEL_0_FALSE,;t t
+s,@ELIX_LEVEL_1_TRUE@,$ELIX_LEVEL_1_TRUE,;t t
+s,@ELIX_LEVEL_1_FALSE@,$ELIX_LEVEL_1_FALSE,;t t
+s,@ELIX_LEVEL_2_TRUE@,$ELIX_LEVEL_2_TRUE,;t t
+s,@ELIX_LEVEL_2_FALSE@,$ELIX_LEVEL_2_FALSE,;t t
+s,@ELIX_LEVEL_3_TRUE@,$ELIX_LEVEL_3_TRUE,;t t
+s,@ELIX_LEVEL_3_FALSE@,$ELIX_LEVEL_3_FALSE,;t t
+s,@ELIX_LEVEL_4_TRUE@,$ELIX_LEVEL_4_TRUE,;t t
+s,@ELIX_LEVEL_4_FALSE@,$ELIX_LEVEL_4_FALSE,;t t
+s,@USE_LIBTOOL_TRUE@,$USE_LIBTOOL_TRUE,;t t
+s,@USE_LIBTOOL_FALSE@,$USE_LIBTOOL_FALSE,;t t
+s,@OBJEXT@,$OBJEXT,;t t
+s,@oext@,$oext,;t t
+s,@aext@,$aext,;t t
+s,@lpfx@,$lpfx,;t t
+s,@libm_machine_dir@,$libm_machine_dir,;t t
+s,@machine_dir@,$machine_dir,;t t
+s,@sys_dir@,$sys_dir,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_COMMANDS section.
+#
+for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+  ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
+echo "$as_me: executing $ac_dest commands" >&6;}
+  case $ac_dest in
+    depfiles ) test x"$AMDEP_TRUE" != x"" || for mf in $CONFIG_FILES; do
+  # Strip MF so we end up with the name of the file.
+  mf=`echo "$mf" | sed -e 's/:.*$//'`
+  # Check whether this is an Automake generated Makefile or not.
+  # We used to match only the files named `Makefile.in', but
+  # some people rename them; so instead we look at the file content.
+  # Grep'ing the first line is not enough: some people post-process
+  # each Makefile.in and add a new line on top of each file to say so.
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
+    dirpart=`(dirname "$mf") 2>/dev/null ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  else
+    continue
+  fi
+  # Extract the definition of DEPDIR, am__include, and am__quote
+  # from the Makefile without running `make'.
+  DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+  test -z "$DEPDIR" && continue
+  am__include=`sed -n 's/^am__include = //p' < "$mf"`
+  test -z "am__include" && continue
+  am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+  # When using ansi2knr, U may be empty or an underscore; expand it
+  U=`sed -n 's/^U = //p' < "$mf"`
+  # Find all dependency output files, they are included files with
+  # $(DEPDIR) in their names.  We invoke sed twice because it is the
+  # simplest approach to changing $(DEPDIR) to its actual value in the
+  # expansion.
+  for file in `sed -n "
+    s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+       sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+    # Make sure the directory exists.
+    test -f "$dirpart/$file" && continue
+    fdir=`(dirname "$file") 2>/dev/null ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    { if $as_mkdir_p; then
+    mkdir -p $dirpart/$fdir
+  else
+    as_dir=$dirpart/$fdir
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory $dirpart/$fdir" >&5
+echo "$as_me: error: cannot create directory $dirpart/$fdir" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+    # echo "creating $dirpart/$file"
+    echo '# dummy' > "$dirpart/$file"
+  done
+done
+ ;;
+  esac
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/configure.in newlib-1.15.0/newlib/libm/machine/spu/configure.in
--- orig.newlib-1.15.0/newlib/libm/machine/spu/configure.in	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/configure.in	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,14 @@
+dnl This is the newlib/libc/machine/spu configure.in file.
+dnl Process this file with autoconf to produce a configure script.
+
+AC_PREREQ(2.59)
+AC_INIT([newlib],[NEWLIB_VERSION])
+AC_CONFIG_SRCDIR([Makefile.am])
+
+dnl Can't be done in NEWLIB_CONFIGURE because that confuses automake.
+AC_CONFIG_AUX_DIR(../../../..)
+
+NEWLIB_CONFIGURE(../../..)
+
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/feclearexcept.c newlib-1.15.0/newlib/libm/machine/spu/feclearexcept.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/feclearexcept.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/feclearexcept.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/feclearexcept.h"
+
+void feclearexcept(int excepts)
+{
+    _feclearexcept(excepts);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/fe_dfl_env.c newlib-1.15.0/newlib/libm/machine/spu/fe_dfl_env.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/fe_dfl_env.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/fe_dfl_env.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include <spu_intrinsics.h>
+#include <fenv.h>
+/*
+ * Define for FE_DFL_ENV macro, all bits zero.
+ */
+const fenv_t __fe_dfl_env = { 0 };
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/fegetenv.c newlib-1.15.0/newlib/libm/machine/spu/fegetenv.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/fegetenv.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/fegetenv.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fegetenv.h"
+
+void fegetenv(fenv_t *envp)
+{
+    _fegetenv(envp);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/fegetexceptflag.c newlib-1.15.0/newlib/libm/machine/spu/fegetexceptflag.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/fegetexceptflag.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/fegetexceptflag.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fegetexceptflag.h"
+
+void fegetexceptflag(fexcept_t *flagp, int excepts)
+{
+    _fegetexceptflag(flagp, excepts);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/fegetround.c newlib-1.15.0/newlib/libm/machine/spu/fegetround.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/fegetround.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/fegetround.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fegetround.h"
+
+int fegetround()
+{
+    return _fegetround();
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/feholdexcept.c newlib-1.15.0/newlib/libm/machine/spu/feholdexcept.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/feholdexcept.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/feholdexcept.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/feholdexcept.h"
+
+int feholdexcept(fenv_t *envp)
+{
+    return _feholdexcept(envp);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/feraiseexcept.c newlib-1.15.0/newlib/libm/machine/spu/feraiseexcept.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/feraiseexcept.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/feraiseexcept.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/feraiseexcept.h"
+
+void feraiseexcept(int excepts)
+{
+    _feraiseexcept(excepts);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/fesetenv.c newlib-1.15.0/newlib/libm/machine/spu/fesetenv.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/fesetenv.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/fesetenv.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fesetenv.h"
+
+void fesetenv(const fenv_t *envp)
+{
+    _fesetenv(envp);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/fesetexceptflag.c newlib-1.15.0/newlib/libm/machine/spu/fesetexceptflag.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/fesetexceptflag.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/fesetexceptflag.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fesetexceptflag.h"
+
+void fesetexceptflag(const fexcept_t *flagp, int excepts)
+{
+    _fesetexceptflag(flagp, excepts);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/fesetround.c newlib-1.15.0/newlib/libm/machine/spu/fesetround.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/fesetround.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/fesetround.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fesetround.h"
+
+int fesetround(int rounding_mode)
+{
+    return _fesetround(rounding_mode);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/fetestexcept.c newlib-1.15.0/newlib/libm/machine/spu/fetestexcept.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/fetestexcept.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/fetestexcept.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fetestexcept.h"
+
+int fetestexcept(int excepts)
+{
+    return _fetestexcept(excepts);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/feupdateenv.c newlib-1.15.0/newlib/libm/machine/spu/feupdateenv.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/feupdateenv.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/feupdateenv.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/feupdateenv.h"
+
+void feupdateenv(const fenv_t *envp)
+{
+    _feupdateenv(envp);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/common-file-to-func-map newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/common-file-to-func-map
--- orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/common-file-to-func-map	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/common-file-to-func-map	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,53 @@
+s_cbrt.c cbrt
+s_copysign.c copysign
+s_expm1.c expm1
+sf_cbrt.c cbrtf
+sf_copysign.c copysignf
+s_fdim.c fdim
+sf_expm1.c expm1f
+sf_fdim.c fdimf
+sf_finite.c finitef not-c99
+sf_fma.c fmaf
+sf_fmax.c fmaxf
+sf_fmin.c fminf
+sf_ilogb.c ilogbf
+sf_infinity.c infinityf
+s_finite.c finite
+sf_log1p.c log1pf
+sf_logb.c logbf
+sf_lrint.c lrintf
+sf_lround.c lroundf
+s_fma.c fma
+s_fmax.c fmax
+s_fmin.c fmin
+sf_modf.c modff
+sf_nan.c nanf
+sf_nearbyint.c nearbyintf
+sf_nextafter.c nextafterf
+s_fpclassify.c fpclassify
+sf_remquo.c remquof
+sf_rint.c rintf
+sf_round.c roundf
+sf_scalbln.c scalblnf
+sf_scalbn.c scalbnf
+sf_trunc.c truncf
+s_ilogb.c ilogb
+s_infconst.c infconst no-functions
+s_infinity.c infinity
+s_lib_ver.c lib_ver no-functions
+s_log1p.c log1p
+s_logb.c logb
+s_lrint.c lrint
+s_lround.c lround
+s_matherr.c matherr not-c99
+s_modf.c modf
+s_nan.c nan
+s_nearbyint.c nearbyint
+s_nextafter.c nextafter
+s_remquo.c remquo
+s_rint.c rint
+s_round.c round
+s_scalbln.c scalbln
+s_scalbn.c scalbn
+s_signbit.c signbit
+s_trunc.c trunc
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-alias newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-alias
--- orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-alias	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-alias	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,63 @@
+/* @(#)94	1.2  src/lib/math/libmath-alias-spu, sw.lib, sdk_pub 10/19/05 10:30:59 */
+/* -------------------------------------------------------------- */
+/* (C) Copyright 2001,2005,                                       */
+/* International Business Machines Corporation,                   */
+/* Sony Computer Entertainment Incorporated,                      */
+/* Toshiba Corporation.                                           */
+/*                                                                */
+/* All Rights Reserved.                                           */
+/* -------------------------------------------------------------- */
+/* PROLOG END TAG zYx                                              */
+
+long double cbrtl(long double) __attribute__ ((strong, alias ("cbrt")));
+long double ceill(long double) __attribute__ ((strong, alias ("ceil")));
+long double copysignl(long double, long double) __attribute__ ((strong, alias ("copysign")));
+long double cosl(long double angle)  __attribute__ ((strong, alias ("cos")));
+long double cotl(long double angle) __attribute__ ((strong, alias ("cot")));
+long double expl(long double x) __attribute__ ((strong, alias ("exp")));
+long double exp2l(long double x) __attribute__ ((strong, alias ("exp2")));
+long double exp10l(long double x) __attribute__ ((strong, alias ("exp10")));
+long double fabsl(long double) __attribute__ ((strong, alias ("fabs")));
+long double fdiml(long double, long double) __attribute__ ((strong, alias ("fdim")));
+long double floorl(long double) __attribute__ ((strong, alias ("floor")));
+long double fmal(long double, long double, long double) __attribute__ ((strong, alias ("fma")));
+long double fmaxl(long double, long double) __attribute__ ((strong, alias ("fmax")));
+long double fminl(long double, long double) __attribute__ ((strong, alias ("fmin")));
+long double fmodl(long double, long double) __attribute__ ((strong, alias ("fmod")));
+long double frexpl(long double, int *) __attribute__ ((strong, alias ("frexp")));
+int ilogbl(long double) __attribute__ ((strong, alias ("ilogb")));
+long double ldexpl(long double, int) __attribute__ ((strong, alias ("ldexp")));
+long long int llrintl(long double) __attribute__ ((strong, alias ("llrint")));
+long long int llroundl(long double) __attribute__ ((strong, alias ("llround")));
+long double logl(long double x) __attribute__ ((strong, alias ("log")));
+long double log2l(long double x) __attribute__ ((strong, alias ("log2")));
+long double log10l(long double x) __attribute__ ((strong, alias ("log10")));
+long int lrintl(long double) __attribute__ ((strong, alias ("lrint")));
+long int lroundl(long double) __attribute__ ((strong, alias ("lround")));
+/* For single precision float (truncation rounding mode only), nearbyint is
+ * equivalent to trunc.
+ */
+float nearbyintf(float) __attribute__ ((strong, alias ("truncf")));
+vector float nearbyintf_v(vector float) __attribute__ ((strong, alias ("truncf_v")));
+long double nearbyintl(long double) __attribute__ ((strong, alias ("nearbyint")));
+long double powl(long double x, long double y) __attribute__ ((strong, alias ("pow")));
+long double remainderl(long double, long double) __attribute__ ((strong, alias ("remainder")));
+long double remquol(long double, long double, int *) __attribute__ ((strong, alias ("remquo")));
+/* For single precision float (truncation rounding mode only), rint is
+ * equivalent to trunc.
+ */
+float rintf(float) __attribute__ ((strong, alias ("truncf")));
+/* For single precision float (truncation rounding mode only), rint is
+ * equivalent to trunc.
+ */
+vector float rintf_v(vector float) __attribute__ ((strong, alias ("truncf_v")));
+long double rintl(long double) __attribute__ ((strong, alias ("rint")));
+long double roundl(long double) __attribute__ ((strong, alias ("round")));
+float scalblnf(float, long int) __attribute__ ((strong, alias ("scalbnf")));
+long double scalbnl() __attribute__ ((strong, alias ("scalbn")));
+vector float scalbnf_v(vector float, vector signed int) __attribute__ ((strong, alias ("ldexpf_v")));
+vector double scalbn_v(vector double, vector signed int) __attribute__ ((strong, alias ("ldexp_v")));
+long double sinl(long double angle) __attribute__ ((strong, alias ("sin")));
+long double sqrtl(long double value) __attribute__ ((strong, alias ("sqrt")));
+long double tanl(long double angle) __attribute__ ((strong, alias ("tan")));
+long double truncl(long double) __attribute__ ((strong, alias ("trunc")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c.awk newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c.awk
--- orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c.awk	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c.awk	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,75 @@
+# --------------------------------------------------------------
+# (C)Copyright 2001,2006,
+# International Business Machines Corporation,
+# Sony Computer Entertainment, Incorporated,
+# Toshiba Corporation,
+#
+# All Rights Reserved.
+# --------------------------------------------------------------
+# PROLOG END TAG zYx
+BEGIN {
+    func_def = 0;
+    retval = 1;
+    include_path = "";
+}
+
+/static[ 	]*__inline/	{ func_def = 1 }
+/static[ 	]*__inline[ 	]*void/	{ retval = 0 }
+/static[ 	]*__inline[ 	]*void[ 	]*[*]/	{ retval = 1 }
+{
+    if (func_def == 1)
+    {
+	name = ARGV[ARGIND];
+	printf ("#include \"%s%s\"\n\n", include_path, name);
+
+	gsub ("", "", $0);
+	sub ("static[ 	]*__inline[ 	]*", "", $0);
+	sub (" _", " ", $0);
+	printf ("%s\n{\n", $0);
+
+	# Extract the subroutine name
+	count = split($0, funclist, "(");
+	name = funclist[1];
+	count = split(name, namelist, " ");
+	name = namelist[count];
+
+	params = $0;
+	gsub ("[a-zA-Z0-9_* ]*[(]", "", params);
+	gsub ("[)][a-zA-Z0-9_;* ]*", "", params);
+
+
+	if (retval == 1) {
+	    printf ("    return _%s(", name);
+	} else {
+	    printf ("    _%s(", name);
+	}
+
+	# For each parameter, extract the parameter name
+	count = split(params, paramlist, ",");
+	for (i=1; i<=count; i++) {
+	    param = paramlist[i];
+
+	    pcount = split(param, plist, " ");
+	    pname = plist[pcount];
+
+	    # Remove leading * and trailing [#]
+	    gsub ("*", "", pname);
+	    gsub ("[[][0-9]*]", "", pname);
+
+	    if (i > 1) printf (", ");
+	    printf ("%s", pname);
+	}
+
+	printf(");\n}\n");
+	func_def = 0;
+    }
+    retval = 1;
+}
+
+END {
+    if (ALIAS_FILE)
+    {
+	cmd = sprintf ("fgrep %s%s%s %s", "\"\\\"", name, "\"\\\"", ALIAS_FILE);
+	system (cmd);
+    }
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-files newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-files
--- orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-files	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-files	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,69 @@
+acosf.c	acosf
+asinf.c	asinf
+atanf.c	atanf
+ceilf.c	ceilf
+cosf.c	cosf
+expf.c	expf
+exp2f.c	exp2f
+fabsf.c	fabsf
+fdimf.c	fdimf
+floorf.c	floorf
+fmaf.c	fmaf
+fmaxf.c	fmaxf
+fminf.c	fminf
+logf.c	logf
+log2f.c	log2f is a macro in newlib
+log10f.c	log10f
+powf.c	powf
+sinf.c	sinf
+sqrtf.c	sqrtf
+tanf.c		tanf
+cbrt.c	cbrt
+cbrtf.c	cbrtf
+ceil.c	ceil
+copysign.c	copysign
+copysignf.c	copysignf
+cos.c	cos
+exp.c	exp
+exp2.c	exp2
+fabs.c	fabs
+fdim.c	fdim
+floor.c	floor
+fma.c	fma
+fmax.c	fmax
+fmin.c	fmin
+fmod.c	fmod
+fmodf.c	fmodf
+frexp.c	frexp
+frexpf.c	frexpf
+ilogb.c	ilogb
+ilogbf.c	ilogbf
+ldexp.c	ldexp
+ldexpf.c	ldexpf
+llrint.c	llrint long long
+llrintf.c	llrintf long long
+llround.c	llround long long
+llroundf.c	llroundf long long
+log.c	log
+log2.c	log2 is a macro in newlib
+log10.c	log10
+lrint.c	lrint
+lrintf.c	lrintf
+lround.c	lround
+lroundf.c	lroundf
+nearbyint.c	nearbyint
+pow.c	pow
+remainder.c	remainder
+remainderf.c	remainderf
+remquo.c	remquo
+remquof.c	remquof
+rint.c	rint
+round.c	round
+roundf.c	roundf
+scalbn.c	scalbn
+scalbnf.c	scalbnf
+sin.c	sin
+sqrt.c	sqrt
+tan.c	tan
+trunc.c	trunc
+truncf.c	truncf
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-files.sh newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-files.sh
--- orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-files.sh	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-c-files.sh	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,58 @@
+#! /bin/sh
+
+# Script to generate C files for a given list of SDK files/functions.
+# Use (while in this directory) like:
+#
+#     bash ./gen-c-files.sh gen-c-files newlib_file_to_func > gen.out 2>&1
+#     mv test_dir/*.c ..
+#
+# Examine and handle the results for:
+#
+#     grep "Note no match found" gen.out
+#
+# Then edit / update the Makefile.am to include the proper list of c
+# files.
+
+awk=/usr/bin/awk
+
+hdir=../headers
+alias_file=./gen-c-alias
+in_file=$1
+# in_file is a list of file names and functions supplied by that file.
+
+newlib_map_file=$2
+
+# map_file is a list of file names to function name, and then comments. As
+# we have to rename the C file to be the same as the one found in the map
+# file. in_file has the same format.
+
+lib_awk=./gen-c.awk
+
+# Generate .c files from .h files
+
+tdir=test_dir
+rm -f ${tdir}/*
+mkdir -p ${tdir}
+grep -v "^#" ${in_file} | while read line
+do
+	# echo line is ${line}
+	set ${line}
+	file=$1
+	out_file=${tdir}/${file}
+	myfunc=$2
+	base=${file%*.c}
+	obj=${base}.o
+	hdr=${hdir}/${base}.h
+	echo "creating ${out_file}"
+	${awk} -v ALIAS_FILE=${alias_file} -f ${lib_awk} ${hdr} > ${out_file}
+	# Find ${myfunc} in ${newlib_map_file}
+	new_name=$(grep -v "^#" ${newlib_map_file} | \
+		${awk} -v myfunc=${myfunc} '$2 == myfunc {print $1}')
+	if [ -z "${new_name}" ]
+	then
+		echo Note no match found for file ${file}
+	else
+		echo rename ${out_file} ${tdir}/${new_name}
+		mv ${out_file} ${tdir}/${new_name}
+	fi
+done
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-fe-c-files newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-fe-c-files
--- orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-fe-c-files	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/gen-fe-c-files	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,11 @@
+feclearexcept.c
+fegetenv.c
+fegetexceptflag.c
+fegetround.c
+feholdexcept.c
+feraiseexcept.c
+fesetenv.c
+fesetexceptflag.c
+fesetround.c
+fetestexcept.c
+feupdateenv.c
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/math-file-to-func-map newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/math-file-to-func-map
--- orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/math-file-to-func-map	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/math-file-to-func-map	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,82 @@
+s_asinh.c asinh
+s_atan.c atan
+s_ceil.c ceil
+s_cos.c cos
+s_erf.c erf
+s_fabs.c fabs
+sf_asinh.c asinhf
+sf_atan.c atanf
+sf_ceil.c ceilf
+sf_cos.c cosf
+sf_erf.c erff
+sf_fabs.c fabsf
+sf_floor.c floorf
+sf_frexp.c frexpf
+sf_isinf.c isinff
+sf_isnan.c isnanf
+sf_ldexp.c ldexpf
+s_floor.c floor
+s_frexp.c frexp
+sf_signif.c significandf special
+sf_sin.c sinf
+sf_tan.c tanf
+sf_tanh.c tanhf
+s_isinf.c isinf
+s_isnan.c isnan
+s_ldexp.c ldexp
+s_signif.c significand special
+s_sin.c sin
+s_tan.c tan
+s_tanh.c tanh
+w_acos.c acos
+w_acosh.c acosh
+w_asin.c asin
+w_atan2.c atan2
+w_atanh.c atanh
+w_cabs.c cabs
+w_cosh.c cosh
+w_drem.c drem
+w_exp2.c exp2
+w_exp.c exp
+wf_acos.c acosf
+wf_acosh.c acoshf
+wf_asin.c asinf
+wf_atan2.c atan2f
+wf_atanh.c atanhf
+wf_cabs.c cabsf
+wf_cosh.c coshf
+wf_drem.c dremf
+wf_exp2.c exp2f
+wf_exp.c expf
+wf_fmod.c fmodf
+wf_gamma.c gammaf
+wf_hypot.c hypotf
+wf_j0.c j0f
+wf_j1.c j1f
+wf_jn.c jnf
+wf_lgamma.c lgammaf
+wf_log10.c log10f
+wf_log.c logf
+w_fmod.c fmod
+wf_pow.c powf
+wf_remainder.c remainderf
+wf_scalb.c scalbf
+wf_sincos.c sincosf
+wf_sinh.c sinhf
+wf_sqrt.c sqrtf
+wf_tgamma.c tgammaf
+w_gamma.c gamma
+w_hypot.c hypot
+w_j0.c j0
+w_j1.c j1
+w_jn.c jn
+w_lgamma.c lgamma
+w_log10.c log10
+w_log.c log
+w_pow.c pow
+w_remainder.c remainder
+w_scalb.c scalb
+w_sincos.c sincos
+w_sinh.c sinh
+w_sqrt.c sqrt
+w_tgamma.c tgamma
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/newlib_file_to_func newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/newlib_file_to_func
--- orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/newlib_file_to_func	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/newlib_file_to_func	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,138 @@
+# generated via:
+#    cat common-file-to-func-map math-file-to-func-map
+# if we switch to mathfp the file names must change!
+s_cbrt.c cbrt
+s_copysign.c copysign
+s_expm1.c expm1
+sf_cbrt.c cbrtf
+sf_copysign.c copysignf
+s_fdim.c fdim
+sf_expm1.c expm1f
+sf_fdim.c fdimf
+sf_finite.c finitef not-c99
+sf_fma.c fmaf
+sf_fmax.c fmaxf
+sf_fmin.c fminf
+sf_ilogb.c ilogbf
+sf_infinity.c infinityf
+s_finite.c finite
+sf_log1p.c log1pf
+sf_logb.c logbf
+sf_lrint.c lrintf
+sf_lround.c lroundf
+s_fma.c fma
+s_fmax.c fmax
+s_fmin.c fmin
+sf_modf.c modff
+sf_nan.c nanf
+sf_nearbyint.c nearbyintf
+sf_nextafter.c nextafterf
+s_fpclassify.c fpclassify
+sf_remquo.c remquof
+sf_rint.c rintf
+sf_round.c roundf
+sf_scalbln.c scalblnf
+sf_scalbn.c scalbnf
+sf_trunc.c truncf
+s_ilogb.c ilogb
+s_infconst.c infconst no-functions
+s_infinity.c infinity
+s_lib_ver.c lib_ver no-functions
+s_log1p.c log1p
+s_logb.c logb
+s_lrint.c lrint
+s_lround.c lround
+s_matherr.c matherr not-c99
+s_modf.c modf
+s_nan.c nan
+s_nearbyint.c nearbyint
+s_nextafter.c nextafter
+s_remquo.c remquo
+s_rint.c rint
+s_round.c round
+s_scalbln.c scalbln
+s_scalbn.c scalbn
+s_signbit.c signbit
+s_trunc.c trunc
+s_asinh.c asinh
+s_atan.c atan
+s_ceil.c ceil
+s_cos.c cos
+s_erf.c erf
+s_fabs.c fabs
+sf_asinh.c asinhf
+sf_atan.c atanf
+sf_ceil.c ceilf
+sf_cos.c cosf
+sf_erf.c erff
+sf_fabs.c fabsf
+sf_floor.c floorf
+sf_frexp.c frexpf
+sf_isinf.c isinff
+sf_isnan.c isnanf
+sf_ldexp.c ldexpf
+s_floor.c floor
+s_frexp.c frexp
+sf_signif.c significandf special
+sf_sin.c sinf
+sf_tan.c tanf
+sf_tanh.c tanhf
+s_isinf.c isinf
+s_isnan.c isnan
+s_ldexp.c ldexp
+s_signif.c significand special
+s_sin.c sin
+s_tan.c tan
+s_tanh.c tanh
+w_acos.c acos
+w_acosh.c acosh
+w_asin.c asin
+w_atan2.c atan2
+w_atanh.c atanh
+w_cabs.c cabs
+w_cosh.c cosh
+w_drem.c drem
+w_exp2.c exp2
+w_exp.c exp
+wf_acos.c acosf
+wf_acosh.c acoshf
+wf_asin.c asinf
+wf_atan2.c atan2f
+wf_atanh.c atanhf
+wf_cabs.c cabsf
+wf_cosh.c coshf
+wf_drem.c dremf
+wf_exp2.c exp2f
+wf_exp.c expf
+wf_fmod.c fmodf
+wf_gamma.c gammaf
+wf_hypot.c hypotf
+wf_j0.c j0f
+wf_j1.c j1f
+wf_jn.c jnf
+wf_lgamma.c lgammaf
+wf_log10.c log10f
+wf_log.c logf
+w_fmod.c fmod
+wf_pow.c powf
+wf_remainder.c remainderf
+wf_scalb.c scalbf
+wf_sincos.c sincosf
+wf_sinh.c sinhf
+wf_sqrt.c sqrtf
+wf_tgamma.c tgammaf
+w_gamma.c gamma
+w_hypot.c hypot
+w_j0.c j0
+w_j1.c j1
+w_jn.c jn
+w_lgamma.c lgamma
+w_log10.c log10
+w_log.c log
+w_pow.c pow
+w_remainder.c remainder
+w_scalb.c scalb
+w_sincos.c sincos
+w_sinh.c sinh
+w_sqrt.c sqrt
+w_tgamma.c tgamma
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/null-map newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/null-map
--- orig.newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/null-map	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/file-creation-tools/null-map	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,2 @@
+# used for fe, since there are not common/base fe files (I don't know if
+# there should or could be any, probably not worth it).
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/acosf.h newlib-1.15.0/newlib/libm/machine/spu/headers/acosf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/acosf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/acosf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,78 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _ACOSF_H_
+#define _ACOSF_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include "acosf_v.h"
+
+
+/*
+ * FUNCTION
+ *	float _acosf(float x)
+ *
+ * DESCRIPTION
+ *	_acosf computes the arc cosine of the value x; that is the value
+ *	whose cosine is x. Results are undefined if x is outside the 
+ *	range [-1, 1]. 
+ *
+ *	_acosf returns the arc cosine in radians and the value is 
+ *	mathematically defined to be in the range 0 to PI.
+ */
+
+static __inline float _acosf(float x)
+{
+#ifdef __SPU__
+  return(spu_extract(_acosf_v(spu_promote(x, 0)), 0));
+
+#else /* !__SPU__ */
+
+  union {
+    vector float v;
+    float f[4];
+  } u;
+
+  u.f[0] = x;
+  u.v = _acosf_v(u.v);
+
+  return (u.f[0]);
+
+#endif /* __SPU__ */
+}
+
+#endif /* _ACOSF_H_ */
+
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/acosf_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/acosf_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/acosf_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/acosf_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,73 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _ACOSF_V_H_
+#define _ACOSF_V_H_	1
+
+#include <vec_literal.h>
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+#include "asinf_v.h"
+
+/*
+ * FUNCTION
+ *	vector float _acosf_v(vector float x)
+ *
+ * DESCRIPTION
+ *	_acos computes the arc cosine for a vector of values x; that is the 
+ *	values whose cosine is x. Results are undefined if x is outside the 
+ *	range [-1, 1]. 
+ *
+ *	_acosf_v returns the arc cosine in radians and the value is 
+ *	mathematically defined to be in the range 0 to PI.
+ */
+
+
+static __inline vector float _acosf_v(vector float x)
+{
+  /* The arc-cos is computed using asin as follows:
+   *
+   *       acos(x) = PI/2 - asin(x);
+   */
+#ifdef __SPU__
+  return (spu_sub(VEC_SPLAT_F32(1.5707963267949), _asinf_v(x)));
+#else
+  return (vec_sub(VEC_SPLAT_F32(1.5707963267949), _asinf_v(x)));
+#endif
+}
+
+#endif /* _ACOSF_V_H_ */
+
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/asinf.h newlib-1.15.0/newlib/libm/machine/spu/headers/asinf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/asinf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/asinf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,74 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _ASINF_H_
+#define _ASINF_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include "asinf_v.h"
+
+/*
+ * FUNCTION
+ *	float _asinf(float x)
+ *
+ * DESCRIPTION
+ *	_asinf computes the arc sine of the value x; that is the value
+ *	whose sine is x. Results are undefined if x is outside the 
+ *	range [-1, 1]. 
+ */
+
+static __inline float _asinf(float x)
+{
+#ifdef __SPU__
+  return(spu_extract(_asinf_v(spu_promote(x, 0)), 0));
+
+#else /* !__SPU__ */
+
+  union {
+    vector float v;
+    float f[4];
+  } u;
+
+  u.f[0] = x;
+  u.v = _asinf_v(u.v);
+
+  return (u.f[0]);
+
+#endif /* __SPU__ */
+}
+
+#endif /* _ASINF_H_ */
+
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/asinf_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/asinf_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/asinf_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/asinf_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,193 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _ASINF_V_H_
+#define _ASINF_V_H_	1
+
+#include <vec_literal.h>
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+#include "divide_v.h"
+#include "sqrtf_v.h"
+
+/*
+ * FUNCTION
+ *	vector float _asinf_v(vector float x)
+ *
+ * DESCRIPTION
+ *	_asinf_v computes the arc sine for a vector of values x; that is the 
+ *	values whose sine is x. Results are undefined if x is outside the 
+ *	range [-1, 1]. 
+ */
+
+static __inline vector float _asinf_v(vector float x)
+{
+  /* The arcsin is computed using two different algorithms, depending
+   * upon the absolute value of the input. For inputs in the range 
+   * [0, PI/4], it is computed as the ratio of two polynomials.
+   *
+   *	asin(x) = p/q;
+   *
+   *    where p = P11*x^11 + P09*x^9 + P07*x^7 + P05*x^5 + P03*x3 + x
+   *          q = Q08*x^8  + Q06*x^6 + Q04*x^4 + Q02*x^2 + Q00
+   *
+   * For the range of value [PI/4, 1], the arcsin is computed using:
+   *
+   *    asin = PI/2 - sqrt(1 - x) * r;
+   *
+   *    where r = C07*x^7 + C06*x^6 + C05*x^5 + C04*x^4 + C03*x^3 + C02*x^2
+   *              C01*x   + C00;
+   */
+  vector float r, r1, r2, r_hi, r_lo;
+  vector float xabs, x2, x4, x6;
+  vector float p, p_hi, p_lo;
+  vector float q, q_hi, q_lo;
+  vector float pi_over_2 = VEC_SPLAT_F32(1.5707963267949);
+  vector float pi_over_4 = VEC_SPLAT_F32(0.7853981633974);
+  vector unsigned int msb = VEC_SPLAT_U32(0x80000000);
+
+#ifdef __SPU__
+
+  x2 = spu_mul(x, x);
+  x4 = spu_mul(x2, x2);
+  x6 = spu_mul(x4, x2);
+
+  xabs = spu_andc(x, (vector float)msb);
+
+  /* Compute arc-sin for values in the range [0, PI/4]
+   */
+  p_hi = spu_madd(VEC_SPLAT_F32(0.0000347933107596021167570), x2,
+		  VEC_SPLAT_F32(0.000791534994289814532176));
+  p_hi = spu_madd(p_hi, x2, VEC_SPLAT_F32(-0.0400555345006794114027));
+
+  p_lo = spu_madd(VEC_SPLAT_F32(0.201212532134862925881), x2,
+		  VEC_SPLAT_F32(-0.325565818622400915405));
+  p_lo = spu_madd(p_lo, x2, VEC_SPLAT_F32(0.166666666666666657415));
+  
+  p = spu_madd(p_hi, x6, p_lo);
+
+  q_hi = spu_madd(VEC_SPLAT_F32(0.0770381505559019352791), x2,
+		  VEC_SPLAT_F32(-0.688283971605453293030));
+  q_hi = spu_madd(q_hi, x2, VEC_SPLAT_F32(2.02094576023350569471));
+
+  q_lo = spu_madd(VEC_SPLAT_F32(-2.40339491173441421878), x2, 
+		  VEC_SPLAT_F32(1.0));
+
+  q = spu_madd(q_hi, x4, q_lo);
+
+  r1 = spu_madd(_divide_v(p, q), spu_mul(xabs, x2), xabs);
+
+  /* Compute arc-sin for values in the range [PI/4, 1]
+   */
+  r_hi = spu_madd(VEC_SPLAT_F32(-0.0012624911), xabs,
+		  VEC_SPLAT_F32(0.0066700901));
+  r_hi = spu_madd(r_hi, xabs, VEC_SPLAT_F32(-0.0170881256));
+  r_hi = spu_madd(r_hi, xabs, VEC_SPLAT_F32(0.0308918810f));
+
+  r_lo = spu_madd(VEC_SPLAT_F32(-0.0501743046), xabs,
+		  VEC_SPLAT_F32(0.0889789874));
+  r_lo = spu_madd(r_lo, xabs, VEC_SPLAT_F32(-0.2145988016));
+  r_lo = spu_madd(r_lo, xabs, pi_over_2);
+
+  r = spu_madd(r_hi, x4, r_lo);
+  
+  r2 = spu_nmsub(r, _sqrtf_v(spu_sub(VEC_SPLAT_F32(1.0), xabs)), 
+		 pi_over_2);
+
+  /* Select the result depending upon the input value. Correct the
+   * sign of the result.
+   */
+  return (spu_sel(spu_sel(r1, r2, spu_cmpgt(xabs, pi_over_4)), 
+		  x, msb));
+#else
+  vector float zero = VEC_SPLAT_F32(0.0);
+  
+  x2 = vec_madd(x, x, zero);
+  x4 = vec_madd(x2, x2, zero);
+  x6 = vec_madd(x4, x2, zero);
+
+  xabs = vec_andc(x, (vector float)msb);
+
+  /* Compute arc-sin for values in the range [0, PI/4]
+   */
+  p_hi = vec_madd(VEC_SPLAT_F32(0.0000347933107596021167570), x2,
+		  VEC_SPLAT_F32(0.000791534994289814532176));
+  p_hi = vec_madd(p_hi, x2, VEC_SPLAT_F32(-0.0400555345006794114027));
+
+  p_lo = vec_madd(VEC_SPLAT_F32(0.201212532134862925881), x2,
+		  VEC_SPLAT_F32(-0.325565818622400915405));
+  p_lo = vec_madd(p_lo, x2, VEC_SPLAT_F32(0.166666666666666657415));
+  
+  p = vec_madd(p_hi, x6, p_lo);
+
+  q_hi = vec_madd(VEC_SPLAT_F32(0.0770381505559019352791), x2,
+		  VEC_SPLAT_F32(-0.688283971605453293030));
+  q_hi = vec_madd(q_hi, x2, VEC_SPLAT_F32(2.02094576023350569471));
+
+  q_lo = vec_madd(VEC_SPLAT_F32(-2.40339491173441421878), x2, 
+		  VEC_SPLAT_F32(1.0));
+
+  q = vec_madd(q_hi, x4, q_lo);
+
+  r1 = vec_madd(_divide_v(p, q), vec_madd(xabs, x2, zero), xabs);
+
+  /* Compute arc-sin for values in the range [PI/4, 1]
+   */
+  r_hi = vec_madd(VEC_SPLAT_F32(-0.0012624911), xabs,
+		  VEC_SPLAT_F32(0.0066700901));
+  r_hi = vec_madd(r_hi, xabs, VEC_SPLAT_F32(-0.0170881256));
+  r_hi = vec_madd(r_hi, xabs, VEC_SPLAT_F32(0.0308918810f));
+
+  r_lo = vec_madd(VEC_SPLAT_F32(-0.0501743046), xabs,
+		  VEC_SPLAT_F32(0.0889789874));
+  r_lo = vec_madd(r_lo, xabs, VEC_SPLAT_F32(-0.2145988016));
+  r_lo = vec_madd(r_lo, xabs, pi_over_2);
+
+  r = vec_madd(r_hi, x4, r_lo);
+  
+  r2 = vec_nmsub(r, _sqrtf_v(vec_sub(VEC_SPLAT_F32(1.0), xabs)), 
+		 pi_over_2);
+
+  /* Select the result depending upon the input value. Correct the
+   * sign of the result.
+   */
+  return (vec_sel(vec_sel(r1, r2, vec_cmpgt(xabs, pi_over_4)), 
+		  x, msb));
+#endif
+}
+
+#endif /* _ASINF_V_H_ */
+
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/atanf.h newlib-1.15.0/newlib/libm/machine/spu/headers/atanf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/atanf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/atanf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,112 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _ATANF_H_
+#define _ATANF_H_	1
+
+#ifndef M_PI_2
+#define M_PI_2		1.5707963267949f
+#endif /* M_PI_2 */
+
+/*
+ * FUNCTION
+ *	float _atanf(float x)
+ *
+ * DESCRIPTION
+ *	_atanf computes the arc tangent of the value x; that is the value
+ *	whose tangent is x.
+ *
+ *	_atanf returns the arc tangent in radians and the value is 
+ *	mathematically defined to be in the range -PI/2 to PI/2.
+ *
+ *	The arc tangent function is computed using a polynomial approximation
+ *	(B. Carlson, M. Goldstein, Los Alamos Scientific Laboratiry, 1955).
+ *                __8__
+ *		  \
+ *		   \ 
+ *	atanf(x) =  /    Ci*x^(2*i+1)
+ *                /____
+ *                 i=0
+ *
+ *	for x in the range -1 to 1. The remaining regions are defined to be:
+ *
+ *	[1, infinity]   :  PI/2 + atanf(-1/x)
+ *	[-infinity, -1] : -PI/2 + atanf(-1/x)
+ */
+
+static __inline float _atanf(float x)
+{
+  float xabs;
+  float bias;
+  float x2, x3, x4, x8, x9;
+  float hi, lo;
+  float result;
+
+  bias = 0.0f;
+  xabs = (x < 0.0f) ? -x : x;
+
+  if (xabs >= 1.0f) {
+    bias = M_PI_2;
+    if (x < 0.0f) {
+      bias = -bias;
+    }
+    x = -1.0f / x;
+  }
+  /* Instruction counts can be reduced if the polynomial was
+   * computed entirely from nested (dependent) fma's. However, 
+   * to reduce the number of pipeline stalls, the polygon is evaluated 
+   * in two halves(hi and lo).
+   */
+  bias += x;
+
+  x2 = x * x;
+  x3 = x2 * x;
+  x4 = x2 * x2;
+  x8 = x4 * x4;
+  x9 = x8 * x;
+  hi =  0.0028662257f * x2 - 0.0161657367f;
+  hi =             hi * x2 + 0.0429096138f;
+  hi =             hi * x2 - 0.0752896400f;
+  hi =             hi * x2 + 0.1065626393f;
+  lo = -0.1420889944f * x2 + 0.1999355085f;
+  lo =             lo * x2 - 0.3333314528f;
+  lo =             lo * x3 + bias;
+
+  result = hi * x9 + lo;
+
+  return (result);
+}
+
+#endif /* _ATANF_H_ */
+
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cbrtf.h newlib-1.15.0/newlib/libm/machine/spu/headers/cbrtf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cbrtf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/cbrtf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,124 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _CBRTF_H_
+#define _CBRTF_H_		1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+extern double cbrt_factors[5];
+
+/* Compute the cube root of the floating point input x.
+ */
+
+static __inline float _cbrtf(float x)
+{
+  vec_int4 exp, bias;
+  vec_uint4 mask, e_div_3, e_mod_3;
+  vec_uint4 mant_mask = VEC_SPLAT_U32(0x7FFFFF);
+  vec_float4 in;
+  vec_float4 half = VEC_SPLAT_F32(0.5f);
+  vec_float4 onef = VEC_SPLAT_F32(1.0f);
+  vec_float4 out, mant, ym, bf, inv_bf;
+  vec_double2 two = VEC_SPLAT_F64(2.0);
+  /* Polynomial coefficients */
+  vec_double2 c2 = VEC_SPLAT_F64(0.191502161678719066);
+  vec_double2 c1 = VEC_SPLAT_F64(0.697570460207922770);
+  vec_double2 c0 = VEC_SPLAT_F64(0.492659620528969547);
+  vec_double2 a0, b0, inv_b0, ym0;
+  vec_double2 mant0, u0, u0_3, factor0;
+
+  in = spu_promote(x, 0);
+
+  /* Normalize the mantissa (fraction part) into the range [0.5, 1.0) and 
+   * extract the exponent. 
+   */
+  mant = spu_sel(half, in, mant_mask);
+  exp = spu_and(spu_rlmask((vec_int4)in, -23), 0xFF);
+
+  /* Generate mask used to zero result if the exponent is zero (ie, in is either
+   * zero or a denorm
+   */
+  mask = spu_cmpeq(exp, 0);
+  exp = spu_add(exp, -126);
+
+  mant0 = spu_extend(mant);
+
+  u0 = spu_madd(mant0, spu_nmsub(mant0, c2, c1), c0);
+  u0_3 = spu_mul(spu_mul(u0, u0), u0);
+
+  /* Compute: e_div_3 = exp/3
+   *
+   * Fetch:   factor = factor[2+exp%3]
+   * 
+   * The factors array contains 5 values: 2^(-2/3), 2^(-1/3), 2^0, 2^(1/3), 2^(2/3), 2^1.
+   */
+  bias = spu_rlmask(spu_rlmaska(exp, -15), -16);
+  e_div_3 = (vec_uint4)spu_rlmaska(spu_madd((vec_short8)exp, VEC_SPLAT_S16(0x5556), bias), -16);
+
+  e_mod_3 = (vec_uint4)spu_sub((vec_int4)(exp), spu_mulo((vec_short8)e_div_3, VEC_SPLAT_S16(3)));
+
+  e_mod_3 = spu_add(e_mod_3, 2);
+
+  factor0 = spu_promote(cbrt_factors[spu_extract(e_mod_3, 0)], 0);
+
+  /* Compute the estimated mantissa cube root (ym) equals:
+   *       ym = (u * factor * (2.0 * mant + u3)) / (2.0 * u3 + mant);
+   */
+  a0 = spu_mul(spu_mul(factor0, u0), spu_madd(two, mant0, u0_3));
+  b0 = spu_madd(two, u0_3, mant0);
+
+  bf = spu_roundtf(b0);
+
+  inv_bf = spu_re(bf);
+  inv_bf = spu_madd(spu_nmsub(bf, inv_bf, onef), inv_bf, inv_bf);
+
+  inv_b0 = spu_extend(inv_bf);
+
+  ym0 = spu_mul(a0, inv_b0);
+  ym0 = spu_madd(spu_nmsub(b0, ym0, a0), inv_b0, ym0);
+
+  ym = spu_roundtf(ym0);
+
+  /* Merge sign, computed exponent, and computed mantissa.
+   */
+  exp = spu_rl(spu_add((vec_int4)e_div_3, 127), 23);
+  out = spu_sel((vec_float4)exp, in, VEC_SPLAT_U32(0x80000000));
+  out = spu_mul(out, ym);
+
+  out = spu_andc(out, (vec_float4)mask);
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _CBRTF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cbrt.h newlib-1.15.0/newlib/libm/machine/spu/headers/cbrt.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cbrt.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/cbrt.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,128 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _CBRT_H_
+#define _CBRT_H_		1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+extern double cbrt_factors[5];
+
+/* Compute the cube root of x to double precision.
+ */
+
+static __inline double _cbrt(double x)
+{
+  vec_int4 exp, bias;
+  vec_uint4 e_div_3, e_mod_3;
+  vec_float4 bf, inv_bf;
+  vec_float4 onef = VEC_SPLAT_F32(1.0f);
+  vec_ullong2 mask;
+  vec_ullong2 mant_mask = VEC_SPLAT_U64(0xFFFFFFFFFFFFFULL);
+  vec_double2 one = VEC_SPLAT_F64(1.0);
+  vec_double2 two = VEC_SPLAT_F64(2.0);
+  vec_double2 half = VEC_SPLAT_F64(0.5);
+  /* Polynomial coefficients */
+  vec_double2 c0 = VEC_SPLAT_F64(0.354895765043919860);
+  vec_double2 c1 = VEC_SPLAT_F64(1.50819193781584896);
+  vec_double2 c2 = VEC_SPLAT_F64(-2.11499494167371287);
+  vec_double2 c3 = VEC_SPLAT_F64(2.44693122563534430);
+  vec_double2 c4 = VEC_SPLAT_F64(-1.83469277483613086);
+  vec_double2 c5 = VEC_SPLAT_F64(0.784932344976639262);
+  vec_double2 c6 = VEC_SPLAT_F64(0.145263899385486377);
+  vec_double2 in, out, mant, u, u3, ym, a, b, factor, inv_b;
+
+  in = spu_promote(x, 0);
+
+  /* Normalize the mantissa (fraction part) into the range [0.5, 1.0) and 
+   * extract the exponent. 
+   */
+  mant = spu_sel(half, in, mant_mask);
+  exp = spu_and(spu_rlmask((vec_int4)in, -20), 0x7FF);
+
+  /* Generate mask used to zero result if the exponent is zero (ie, <in> is 
+   * either zero or a denorm
+   */
+  mask = (vec_ullong2)spu_cmpeq(exp, 0);
+  mask = spu_shuffle(mask, mask, VEC_LITERAL(vec_uchar16, 0,1,2,3,0,1,2,3,8,9,10,11,8,9,10,11));
+  exp = spu_add(exp, -1022);
+
+  u = spu_madd(mant, spu_madd(mant, spu_madd(mant, spu_madd(mant, spu_madd(mant, spu_nmsub(mant, c6, c5), c4), c3), c2), c1), c0); 
+  u3 = spu_mul(spu_mul(u, u), u);
+
+  /* Compute: e_div_3 = exp/3
+   *
+   * Fetch:   factor = factor[2+exp%3]
+   * 
+   * The factors array contains 5 values: 2^(-2/3), 2^(-1/3), 2^0, 2^(1/3), 
+   *                                      2^(2/3),  2^1.
+   * The fetch is done using shuffle bytes so that is can easily be extended 
+   * to support SIMD compution.
+   */
+  bias = spu_rlmask(spu_rlmaska(exp, -15), -16);
+  e_div_3 = (vec_uint4)spu_rlmaska(spu_madd((vec_short8)exp, VEC_SPLAT_S16(0x5556), bias), -16);
+
+  e_mod_3 = (vec_uint4)spu_sub((vec_int4)(exp), spu_mulo((vec_short8)e_div_3, VEC_SPLAT_S16(3)));
+
+  factor = spu_promote(cbrt_factors[2+spu_extract(e_mod_3, 0)], 0);
+
+  /* Compute the estimated mantissa cube root (ym) equals:
+   *       ym = (u * factor * (2.0 * mant + u3)) / (2.0 * u3 + mant);
+   */
+  a = spu_mul(spu_mul(factor, u), spu_madd(two, mant, u3));
+  b = spu_madd(two, u3, mant);
+
+  bf = spu_roundtf(b);
+  inv_bf = spu_re(bf);
+  inv_bf = spu_madd(spu_nmsub(bf, inv_bf, onef), inv_bf, inv_bf);
+
+  inv_b = spu_extend(inv_bf);
+  inv_b = spu_madd(spu_nmsub(b, inv_b, one), inv_b, inv_b);
+
+  ym = spu_mul(a, inv_b);
+  ym = spu_madd(spu_nmsub(b, ym, a), inv_b, ym);
+
+  /* Merge sign, computed exponent, and computed mantissa.
+   */
+  exp = spu_rl(spu_add((vec_int4)e_div_3, 1023), 20);
+  exp = spu_andc(exp, (vec_int4)mant_mask);
+  out = spu_sel((vec_double2)exp, in, VEC_SPLAT_U64(0x8000000000000000ULL));
+  out = spu_mul(out, ym);
+
+  out = spu_andc(out, (vec_double2)mask);
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _CBRT_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ceilf.h newlib-1.15.0/newlib/libm/machine/spu/headers/ceilf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ceilf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/ceilf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,138 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _CEILF_H_
+#define _CEILF_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include <vec_literal.h>
+
+/*
+ * FUNCTION
+ *	float _ceilf(float value)
+ *
+ * DESCRIPTION
+ *	The _ceilf routine round the input value "value" upwards to the
+ *	nearest integer returning the result as a float. Two forms of the 
+ *	ceiling function are provided - full range and limited (integer) 
+ *	range. 
+ *
+ *	The full range form (default) provides ceiling computation on 
+ *	all IEEE floating point values. The ceiling of NANs remain NANs.
+ *	The ceiling of denorms results in zero.
+ *
+ *	The limited range form (selected by defining CEIL_INTEGER_RANGE)
+ *	compute ths ceiling of all floating-point values in the 32-bit
+ *	signed integer range. Values outside this range get clamped.
+ */
+
+static __inline float _ceilf(float value)
+{
+#ifdef __SPU__
+#ifdef CEIL_INTEGER_RANGE
+  /* 32-BIT INTEGER DYNAMIC RANGE 
+   */
+  union {
+    float f;
+    signed int i;
+    unsigned int ui;
+  } bias;
+
+  bias.f = value;
+
+  /* If positive, bias the input value to truncate towards
+   * positive infinity, instead of zero.
+   */
+  bias.ui = ~(unsigned int)(bias.i >> 31) & 0x3F7FFFFF;
+  value += bias.f;
+
+  /* Remove fraction bits by casting to an integer and back
+   * to a floating-point value.
+   */
+  return ((float)((int)value));
+
+#else /* !CEIL_INTEGER_RANGE */
+  /* FULL FLOATING-POINT RANGE 
+   */
+  vec_int4 exp, shift;
+  vec_uint4 mask, frac_mask, addend, insert, pos;
+  vec_float4 in, out;
+  vec_float4 one = VEC_SPLAT_F32(1.0f);
+
+  in = spu_promote(value, 0);
+
+  /* This function generates the following component
+   * based upon the inputs.
+   *
+   *   mask = bits of the input that need to be replaced.
+   *   insert = value of the bits that need to be replaced
+   *   addend = value to be added to perform function.
+   *
+   * These are applied as follows:.
+   *
+   *   out = ((in & mask) | insert) + addend
+   */
+  pos = spu_cmpgt((vec_int4)in, -1);
+  exp = spu_and(spu_rlmask((vec_int4)in, -23), 0xFF);
+
+  shift = spu_sub(127, exp);
+
+  frac_mask = spu_and(spu_rlmask(VEC_SPLAT_U32(0x7FFFFF), shift),
+		      spu_cmpgt((vec_int4)shift, -31));
+
+  mask = spu_orc(frac_mask, spu_cmpgt(exp, 126));
+
+  addend = spu_andc(spu_and(spu_add(mask, 1), pos), spu_cmpeq(spu_and((vec_uint4)in, mask), 0));
+  
+  insert = spu_andc(spu_and(pos, (vec_uint4)one), 
+		    spu_cmpgt((vec_uint4)spu_add(exp, -1), 126));
+
+  out = (vec_float4)spu_add(spu_sel((vec_uint4)in, insert, mask), addend);
+
+  return (spu_extract(out, 0));
+#endif /* CEIL_INTEGER_RANGE */
+
+#else /* !__SPU__ */
+  union {
+    vector float fv;
+    float f[4];
+  } in;
+
+  in.f[0] = value;
+  in.fv = vec_ceil(in.fv);
+
+  return (in.f[0]);
+#endif /* __SPU__ */
+}
+#endif /* _CEILF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ceil.h newlib-1.15.0/newlib/libm/machine/spu/headers/ceil.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ceil.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/ceil.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,95 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _CEIL_H_
+#define _CEIL_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Round the input upwards to the nearest integer.
+ */
+
+
+static __inline double _ceil(double x)
+{
+  vec_uchar16 swap_words = VEC_LITERAL(vec_uchar16, 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11);
+  vec_uchar16 splat_hi = VEC_LITERAL(vec_uchar16, 0,1,2,3,0,1,2,3, 8,9,10,11, 8,9,10,11);
+  vec_uint4 one = VEC_LITERAL(vec_uint4, 0, 1, 0, 1);
+  vec_int4 exp, shift;
+  vec_uint4 mask, mask_1, frac_mask, addend, insert, pos, equal0;
+  vec_ullong2 sign = VEC_SPLAT_U64(0x8000000000000000ULL);
+  vec_double2 in, in_hi, out;
+  vec_double2 one_d = VEC_SPLAT_F64(1.0);
+
+  in = spu_promote(x, 0);
+
+  /* This function generates the following component
+   * based upon the inputs.
+   *
+   *   mask = bits of the input that need to be replaced.
+   *   insert = value of the bits that need to be replaced
+   *   addend = value to be added to perform function.
+   *
+   * These are applied as follows:.
+   *
+   *   out = ((in & mask) | insert) + addend
+   */
+  in_hi = spu_shuffle(in, in, splat_hi);
+  pos = spu_cmpgt((vec_int4)in_hi, -1);
+  exp = spu_and(spu_rlmask((vec_int4)in_hi, -20), 0x7FF);
+  shift = spu_sub(VEC_LITERAL(vec_int4, 1023, 1043, 1023, 1043), exp);
+
+  /* clamp shift to the range 0 to -31.
+   */
+  shift = spu_sel(VEC_SPLAT_S32(-32), spu_andc(shift, (vec_int4)spu_cmpgt(shift, 0)), spu_cmpgt(shift, -32));
+
+  frac_mask = spu_rlmask(VEC_LITERAL(vec_uint4, 0xFFFFF, -1, 0xFFFFF, -1), shift);
+  mask = spu_orc(frac_mask, spu_cmpgt(exp, 0x3FE));
+
+  /* addend = ((in & mask) && (in >= 0)) ? mask+1 : 0
+   */
+  mask_1 = spu_addx(mask, one, spu_rlqwbyte(spu_genc(mask, one), 4));
+
+  equal0 = spu_cmpeq(spu_and((vec_uint4)in, mask), 0);
+  addend = spu_andc(spu_and(mask_1, pos), spu_and(equal0, spu_shuffle(equal0, equal0, swap_words)));
+
+  insert = spu_andc(spu_and(pos, (vec_uint4)one_d), 
+		    spu_cmpgt((vec_uint4)spu_add(exp, -1), 1022));
+
+  in = spu_sel(in, (vec_double2)insert, spu_andc((vec_ullong2)mask, sign));
+  out = (vec_double2)spu_addx((vec_uint4)in, addend, spu_rlqwbyte(spu_genc((vec_uint4)in, addend), 4));
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _CEIL_H */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/copysignf.h newlib-1.15.0/newlib/libm/machine/spu/headers/copysignf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/copysignf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/copysignf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,48 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _COPYSIGNF_H_
+#define _COPYSIGNF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* copysign - produces a value with the magnitude of x and the
+ * sign of y.
+ */
+static __inline float _copysignf(float x, float y)
+{
+  return (spu_extract(spu_sel(spu_promote(x, 0), spu_promote(y, 0),
+			      VEC_SPLAT_U32(0x80000000)), 0));
+}
+
+#endif /* _COPYSIGNF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/copysign.h newlib-1.15.0/newlib/libm/machine/spu/headers/copysign.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/copysign.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/copysign.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,48 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _COPYSIGN_H_
+#define _COPYSIGN_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* copysign - produces a value with the magnitude of x and the
+ * sign of y.
+ */
+static __inline double _copysign(double x, double y)
+{
+  return (spu_extract(spu_sel(spu_promote(x, 0), spu_promote(y, 0),
+			      VEC_SPLAT_U64(0x8000000000000000ULL)), 0));
+}
+
+#endif /* _COPYSIGN_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cosf.h newlib-1.15.0/newlib/libm/machine/spu/headers/cosf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cosf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/cosf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,63 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _COSF_H_
+#define _COSF_H_		1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include "cosf_v.h"
+
+
+static __inline float _cosf(float angle)
+{
+#ifdef __SPU__
+
+  return(spu_extract(_cosf_v(spu_promote(angle, 0)), 0));
+
+#else /* !__SPU__ */
+
+  union {
+    vector float v;
+    float f[4];
+  } u;
+
+  u.f[0] = angle;
+  u.v = _cosf_v(u.v);
+
+  return (u.f[0]);
+
+#endif /* __SPU__ */
+}
+
+#endif /* _COSF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cosf_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/cosf_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cosf_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/cosf_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,119 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _COSF_V_H_
+#define _COSF_V_H_	1
+
+#include <vec_literal.h>
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+#include "cos_sin.h"
+
+static __inline vector float _cosf_v(vector float angle)
+{
+#ifdef __SPU__
+  vec_int4   octant;
+  vec_uint4  select;
+  vec_float4 cos, sin;
+  vec_float4 toggle_sign, answer;
+
+  /* Range reduce the input angle x into the range -PI/4 to PI/4
+   * by performing simple modulus.
+   */
+  MOD_PI_OVER_FOUR_F(angle, octant);
+
+  /* Compute the cosine and sine of the range reduced input.
+   */
+  COMPUTE_COS_SIN_F(angle, cos, sin);
+
+  /* For each SIMD element, select which result (cos or sin) to use
+   * with a sign correction depending upon the octant of the original
+   * angle (Maclaurin series).
+   *
+   *   octants      angles     select  sign toggle 
+   *   -------   ------------  ------  -----------
+   *     0          0 to 45     cos        no      
+   *    1,2        45 to 135    sin        yes
+   *    3,4       135 to 225    cos        yes
+   *    5,6       225 to 315    sin        no
+   *     7        315 to 360    cos        no
+   */ 
+  toggle_sign = (vec_float4)spu_sl(spu_and(spu_add(octant, 2), 4), 29);
+  select = spu_cmpeq(spu_and(octant, 2), 0);
+
+  answer = spu_xor(spu_sel(sin, cos, select), toggle_sign);
+
+  return (answer);
+
+#else	/* !__SPU__ */
+
+  vector float cos, sin;
+  vector float toggle_sign, answer;
+  vector bool int select;
+  vector signed int octant;
+  vector signed int two = VEC_SPLAT_S32(2);
+  
+  /* Range reduce the input angle x into the range -PI/4 to PI/4
+   * by performing simple modulus.
+   */
+  MOD_PI_OVER_FOUR_F(angle, octant);
+
+  /* Compute the cosine and sine of the range reduced input.
+   */
+  COMPUTE_COS_SIN_F(angle, cos, sin);
+
+
+  /* For each SIMD element, select which result (cos or sin) to use
+   * with a sign correction depending upon the octant of the original
+   * angle (Maclaurin series).
+   *
+   *   octants       angles    select  sign toggle 
+   *   -------   ------------   ------  -----------
+   *     0          0 to 45     cos        no      
+   *    1,2        45 to 135    sin        yes
+   *    3,4       135 to 225    cos        yes
+   *    5,6       225 to 315    sin        no
+   *     7        315 to 360    cos        no
+   */ 
+  toggle_sign = (vector float)vec_sl(vec_and(vec_add(octant, two), VEC_SPLAT_S32(4)), 
+				     VEC_SPLAT_U32(29));
+  select = vec_cmpeq(vec_and(octant, two), VEC_SPLAT_S32(0));
+  answer = vec_xor(vec_sel(sin, cos, select), toggle_sign);;
+
+  return (answer);
+
+#endif	/* __SPU__ */
+}
+
+#endif /* _COSF_V_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cos.h newlib-1.15.0/newlib/libm/machine/spu/headers/cos.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cos.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/cos.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,44 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _COS_H_
+#define _COS_H_		1
+
+#include <spu_intrinsics.h>
+#include "cos_v.h"
+
+static __inline double _cos(double x)
+{
+  return (spu_extract(_cos_v(spu_promote(x, 0)), 0));
+}
+
+#endif /* _COS_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cos_sin.h newlib-1.15.0/newlib/libm/machine/spu/headers/cos_sin.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cos_sin.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/cos_sin.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,262 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _COS_SIN_H_
+#define _COS_SIN_H_	1
+
+#include <vec_literal.h>
+
+#define M_PI_OVER_4_HI_32 0x3fe921fb
+
+#define M_PI_OVER_4	0.78539816339744827900
+#define M_FOUR_OVER_PI 	1.27323954478442180616
+
+#define M_PI_OVER_2	1.57079632679489655800
+#define M_PI_OVER_2_HI 	1.57079632673412561417
+#define M_PI_OVER_2_LO 	0.0000000000607710050650619224932
+
+#define M_PI_OVER_2F_HI   1.570312500000000000
+#define M_PI_OVER_2F_LO	  0.000483826794896558
+
+/* The following coefficients correspond to the Taylor series
+ * coefficients for cos and sin.
+ */
+#define COS_14 -0.00000000001138218794258068723867
+#define COS_12  0.000000002087614008917893178252
+#define COS_10 -0.0000002755731724204127572108
+#define COS_08  0.00002480158729870839541888
+#define COS_06 -0.001388888888888735934799
+#define COS_04  0.04166666666666666534980
+#define COS_02 -0.5000000000000000000000
+#define COS_00  1.0
+
+#define SIN_15 -0.00000000000076471637318198164759
+#define SIN_13  0.00000000016059043836821614599
+#define SIN_11 -0.000000025052108385441718775
+#define SIN_09  0.0000027557319223985890653
+#define SIN_07 -0.0001984126984126984127
+#define SIN_05  0.008333333333333333333
+#define SIN_03 -0.16666666666666666666
+#define SIN_01  1.0
+
+#ifdef __SPU__
+
+/* Compute the following for each floating point element of x. 
+ * 	x  = fmod(x, PI/4); 
+ *  	ix = (int)x * PI/4;
+ * This allows one to compute cos / sin over the limited range
+ * and select the sign and correct result based upon the octant
+ * of the original angle (as defined by the ix result).
+ *
+ * Expected Inputs Types: 
+ * 	x  = vec_float4
+ *	ix = vec_int4
+ */
+#define MOD_PI_OVER_FOUR_F(_x, _ix) {					\
+  vec_float4 fx;							\
+									\
+  _ix = spu_convts(spu_mul(_x, VEC_SPLAT_F32(M_FOUR_OVER_PI)), 0);	\
+  _ix = spu_add(_ix, spu_add(spu_rlmaska((vec_int4)_x, -31), 1));	\
+									\
+  fx = spu_convtf(spu_rlmaska(_ix, -1), 0);				\
+  _x  = spu_nmsub(fx, VEC_SPLAT_F32(M_PI_OVER_2F_HI), _x);		\
+  _x  = spu_nmsub(fx, VEC_SPLAT_F32(M_PI_OVER_2F_LO), _x);		\
+}
+
+/* Double precision MOD_PI_OVER_FOUR
+ *
+ * Expected Inputs Types: 
+ * 	x  = vec_double2
+ *	ix = vec_int4
+ */
+#define MOD_PI_OVER_FOUR(_x, _ix) {					\
+  vec_float4 fx;							\
+  vec_double2 dix;							\
+									\
+  fx = spu_roundtf(spu_mul(_x, VEC_SPLAT_F64(M_FOUR_OVER_PI)));		\
+  _ix = spu_convts(fx, 0);						\
+  _ix = spu_add(_ix, spu_add(spu_rlmaska((vec_int4)fx, -31), 1));	\
+									\
+  dix = spu_extend(spu_convtf(spu_rlmaska(_ix, -1), 0));		\
+  _x  = spu_nmsub(VEC_SPLAT_F64(M_PI_OVER_2_HI), dix, _x);		\
+  _x  = spu_nmsub(VEC_SPLAT_F64(M_PI_OVER_2_LO), dix, _x);		\
+}
+
+
+/* Compute the cos(x) and sin(x) for the range reduced angle x.
+ * In order to compute these trig functions to full single precision
+ * accuracy, we solve the Taylor series.
+ *
+ *   c = cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + x^8/8! - x^10/10!
+ *   s = sin(x) = x - x^3/4! + x^5/5! - x^7/7! + x^9/9! - x^11/11!
+ *
+ * Expected Inputs Types: 
+ * 	x = vec_float4
+ *	c = vec_float4
+ *	s = vec_float4
+ */
+
+#define COMPUTE_COS_SIN_F(_x, _c, _s) {					\
+  vec_float4 x2, x4, x6;						\
+  vec_float4 cos_hi, cos_lo;						\
+  vec_float4 sin_hi, sin_lo;						\
+									\
+  x2 = spu_mul(_x, _x);							\
+  x4 = spu_mul(x2, x2);							\
+  x6 = spu_mul(x2, x4);							\
+									\
+  cos_hi = spu_madd(VEC_SPLAT_F32(COS_10), x2, VEC_SPLAT_F32(COS_08));	\
+  cos_lo = spu_madd(VEC_SPLAT_F32(COS_04), x2, VEC_SPLAT_F32(COS_02));	\
+  cos_hi = spu_madd(cos_hi, x2, VEC_SPLAT_F32(COS_06));			\
+  cos_lo = spu_madd(cos_lo, x2, VEC_SPLAT_F32(COS_00));			\
+  _c     = spu_madd(cos_hi, x6, cos_lo);				\
+									\
+  sin_hi = spu_madd(VEC_SPLAT_F32(SIN_11), x2, VEC_SPLAT_F32(SIN_09));	\
+  sin_lo = spu_madd(VEC_SPLAT_F32(SIN_05), x2, VEC_SPLAT_F32(SIN_03));	\
+  sin_hi = spu_madd(sin_hi, x2, VEC_SPLAT_F32(SIN_07));			\
+  sin_lo = spu_madd(sin_lo, x2, VEC_SPLAT_F32(SIN_01));			\
+  _s    = spu_madd(sin_hi, x6, sin_lo);					\
+  _s     = spu_mul(_s, _x);						\
+}
+
+
+/* Compute the cos(x) and sin(x) for the range reduced angle x.
+ * This version computes the cosine and sine to double precision 
+ * accuracy using the Taylor series:
+ *
+ *   c = cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + x^8/8! - x^10/10! + x^12/12! - x^14/14!
+ *   s = sin(x) = x - x^3/4! + x^5/5! - x^7/7! + x^9/9! - x^11/11! + x^13/13! - x^15/15!
+ *
+ * Expected Inputs Types: 
+ * 	x = vec_double2
+ *	c = vec_double2
+ *	s = vec_double2
+ */
+
+#define COMPUTE_COS_SIN(_x, _c, _s) {					\
+  vec_double2 x2, x4, x8;						\
+  vec_double2 cos_hi, cos_lo;						\
+  vec_double2 sin_hi, sin_lo;						\
+									\
+  x2 = spu_mul(_x, _x);							\
+  x4 = spu_mul(x2, x2);							\
+  x8 = spu_mul(x4, x4);							\
+									\
+  cos_hi = spu_madd(VEC_SPLAT_F64(COS_14), x2, VEC_SPLAT_F64(COS_12));	\
+  cos_lo = spu_madd(VEC_SPLAT_F64(COS_06), x2, VEC_SPLAT_F64(COS_04));	\
+  cos_hi = spu_madd(cos_hi, x2, VEC_SPLAT_F64(COS_10));			\
+  cos_lo = spu_madd(cos_lo, x2, VEC_SPLAT_F64(COS_02));			\
+  cos_hi = spu_madd(cos_hi, x2, VEC_SPLAT_F64(COS_08));			\
+  cos_lo = spu_madd(cos_lo, x2, VEC_SPLAT_F64(COS_00));			\
+  _c     = spu_madd(cos_hi, x8, cos_lo);				\
+									\
+  sin_hi = spu_madd(VEC_SPLAT_F64(SIN_15), x2, VEC_SPLAT_F64(SIN_13));	\
+  sin_lo = spu_madd(VEC_SPLAT_F64(SIN_07), x2, VEC_SPLAT_F64(SIN_05));	\
+  sin_hi = spu_madd(sin_hi, x2, VEC_SPLAT_F64(SIN_11));			\
+  sin_lo = spu_madd(sin_lo, x2, VEC_SPLAT_F64(SIN_03));			\
+  sin_hi = spu_madd(sin_hi, x2, VEC_SPLAT_F64(SIN_09));			\
+  sin_lo = spu_madd(sin_lo, x2, VEC_SPLAT_F64(SIN_01));			\
+  _s     = spu_madd(sin_hi, x8, sin_lo);				\
+  _s     = spu_mul(_s, _x);						\
+}
+
+
+#else	/* !__SPU__ */
+
+/* Compute the following for each floating point element of x. 
+ * 	x  = fmod(x, PI/4); 
+ *  	ix = (int)x * PI/4;
+ * This allows one to compute cos / sin over the limited range
+ * and select the sign and correct result based upon the octant
+ * of the original angle (as defined by the ix result).
+ *
+ * Expected Inputs Types: 
+ * 	x  = vector float
+ *	ix = vector signed int
+ */
+
+#define MOD_PI_OVER_FOUR_F(_x, _ix) {									\
+  vector float fx;											\
+  vector float zero = VEC_SPLAT_F32(0.0);								\
+  vector signed int one = VEC_SPLAT_S32(1);								\
+													\
+  _ix = vec_cts(vec_madd(_x, VEC_SPLAT_F32(M_FOUR_OVER_PI), zero), 0);					\
+  _ix = vec_add(_ix, vec_add(vec_sra((vector signed int)(_x), VEC_SPLAT_U32(31)), one));		\
+													\
+  fx = vec_ctf(vec_sra(_ix, VEC_SPLAT_U32(1)), 0);							\
+  _x  = vec_nmsub(fx, VEC_SPLAT_F32(M_PI_OVER_2F_HI), _x);						\
+  _x  = vec_nmsub(fx, VEC_SPLAT_F32(M_PI_OVER_2F_LO), _x);						\
+}
+
+
+/* Compute the cos(x) and sin(x) for the range reduced angle x.
+ * In order to compute these trig functions to full single precision
+ * accuracy, we solve the Taylor series.
+ *
+ *   c = cos(x) = 1 - x^2/2! + x^4/4! - x^6/6! + x^8/8! - x^10/10!
+ *   s = sin(x) = x - x^3/4! + x^5/5! - x^7/7! + x^9/9! - x^11/11!
+ *
+ * Expected Inputs Types: 
+ * 	x = vector float
+ *	c = vector float
+ *	s = vector float
+ */
+#define COMPUTE_COS_SIN_F(_x, _c, _s) {						\
+  vector float x2, x4, x6;							\
+  vector float cos_hi, cos_lo;							\
+  vector float sin_hi, sin_lo;							\
+  vector float zero = VEC_SPLAT_F32(0.0);					\
+										\
+  x2 = vec_madd(_x, _x, zero);							\
+  x4 = vec_madd(x2, x2, zero);							\
+  x6 = vec_madd(x2, x4, zero);							\
+										\
+  cos_hi = vec_madd(VEC_SPLAT_F32(COS_10), x2, VEC_SPLAT_F32(COS_08));		\
+  cos_lo = vec_madd(VEC_SPLAT_F32(COS_04), x2, VEC_SPLAT_F32(COS_02));		\
+  cos_hi = vec_madd(cos_hi, x2, VEC_SPLAT_F32(COS_06));				\
+  cos_lo = vec_madd(cos_lo, x2, VEC_SPLAT_F32(COS_00));				\
+  _c     = vec_madd(cos_hi, x6, cos_lo);					\
+										\
+  sin_hi = vec_madd(VEC_SPLAT_F32(SIN_11), x2, VEC_SPLAT_F32(SIN_09));		\
+  sin_lo = vec_madd(VEC_SPLAT_F32(SIN_05), x2, VEC_SPLAT_F32(SIN_03));		\
+  sin_hi = vec_madd(sin_hi, x2, VEC_SPLAT_F32(SIN_07));				\
+  sin_lo = vec_madd(sin_lo, x2, VEC_SPLAT_F32(SIN_01));				\
+  _s     = vec_madd(sin_hi, x6, sin_lo);					\
+  _s     = vec_madd(_s, _x, zero);						\
+}
+
+#endif	/* __SPU__ */
+
+#endif /* _COS_SIN_H_ */
+
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cos_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/cos_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/cos_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/cos_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,78 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _COS_V_H_
+#define _COS_V_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+#include "cos_sin.h"
+
+static __inline vector double _cos_v(vector double angle)
+{
+  vec_int4    octant;
+  vec_ullong2 select;
+  vec_double2 cos, sin;
+  vec_double2 toggle_sign, answer;
+
+  /* Range reduce the input angle x into the range -PI/4 to PI/4
+   * by performing simple modulus.
+   */
+  MOD_PI_OVER_FOUR(angle, octant);
+
+  /* Compute the cosine and sine of the range reduced input.
+   */
+  COMPUTE_COS_SIN(angle, cos, sin);
+
+  /* For each SIMD element, select which result (cos or sin) to use
+   * with a sign correction depending upon the octant of the original
+   * angle (Maclaurin series).
+   *
+   *   octants      angles     select  sign toggle 
+   *   -------   ------------  ------  -----------
+   *     0          0 to 45     cos        no      
+   *    1,2        45 to 135    sin        yes
+   *    3,4       135 to 225    cos        yes
+   *    5,6       225 to 315    sin        no
+   *     7        315 to 360    cos        no
+   */ 
+  octant = spu_shuffle(octant, octant, VEC_LITERAL(vec_uchar16, 0,1, 2, 3, 0,1, 2, 3, 8,9,10,11, 8,9,10,11));
+
+  toggle_sign = (vec_double2)spu_sl(spu_and(spu_add(octant, 2), 4), VEC_LITERAL(vec_uint4, 29,32,29,32));
+  select = (vec_ullong2)spu_cmpeq(spu_and(octant, 2), 0);
+
+  answer = spu_xor(spu_sel(sin, cos, select), toggle_sign);
+
+  return (answer);
+}
+
+#endif /* _COS_V_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/divide_dv.h newlib-1.15.0/newlib/libm/machine/spu/headers/divide_dv.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/divide_dv.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/divide_dv.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,152 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _DIVIDE_DV_H_
+#define _DIVIDE_DV_H_	1
+
+/*
+ * FUNCTION
+ * 	vector double _divide_dv(vector double a, vector double b)
+ * 
+ * DESCRIPTION
+ * 	_divide_dv divides the vector dividend <a> by the vector divisor <b> and 
+ *      returns the resulting vector quotient. 
+ */
+
+#ifdef __SPU__
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+
+static __inline vector double _divide_dv(vector double a, vector double b)
+{
+  /* This function has been designed to provide a
+   * full function operation that presisely computes
+   * the quotient for the entire range of extended
+   * single precision inputs <a> and <b>. This includes:
+   *
+   * 1) Computing the quotient to full single precision
+   *    floating point accuracy.
+   * 2) Round the result consistently with the rounding
+   *    mode of the processor - truncated toward zero.
+   * 3) Underflow and overflow results are clamped to
+   *    Smin and Smax and flagged with the appropriate
+   *    UNF or OVF exception in the FPSCR.
+   * 4) Divide By Zero (DBZ) exception is produced when
+   *    the divisor <b> has a zero exponent. A quotient
+   *    of correctly signed Smax is produced.
+   * 5) Denorm/zero divided by a denorm/zero generates 
+   *    undefined results.
+   * 6) Resulting denorm quotients will be coerced to +0.
+   */
+  vec_float4 onef = VEC_SPLAT_F32(1.0f);
+  vec_float4 inv_bf, mant_bf;
+  vec_double2 mant_a, mant_b, inv_b, q0, q1, q2, mult;
+  vec_double2 one = VEC_SPLAT_F64(1.0);
+  vec_uint4 exp, exp_a, exp_b, overflow, underflow, b_gt_a;
+  vec_uint4 exp_mask = VEC_LITERAL(vec_uint4, 0x7FF00000, 0, 0x7FF00000, 0);
+  vec_uint4 abs_a, abs_b;
+  vec_uint4 sign_mask = VEC_LITERAL(vec_uint4, 0x80000000, 0, 0x80000000, 0);
+
+  /* For computing the quotient, force the divisor and 
+   * dividend into the range (1.0 <= 0 < 2.0).
+   */
+  mant_a = spu_sel(a, one, (vec_ullong2)exp_mask);
+  mant_b = spu_sel(b, one, (vec_ullong2)exp_mask);
+
+  mant_bf = spu_roundtf(mant_b);
+
+  /* Approximate the single reciprocal of b by using
+   * the single precision reciprocal estimate followed by one 
+   * single precision iteration of the Newton-Raphson.
+   */
+  inv_bf = spu_re(mant_bf);
+  inv_bf = spu_madd(spu_nmsub(mant_bf, inv_bf, onef), inv_bf, inv_bf);
+
+  /* Perform 2 more Newton-Raphson iterations in double precision.
+   */
+  inv_b = spu_extend(inv_bf);
+  inv_b = spu_madd(spu_nmsub(mant_b, inv_b, one), inv_b, inv_b);
+
+  q0 = spu_mul(mant_a, inv_b);
+  q1 = spu_madd(spu_nmsub(mant_b, q0, mant_a), inv_b, q0);
+
+  /* Compute the quotient's expected exponent. If the exponent
+   * is out of range, then force the resulting exponent to 0.
+   * (1023 with the bias). We correct for the out of range 
+   * values by computing a multiplier (mult) that will force the 
+   * result to the correct out of range value and set the 
+   * correct exception flag (UNF, OVF, or neither). The multiplier
+   * is also conditioned to generate correctly signed Smax if the 
+   * divisor b is a denorm or zero.
+   */
+  exp_a = spu_and((vec_uint4)a, exp_mask);
+  exp_b = spu_and((vec_uint4)b, exp_mask);
+
+  abs_a = spu_andc((vec_uint4)mant_a, sign_mask);
+  abs_b = spu_andc((vec_uint4)mant_b, sign_mask);
+
+  b_gt_a = spu_cmpgt(abs_b, abs_a);
+  b_gt_a = spu_or(b_gt_a, spu_and(spu_cmpeq(abs_b, abs_a),
+				  spu_rlqwbyte(b_gt_a, 4)));
+
+  exp = spu_add(spu_sub(spu_add(exp_a, (vec_uint4)one), exp_b), b_gt_a);
+
+  /* The default multiplier is 1.0. If an underflow is detected (ie, 
+   * either the dividend <a> is a denorm/zero, or the computed exponent is 
+   * less than or equal to a biased 0), force the multiplier to 0.0.
+   */
+  underflow = spu_cmpgt((vec_int4)exp, 0);
+  mult = spu_and(one, (vec_double2)underflow);
+  exp = spu_and(exp, underflow);
+
+  /* Force the multiplier to positive infinity (exp_mask) and the biased exponent 
+   * to 1023, if the divisor is denorm/zero or the computed biased exponent is 
+   * greater than 1023.
+   */
+  overflow = spu_or(spu_cmpeq(exp_b, 0), spu_cmpeq(spu_rlmask(exp, -30), 2));
+  exp = spu_sel(exp, (vec_uint4)one, overflow);
+
+  mult = spu_sel(mult, (vec_double2)exp_mask, (vec_ullong2)spu_rlmask(overflow, -1));
+  mult = spu_andc(mult, (vec_double2)spu_cmpeq(exp_a, 0));
+
+  /* Insert the exponent into the result and perform the
+   * final multiplication.
+   */
+  q2 = spu_sel(q1, (vec_double2)exp, (vec_ullong2)exp_mask);
+  q2 = spu_mul(q2, mult);
+
+  return (q2);
+}
+#endif /* __SPU__ */
+#endif /* _DIVIDE_DV_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/divide_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/divide_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/divide_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/divide_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,181 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _DIVIDE_V_H_
+#define _DIVIDE_V_H_	1
+
+#include <vec_literal.h>
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+/*
+ * FUNCTION
+ * 	vector float _divide_v(vector float dividend, vector float divisor)
+ * 
+ * DESCRIPTION
+ * 	_divide_v divides the vector dividend by the vector divisor and 
+ *      returns the resulting vector quotient.
+ */
+
+static __inline vector float _divide_v(vector float a, vector float b)
+{
+#ifdef __SPU__
+  /* This function has been designed to provide a
+   * full function operation that presisely computes
+   * the quotient for the entire range of extended
+   * single precision inputs <a> and <b>. This includes:
+   *
+   * 1) Computing the quotient to full single precision
+   *    floating point accuracy.
+   * 2) Round the result consistently with the rounding
+   *    mode of the processor - truncated toward zero.
+   * 3) Underflow and overflow results are clamped to
+   *    Smin and Smax and flagged with the appropriate
+   *    UNF or OVF exception in the FPSCR.
+   * 4) Divide By Zero (DBZ) exception is produced when
+   *    the divisor <b> has a zero exponent. A quotient
+   *    of correctly signed Smax is produced.
+   * 5) Denorm/zero divided by a denorm/zero generates 
+   *    a DBZ with the results undefined.
+   * 6) Resulting denorm quotients will be coerced to +0.
+   * 7) If a non-compliant IEEE result is produced, the
+   *    a DIFF exception is generated.
+   */
+#ifdef IEEE_ACCURATE_DIVIDE
+  vector float inv_b, err, q0, q1, q2;
+  vector float mult;
+  vector float mant_a, mant_b;
+  vector float one = VEC_SPLAT_F32(1.0f);
+  vector unsigned int exp, exp_a, exp_b, overflow;
+  vector unsigned int exp_mask = VEC_SPLAT_U32(0x7F800000);
+
+  /* If b has a zero exponent, then set the divide by zero
+   * (DBZ) exception flag. The estimate result is discarded.
+   * Note: This must be implemented as inline assembly. Otherwise
+   * the optimizer removes it.
+   */
+  (void)si_frest((qword)(b));
+  
+  /* For computing the quotient, force the divisor and 
+   * dividend into the range (1.0 <= 0 < 2.0).
+   */
+  mant_a = spu_sel(a, one, exp_mask);
+  mant_b = spu_sel(b, one, exp_mask);
+
+  /* Compute the quotient using reciprocal estimate
+   * followed by one iteration of the Newton-Raphson.
+   */
+  inv_b = spu_re(mant_b);
+  q0 = spu_mul(mant_a, inv_b);
+  q1 = spu_nmsub(mant_b, q0, mant_a);
+  q1 = spu_madd(inv_b, q1, q0);
+
+  /* Due to truncation error, the quotient result
+   * may be low by 1 ulp (unit of least position),
+   * Conditionally add one if the estimate is too
+   * small.
+   */
+  q2 = (vector float)spu_add((vector unsigned int)(q1), 1);
+  err = spu_nmsub(mant_b, q2, mant_a);
+  q2 = spu_sel(q1, q2, spu_cmpgt((vector signed int)err, -1));
+
+
+  /* Compute the quotient's expected exponent. If the exponent
+   * is out of range, then force the resulting exponent to 0.
+   * (127 with the bias). We correct for the out of range 
+   * values by computing a multiplier (mult) that will force the 
+   * result to the correct out of range value and set the 
+   * correct exception flag (UNF, OVF, or neither). The multiplier
+   * is also conditioned to generate correctly signed Smax if the 
+   * divisor b is a denorm or zero.
+   */
+  exp_a = spu_and((vector unsigned int)a, exp_mask);
+  exp_b = spu_and((vector unsigned int)b, exp_mask);
+  exp   = spu_add(spu_sub(spu_add(exp_a, (vector unsigned int)one), exp_b), spu_cmpabsgt(mant_b, mant_a));
+
+  /* The default multiplier is 1.0. If an underflow is detected (ie, 
+   * either the dividend <a> is a denorm/zero, or the computed exponent is 
+   * less than or equal to a biased 0), force the multiplier to 0.0.
+   */
+  mult = spu_and(one, (vector float)spu_cmpgt((vector signed int)exp, 0));
+
+  /* Force the multiplier to positive Smax (0x7FFFFFFF) and the biased exponent 
+   * to 127, if the divisor is denorm/zero or the computed biased exponent is 
+   * greater than 255.
+   */
+
+  overflow = spu_or(spu_cmpeq(exp_b, 0), spu_cmpeq(spu_rlmask(exp, -30), 2));
+  exp = spu_sel(exp, (vector unsigned int)one, overflow);
+
+  mult = spu_or(mult, (vector float)spu_rlmask(overflow, -1));
+  mult = spu_andc(mult, (vector float)spu_cmpeq(exp_a, 0));
+
+  /* Insert the exponent into the result and perform the
+   * final multiplication.
+   */
+  q2    = spu_sel(q2, (vector float)exp, exp_mask);
+  q2    = spu_mul(q2, mult);
+
+  return (q2);
+
+#else /* fast divide */
+  vector float x0, q0, q1, q2, err;
+
+  x0 = spu_re(b);
+  q0 = spu_mul(a, x0);
+  q1 = spu_nmsub(b, q0, a);
+  q1 = spu_madd(x0, q1, q0);
+
+  /* Conditionally bias the result by 1 ulp so that 
+   * even the fast solution preserves the identiy function
+   *  a = a / 1
+   */
+  q2 = (vec_float4)spu_add((vec_uint4)(q1), 1);
+  err = spu_nmsub(b, q2, a);
+  q2 = spu_sel(q1, q2, spu_cmpgt((vec_int4)err, -1));
+  return (q2);
+#endif	/* IEEE_ACCURATE_DIVIDE */
+
+#else	/* VMX */
+  vector float quotient;
+  vector float x0, q0;
+
+  x0 = vec_re(b);
+  q0 = vec_madd(a, x0, VEC_SPLAT_F32(0.0));
+  quotient = vec_nmsub(b, q0, a);
+  quotient = vec_madd(x0, quotient, q0);
+  return (quotient);
+#endif	/* __SPU__ */
+}
+
+#endif /* _DIVIDE_V_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/exp2f.h newlib-1.15.0/newlib/libm/machine/spu/headers/exp2f.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/exp2f.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/exp2f.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,128 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _EXP2F_H_
+#define _EXP2F_H_	1
+
+#ifndef M_LN2
+#define M_LN2	0.69314718055994530942	/* ln(2) */
+#endif /* M_LN2 */
+
+/*
+ * FUNCTION
+ *	float _exp2f(float x)
+ *
+ * DESCRIPTION
+ *	_exp2f computes 2 raised to the input x. Computation is 
+ *	performed by observing the 2^(a+b) = 2^a * 2^b.
+ *	We decompose x into a and b (above) by letting.
+ *	a = ceil(x), b = x - a; 
+ *
+ *	2^a is easilty computed by placing a into the exponent
+ *	or a floating point number whose mantissa is all zeros.
+ *
+ *	2^b is computed using the following polynomial approximation.
+ *	(C. Hastings, Jr, 1955).
+ *
+ *             __7__
+ *	       \
+ *		\ 
+ *	2^x =   /     Ci*x^i
+ *             /____
+ *              i=0
+ *
+ *	for x in the range 0.0 to 1.0
+ *
+ *	C0 =  1.0
+ *	C1 = -0.9999999995
+ *	C2 =  0.4999999206
+ *	C3 = -0.1666653019
+ *	C4 =  0.0416573475
+ *	C5 = -0.0083013598
+ *	C6 =  0.0013298820
+ *	C7 = -0.0001413161
+ *
+ */
+static __inline float _exp2f(float x)
+{
+  union {
+    float f;
+    unsigned int ui;
+  } bias, exp_int, exp_frac;
+  unsigned int overflow, underflow;
+  int ix;
+  float frac, frac2, frac4;
+  float hi, lo;
+
+  /* Break in the input x into two parts ceil(x), x - ceil(x).
+   */
+  bias.f = x;
+  bias.ui = ~(unsigned int)((signed)(bias.ui) >> 31) & 0x3F7FFFFF;
+  ix = (int)(x + bias.f);
+  frac = (float)ix - x;
+  frac *= (float)(M_LN2);
+
+  exp_int.ui  = (ix + 127) << 23;
+
+#ifdef __SPU__
+  overflow  = (ix > 128)  ? 0x7FFFFFFF : 0x0;
+#else
+  overflow  = (ix > 127)  ? 0x7F800000 : 0x0;
+#endif
+  underflow = (ix < -127) ? 0xFFFFFFFF : 0x0;
+
+  /* Instruction counts can be reduced if the polynomial was
+   * computed entirely from nested (dependent) fma's. However, 
+   * to reduce the number of pipeline stalls, the polygon is evaluated 
+   * in two halves (hi amd lo). 
+   */
+  frac2 = frac  * frac;
+  frac4 = frac2 * frac2;
+  hi = -0.0001413161f * frac + 0.0013298820f;
+  hi =             hi * frac - 0.0083013598f;
+  hi =             hi * frac + 0.0416573475f;
+  lo = -0.1666653019f * frac + 0.4999999206f;
+  lo =             lo * frac - 0.9999999995f;
+  lo =             lo * frac + 1.0f;
+  exp_frac.f =     hi * frac4 + lo;
+
+  ix += exp_frac.ui >> 23;
+  exp_frac.f *= exp_int.f;
+
+  exp_frac.ui = (exp_frac.ui | overflow) & ~underflow;
+
+  return (exp_frac.f);
+}
+
+#endif /* _EXP2F_H_ */
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/exp2.h newlib-1.15.0/newlib/libm/machine/spu/headers/exp2.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/exp2.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/exp2.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,53 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _EXP2_H_
+#define _EXP2_H_	1
+
+#include <spu_intrinsics.h>
+#include "exp2_v.h"
+
+/*
+ * FUNCTION
+ *	double _exp2(double x)
+ *
+ * DESCRIPTION
+ *	_exp2 computes 2 raised to the input x.
+ */
+
+static __inline double _exp2(double x)
+{
+  return (spu_extract(_exp2_v(spu_promote(x, 0)), 0));
+}
+
+#endif /* _EXP2_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/exp2_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/exp2_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/exp2_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/exp2_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,145 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _EXP2_V_H_
+#define _EXP2_V_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include <vec_literal.h>
+
+/*
+ * FUNCTION
+ *	vector double _exp2_v(vector double x)
+ *
+ * DESCRIPTION
+ *	_exp2_v computes 2 raised to the input x for each
+ *	of the double word elements of x. Computation is 
+ *	performed by observing the 2^(a+b) = 2^a * 2^b.
+ *	We decompose x into a and b (above) by letting.
+ *	a = ceil(x), b = x - a; 
+ *
+ *	2^a is easily computed by placing a into the exponent
+ *	or a floating point number whose mantissa is all zeros.
+ *
+ *	2^b is computed using the polynomial approximation.
+ *
+ *             __13_
+ *	       \
+ *	        \ 
+ *	2^x =   /     Ci*x^i
+ *             /____
+ *              i=0
+ *
+ *	for x in the range 0.0 to 1.0.
+ *
+ */
+
+
+#define EXP_C00    1.0
+#define EXP_C01    6.93147180559945286227e-01
+#define EXP_C02    2.40226506959100694072e-01
+#define EXP_C03    5.55041086648215761801e-02
+#define EXP_C04    9.61812910762847687873e-03
+#define EXP_C05    1.33335581464284411157e-03
+#define EXP_C06    1.54035303933816060656e-04
+#define EXP_C07    1.52527338040598376946e-05
+#define EXP_C08    1.32154867901443052734e-06
+#define EXP_C09    1.01780860092396959520e-07
+#define EXP_C10    7.05491162080112087744e-09
+#define EXP_C11    4.44553827187081007394e-10
+#define EXP_C12    2.56784359934881958182e-11
+#define EXP_C13    1.36914888539041240648e-12
+
+static __inline vector double _exp2_v(vector double vx) 
+{
+   vec_int4 ix, exp;
+   vec_uint4 overflow, underflow;
+   vec_float4 vxf;
+   vec_double2 p1, p2, x2, x4, x8;
+   vec_double2 vy, vxw, out_of_range;
+
+   /* Compute:  vxw = x - ceil(x)
+    */
+   vxw = spu_add(vx, VEC_SPLAT_F64(0.5));
+   vxf = spu_roundtf(vxw);
+   ix  = spu_convts(vxf, 0);
+   ix  = spu_add(ix, (vec_int4)spu_andc(spu_cmpgt(VEC_SPLAT_F32(0.0), vxf), spu_cmpeq(ix, VEC_SPLAT_S32(0x80000000))));
+   vxf = spu_convtf(ix, 0);
+   vxw = spu_sub(vx, spu_extend(vxf));
+
+   /* Detect overflow and underflow. If overflow, force the result
+    * to infinity (at the end).
+    */
+   exp = spu_shuffle(ix, ix, VEC_LITERAL(vec_uchar16, 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11));
+
+   overflow = spu_cmpgt(exp, 1023);
+   underflow = spu_cmpgt(exp, -1023);
+   out_of_range = (vec_double2)spu_and(overflow, VEC_LITERAL(vec_uint4, 0x7FF00000, 0, 0x7FF00000, 0));
+
+   /* Calculate the result by evaluating the 13th order polynomial.
+    * For efficiency, the polynomial is broken into two parts and
+    * evaluate then using nested 
+    *
+    *  result = (((((c13*x + c12)*x + c11)*x + c10)*x + c9)*x + c8)*x^8 +
+    *           ((((((c7*x + c6)*x + c5)*x + c4)*x + c3)*x + c2)*x + c1)*x + c0
+    */
+   p2 = spu_madd(VEC_SPLAT_F64(EXP_C07), vxw, VEC_SPLAT_F64(EXP_C06));
+   p1 = spu_madd(VEC_SPLAT_F64(EXP_C13), vxw, VEC_SPLAT_F64(EXP_C12));
+   x2 = spu_mul(vxw, vxw);
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(EXP_C05));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(EXP_C11));
+   x4 = spu_mul(x2, x2);
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(EXP_C04));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(EXP_C10));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(EXP_C03));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(EXP_C09));
+   x8 = spu_mul(x4, x4);
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(EXP_C02));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(EXP_C08));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(EXP_C01));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(EXP_C00));
+   vy = spu_madd(x8, p1, p2);
+
+   /*  Align the integer integer portion of x with the exponent.
+    */
+   ix = spu_sl(ix, VEC_LITERAL(vec_uint4, 20, 32, 20, 32));
+   vy = (vec_double2)spu_add((vec_int4)vy, ix);
+   
+   /* Select the result if not overflow or underflow. Otherwise select the 
+    * the out of range value.
+    */
+   return (spu_sel(vy, out_of_range, (vec_ullong2)spu_orc(overflow, underflow)));
+}
+
+#endif /* _EXP2_V_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/expf.h newlib-1.15.0/newlib/libm/machine/spu/headers/expf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/expf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/expf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,58 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _EXPF_H_
+#define _EXPF_H_		1
+
+#include "exp2f.h"
+
+#ifndef M_LOG2E
+#define M_LOG2E		1.4426950408889634074
+#endif /* M_LOG2E */
+
+/*
+ * FUNCTION
+ *	float _expf(float x)
+ *
+ * DESCRIPTION
+ *	_expf computes e raised to the input x. expf is 
+ *	computed using exp2f as e^x = 2^(log2(e)*x)
+ */
+
+static __inline float _expf(float x)
+{
+  return (_exp2f((float)(M_LOG2E) * x));
+}
+
+#endif /* _EXPF_H_ */
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/exp.h newlib-1.15.0/newlib/libm/machine/spu/headers/exp.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/exp.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/exp.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,58 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _EXP_H_
+#define _EXP_H_	1
+
+#include <spu_intrinsics.h>
+#include "exp2_v.h"
+
+#ifndef M_LOG2E
+#define M_LOG2E		1.4426950408889634074
+#endif /* M_LOG2E */
+
+
+/*
+ * FUNCTION
+ *	double _exp(double x)
+ *
+ * DESCRIPTION
+ *	_exp computes e raised to the input x.
+ */
+
+static __inline double _exp(double x)
+{
+  return (spu_extract(_exp2_v(spu_promote(x * M_LOG2E, 0)), 0));
+}
+
+#endif /* _EXP_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fabsf.h newlib-1.15.0/newlib/libm/machine/spu/headers/fabsf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fabsf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fabsf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,60 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _FABSF_H_
+#define _FABSF_H_	1
+
+/*
+ * FUNCTION
+ *	float _fabsf(float value)
+ *
+ * DESCRIPTION
+ *	The _fabsf routine returns the absolute value of the floating-point
+ *	input value "value".  This is accomplished by zeroing the most
+ *	 significant bit (ie, the sign	bit) of the floating-point value.
+ */
+
+static __inline float _fabsf(float value)
+{
+  union {
+    unsigned int ui;
+    float f;
+  } in;
+
+  in.f = value;
+  in.ui = (in.ui << 1) >> 1;
+
+  return (in.f);
+}
+#endif /* _FABSF_H_ */
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fabs.h newlib-1.15.0/newlib/libm/machine/spu/headers/fabs.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fabs.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fabs.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,65 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _FABS_H_
+#define _FABS_H_	1
+
+/*
+ * FUNCTION
+ *	double _fabs(double value)
+ *
+ * DESCRIPTION
+ *	The _fabsf routine returns the absolute value of the floating-point
+ *	input value "value".  This is accomplished by zeroing the most
+ *	 significant bit (ie, the sign	bit) of the floating-point value.
+ */
+
+#ifdef __SPU__
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+
+static __inline double _fabs(double x)
+{
+  vec_ullong2 vx;
+
+  vx = (vec_ullong2)spu_promote(x, 0);
+  vx = spu_andc(vx, VEC_SPLAT_U64(0x8000000000000000ULL));
+
+  return (spu_extract((vec_double2)vx, 0));
+}
+
+#endif /* __SPU__ */
+
+#endif /*  _FABS_H_ */
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fdimf.h newlib-1.15.0/newlib/libm/machine/spu/headers/fdimf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fdimf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fdimf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,59 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _FDIMF_H_
+#define _FDIMF_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+/* fdim - compute the positive difference of x and y.
+ */
+static __inline float _fdimf(float x, float y)
+{ 
+#ifdef __SPU__
+  vec_float4 vx, vy;
+
+  vx = spu_promote(x, 0);
+  vy = spu_promote(y, 0);
+
+  return (spu_extract(spu_and(spu_sub(vx, vy), (vec_float4)spu_cmpgt(vx, vy)), 0));
+#else /* !__SPU__ */
+
+  return ((x > y) ? (x - y) : 0.0f);
+
+#endif	/* __SPU__ */
+}
+
+
+#endif /* _FDIMF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fdim.h newlib-1.15.0/newlib/libm/machine/spu/headers/fdim.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fdim.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fdim.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,57 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _FDIM_H_
+#define _FDIM_H_	1
+
+#ifdef __SPU__
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* fdim - compute the positive difference of x and y.
+ */
+static __inline double _fdim(double x, double y)
+{
+  vec_double2 v;
+  vec_uint4 mask;
+
+  v = spu_promote(x - y, 0);
+  mask = (vec_uint4)spu_shuffle(v, v, VEC_SPLAT_U8(0));
+  v = spu_andc(v, (vec_double2)spu_rlmaska(mask, -31));
+
+  return (spu_extract(v, 0));
+}
+
+#endif /* __SPU__ */
+
+#endif /* _FDIM_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/feclearexcept.h newlib-1.15.0/newlib/libm/machine/spu/headers/feclearexcept.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/feclearexcept.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/feclearexcept.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,55 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FECLEAREXCEPT_H_
+#define _FECLEAREXCEPT_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <fefpscr.h>
+
+static __inline void _feclearexcept(int excepts)
+{
+  vec_uint4 fpscr, fpscr_mask;
+
+  fpscr = spu_mffpscr();
+  excepts = ~(excepts & FE_ALL_EXCEPT);
+  fpscr_mask = __unpack_fpscr((fenv_t) excepts);
+  fpscr = spu_and(fpscr, fpscr_mask);
+  spu_mtfpscr(fpscr);
+}
+
+#endif /* _FECLEAREXCEPT_H_ */
+
+#endif /* __SPU__  */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fefpscr.h newlib-1.15.0/newlib/libm/machine/spu/headers/fefpscr.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fefpscr.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fefpscr.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,79 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/*
+ * Functions to pack/unpack the 128 bit fpscr to/from the 32 bit fenv_t.
+ * The fpscr currently has 32 of 128 bits defined.
+ */
+
+#ifndef _FEFPSCR_H_
+#define _FEFPSCR_H_  1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+
+static __inline vec_uint4 __unpack_fpscr(fenv_t word)
+{
+  vec_uint4 fpscr;
+  vec_uchar16 splat = { 0, 1, 0, 1, 0, 1, 0, 1, 2, 3, 2, 3, 2, 3, 2, 3 };
+  vec_short8 rotm = { -12, -9, -3, 0, -10, -7, -3, 0 };
+  vec_uint4 mask = { 0x00000f07, 0x00003f07, 0x00003f07, 0x00000f07 };
+
+  fpscr = spu_promote (word, 0);
+  fpscr = spu_shuffle (fpscr, fpscr, splat);
+  /*
+   * The casts here are important, so we generate different code.
+   */
+  fpscr = (vec_uint4) spu_rlmask ((vec_short8) fpscr, rotm);
+  fpscr = (vec_uint4) spu_and ((vec_short8) fpscr, 0xff);
+  fpscr = spu_or (spu_rlmask(fpscr, -8), fpscr);
+  fpscr = spu_and (fpscr, mask);
+  return fpscr;
+}
+
+static __inline fenv_t __pack_fpscr(vec_uint4 fpscr)
+{
+  vec_uchar16 pat = { 0x80, 2, 0x80, 10, 0x80, 3, 0x80, 11,
+    0x80, 6, 0x80, 14, 0x80, 7, 0x80, 15 };
+  vec_ushort8 shl = { 12, 10, 9, 7, 3, 3, 0, 0 };
+  vec_uint4 mask = { 0x00000f07, 0x00003f07, 0x00003f07, 0x00000f07 };
+  vec_uint4 word;
+
+  word = spu_and (fpscr, mask);
+  word = spu_shuffle (word, word, pat);
+  word = (vec_uint4) spu_sl ((vec_short8) word, shl);
+  word = spu_orx (word);
+  return spu_extract (word, 0);
+}
+
+#endif
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fegetenv.h newlib-1.15.0/newlib/libm/machine/spu/headers/fegetenv.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fegetenv.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fegetenv.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FEGETENV_H_
+#define _FEGETENV_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <fefpscr.h>
+
+static __inline void _fegetenv(fenv_t *envp)
+{
+  vec_uint4 fpscr;
+
+  fpscr = spu_mffpscr();
+  *envp = __pack_fpscr(fpscr);
+}
+
+#endif /* _FEGETENV_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fegetexceptflag.h newlib-1.15.0/newlib/libm/machine/spu/headers/fegetexceptflag.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fegetexceptflag.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fegetexceptflag.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,52 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FEGETEXCEPTFLAG_H_
+#define _FEGETEXCEPTFLAG_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <fefpscr.h>
+
+static __inline void _fegetexceptflag(fexcept_t *flagp, int excepts)
+{
+  vec_uint4 fpscr;
+  
+  excepts &= FE_ALL_EXCEPT;
+  fpscr = spu_mffpscr();
+  *flagp = __pack_fpscr(fpscr) & excepts;
+}
+
+#endif /* _FEGETEXCEPTFLAG_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fegetround.h newlib-1.15.0/newlib/libm/machine/spu/headers/fegetround.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fegetround.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fegetround.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,49 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FEGETROUND_H_
+#define _FEGETROUND_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+
+#define FE_MASK_ROUND		(__FE_ROUND_ELE_0 | __FE_ROUND_ELE_1)
+
+static __inline int _fegetround()
+{
+	return (((spu_extract(spu_mffpscr(), 0) >> 8) & 0xf) | FE_MASK_ROUND);
+}
+
+#endif /* _FEGETROUND_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/feholdexcept.h newlib-1.15.0/newlib/libm/machine/spu/headers/feholdexcept.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/feholdexcept.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/feholdexcept.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,56 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FEHOLDEXCEPT_H_
+#define _FEHOLDEXCEPT_H_	1
+
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <fefpscr.h>
+
+static __inline int _feholdexcept(fenv_t *envp)
+{
+  vec_uint4 fpscr;
+  fenv_t env;
+
+  fpscr = spu_mffpscr();
+  *envp = __pack_fpscr(fpscr);
+  env = env & ~FE_ALL_EXCEPT;
+  spu_mtfpscr(__unpack_fpscr(env));
+  return (0);
+}
+
+#endif /* _FEHOLDEXCEPT_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/feraiseexcept.h newlib-1.15.0/newlib/libm/machine/spu/headers/feraiseexcept.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/feraiseexcept.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/feraiseexcept.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,54 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FERAISEEXCEPT_H_
+#define _FERAISEEXCEPT_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <fefpscr.h>
+
+static __inline void _feraiseexcept(int excepts)
+{
+  vec_uint4 fpscr, big_except;
+
+  fpscr = spu_mffpscr();
+  excepts = excepts & FE_ALL_EXCEPT;
+  big_except = __unpack_fpscr(excepts);
+  fpscr = spu_or(fpscr, big_except);
+  spu_mtfpscr(fpscr);
+}
+
+#endif /* _FERAISEEXCEPT_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fesetenv.h newlib-1.15.0/newlib/libm/machine/spu/headers/fesetenv.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fesetenv.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fesetenv.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FESETENV_H_
+#define _FESETENV_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <fefpscr.h>
+
+static __inline void _fesetenv(const fenv_t *envp)
+{
+  vec_uint4 fpscr;
+
+  fpscr = __unpack_fpscr(*envp);
+  spu_mtfpscr(fpscr);
+}
+
+#endif /* _FESETENV_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fesetexceptflag.h newlib-1.15.0/newlib/libm/machine/spu/headers/fesetexceptflag.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fesetexceptflag.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fesetexceptflag.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,65 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FESETEXCEPTFLAG_H_
+#define _FESETEXCEPTFLAG_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <fefpscr.h>
+
+static __inline void _fesetexceptflag(const fexcept_t *flagp, int excepts)
+{
+  vec_uint4 fpscr;
+  fenv_t mask, pack_fpscr;
+
+  fpscr = spu_mffpscr();
+
+  /*
+   * We could also use 128 bit and boolean ops, then we would unpack
+   * twice, do boolean operations and store. That is probably the same
+   * number of instructions as this (pack, boolean ops, unpack, store).
+   */
+
+  /*
+   * XXX would using spu_sel() help any?
+   */
+  pack_fpscr = __pack_fpscr(fpscr);
+  mask = excepts & FE_ALL_EXCEPT;
+  fpscr = __unpack_fpscr((pack_fpscr & ~mask) | (*flagp & mask));
+  spu_mtfpscr(fpscr);
+}
+
+#endif /* _FESETEXCEPTFLAG_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fesetround.h newlib-1.15.0/newlib/libm/machine/spu/headers/fesetround.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fesetround.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fesetround.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,106 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _FESETROUND_H_
+#define _FESETROUND_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <vec_literal.h>
+
+#define FE_MASK_ROUND		(__FE_ROUND_ELE_0 | __FE_ROUND_ELE_1)
+
+#define SMALL	(FE_MASK_ROUND - 1)
+#define LARGE	(FE_MASK_ROUND + \
+		 ((__FE_SPU_DOWNWARD << 2) | __FE_SPU_DOWNWARD) + 1)
+
+static __inline int _fesetround(int mode)
+{
+	unsigned int umode;
+	vec_uint4 const valid_ele0 =
+		{ FE_TONEAREST, FE_TOWARDZERO, FE_UPWARD, FE_DOWNWARD };
+	vec_uint4 const valid_ele1 =
+		{ FE_TONEAREST_1, FE_TOWARDZERO_1, FE_UPWARD_1, FE_DOWNWARD_1 };
+	vec_uint4 const too_large = { LARGE, LARGE, LARGE, LARGE };
+	vec_uchar16 const splat_ele0 =
+		{ 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3 };
+	vec_uint4 const clear_non_ele0 = { 0xffffffff, 0, 0, 0 };
+
+	vec_uint4 vec_mode;
+	vec_uint4 valid, fail;
+	vec_uint4 cur_fpscr, new_fpscr, mask_fpscr;
+
+	/*
+	 * There are 24 valid values, check for a range plus the other 8
+	 * rather than check for specific bit settings.
+	 *
+	 * These are all the valid values:
+	 *   0xf00 through 0xf0f (SMALL + 1 through LARGE - 1, 16 values)
+	 *   0xc00 0xc04 0xc08 0xc0c (in ele0)
+	 *   0x300 0x301 0x302 0x303 (in ele1)
+	 */
+	umode = mode;
+	vec_mode = spu_splats(umode);
+	valid = spu_cmpeq(vec_mode, valid_ele0);
+	valid = spu_or(valid, spu_cmpeq(vec_mode, valid_ele1));
+	valid = spu_or(valid, spu_cmpgt(vec_mode, SMALL));
+	valid = spu_and(valid, spu_cmpgt(too_large, vec_mode));
+
+	fail = spu_gather(valid);
+	fail = spu_cmpeq(fail, 0);
+	/*
+	 * set all elements of fail to the value of fail's element 0, so
+	 * we can select the current fpscr values on failure.
+	 */
+	fail = spu_shuffle(fail, fail, splat_ele0);
+
+	cur_fpscr = spu_mffpscr();
+	/*
+	 * We don't have to mask the round element selection out since it
+	 * is shifted out.
+	 */
+	new_fpscr = spu_promote(umode << 8, 0);
+	new_fpscr = spu_and(new_fpscr, clear_non_ele0);
+	/*
+	 * Use the element bits of the mode to set the mask.
+	 */
+	mask_fpscr = spu_promote((umode & FE_MASK_ROUND), 0);
+	new_fpscr = spu_sel(cur_fpscr, new_fpscr, mask_fpscr);
+	/*
+	 * Use the current fpscr value if the round mode was invalid
+	 */
+	new_fpscr = spu_sel(new_fpscr, cur_fpscr, fail);
+	spu_mtfpscr(new_fpscr);
+
+	return spu_extract(fail, 0);
+}
+#endif /* _FESETROUND_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fetestexcept.h newlib-1.15.0/newlib/libm/machine/spu/headers/fetestexcept.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fetestexcept.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fetestexcept.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,52 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FETESTEXCEPT_H_
+#define _FETESTEXCEPT_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <fefpscr.h>
+
+static __inline int _fetestexcept(int excepts)
+{
+  vec_uint4 fpscr;
+
+  excepts &= FE_ALL_EXCEPT;
+  fpscr = spu_mffpscr();
+  return (__pack_fpscr(fpscr) & excepts);
+}
+
+#endif /* _FETESTEXCEPT_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/feupdateenv.h newlib-1.15.0/newlib/libm/machine/spu/headers/feupdateenv.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/feupdateenv.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/feupdateenv.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,51 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FEUPDATEENV_H_
+#define _FEUPDATEENV_H_	1
+
+#include <spu_intrinsics.h>
+#include <fenv.h>
+#include <fefpscr.h>
+
+static __inline void _feupdateenv(const fenv_t *envp)
+{
+  vec_uint4 fpscr;
+
+  fpscr = __unpack_fpscr(*envp);
+  spu_mtfpscr(fpscr);
+}
+
+#endif /* _FEUPDATEENV_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/floorf.h newlib-1.15.0/newlib/libm/machine/spu/headers/floorf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/floorf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/floorf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,136 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _FLOORF_H_
+#define _FLOORF_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include <vec_literal.h>
+
+/*
+ * FUNCTION
+ *	float _floorf(float value)
+ *
+ * DESCRIPTION
+ *	The _floorf routine round the input value "value" downwards to the
+ *	nearest integer returning the result as a float. Two forms of the 
+ *	floor function are provided - full range and limited (integer) 
+ *	range. 
+ *
+ *	The full range form (default) provides floor computation on 
+ *	all IEEE floating point values. The floor of NANs remain NANs.
+ *	The floor of denorms results in zero.
+ *
+ *	The limited range form (selected by defining FLOOR_INTEGER_RANGE)
+ *	compute ths floor of all floating-point values in the 32-bit
+ *	signed integer range. Values outside this range get clamped.
+ */
+
+static __inline float _floorf(float value)
+{
+#ifdef __SPU__
+#ifdef FLOOR_INTEGER_RANGE
+  /* 32-BIT INTEGER DYNAMIC RANGE 
+   */
+  union {
+    float f;
+    signed int i;
+    unsigned int ui;
+  } bias;
+
+  bias.f = value;
+
+  /* If positive, bias the input value to truncate towards
+   * positive infinity, instead of zero.
+   */
+  bias.ui = (unsigned int)(bias.i >> 31) & 0x3F7FFFFF;
+  value -= bias.f;
+
+  /* Remove fraction bits by casting to an integer and back
+   * to a floating-point value.
+   */
+  return ((float)((int)value));
+
+#else /* !FLOOR_INTEGER_RANGE */
+  /* FULL FLOATING-POINT RANGE 
+   */
+  vec_int4 exp, shift;
+  vec_uint4 mask, frac_mask, addend, insert, pos;
+  vec_float4 in, out;
+
+  in = spu_promote(value, 0);
+
+  /* This function generates the following component
+   * based upon the inputs.
+   *
+   *   mask = bits of the input that need to be replaced.
+   *   insert = value of the bits that need to be replaced
+   *   addend = value to be added to perform function.
+   *
+   * These are applied as follows:.
+   *
+   *   out = ((in & mask) | insert) + addend
+   */
+  pos = spu_cmpgt((vec_int4)in, -1);
+  exp = spu_and(spu_rlmask((vec_int4)in, -23), 0xFF);
+
+  shift = spu_sub(127, exp);
+
+  frac_mask = spu_and(spu_rlmask(VEC_SPLAT_U32(0x7FFFFF), shift),
+		      spu_cmpgt((vec_int4)shift, -31));
+
+  mask = spu_orc(frac_mask, spu_cmpgt(exp, 126));
+
+  addend = spu_andc(spu_andc(spu_add(mask, 1), pos), spu_cmpeq(spu_and((vec_uint4)in, mask), 0));
+  
+  insert = spu_andc(spu_andc(VEC_SPLAT_U32(0xBF800000), pos), 
+		    spu_cmpgt((vec_uint4)spu_add(exp, -1), 126));
+
+  out = (vec_float4)spu_add(spu_sel((vec_uint4)in, insert, mask), addend);
+
+  return (spu_extract(out, 0));
+#endif /* FLOOR_INTEGER_RANGE */
+#else /* __SPU__ */
+  union {
+    vector float fv;
+    float f[4];
+  } in;
+
+  in.f[0] = value;
+  in.fv = vec_floor(in.fv);
+
+  return (in.f[0]);
+#endif /* __SPU__ */
+}
+#endif /* _FLOORF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/floor.h newlib-1.15.0/newlib/libm/machine/spu/headers/floor.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/floor.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/floor.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,96 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FLOOR_H_
+#define _FLOOR_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Round the input downwards to the nearest integer.
+ */
+static __inline double _floor(double x)
+{
+  vec_uchar16 swap_words = VEC_LITERAL(vec_uchar16, 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11);
+  vec_uchar16 splat_hi = VEC_LITERAL(vec_uchar16, 0,1,2,3,0,1,2,3, 8,9,10,11, 8,9,10,11);
+  vec_uint4 one = VEC_LITERAL(vec_uint4, 0, 1, 0, 1);
+  vec_int4 exp, shift;
+  vec_uint4 mask, mask_1, frac_mask, addend, insert, pos, equal0;
+  vec_ullong2 sign = VEC_SPLAT_U64(0x8000000000000000ULL);
+  vec_double2 in, in_hi, out;
+  vec_double2 minus_one = VEC_SPLAT_F64(-1.0);
+
+  in = spu_promote(x, 0);
+
+  /* This function generates the following component
+   * based upon the inputs.
+   *
+   *   mask = bits of the input that need to be replaced.
+   *   insert = value of the bits that need to be replaced
+   *   addend = value to be added to perform function.
+   *
+   * These are applied as follows:.
+   *
+   *   out = ((in & mask) | insert) + addend
+   */
+  in_hi = spu_shuffle(in, in, splat_hi);
+  pos = spu_cmpgt((vec_int4)in_hi, -1);
+  exp = spu_and(spu_rlmask((vec_int4)in_hi, -20), 0x7FF);
+  shift = spu_sub(VEC_LITERAL(vec_int4, 1023, 1043, 1023, 1043), exp);
+
+  /* clamp shift to the range 0 to -31.
+   */
+  shift = spu_sel(VEC_SPLAT_S32(-32), spu_andc(shift, (vec_int4)spu_cmpgt(shift, 0)), spu_cmpgt(shift, -32));
+
+  frac_mask = spu_rlmask(VEC_LITERAL(vec_uint4, 0xFFFFF, -1, 0xFFFFF, -1), shift);
+  mask = spu_orc(frac_mask, spu_cmpgt(exp, 0x3FE));
+
+  /* addend = ((in & mask) && (in >= 0)) ? mask+1 : 0
+   */
+  mask_1 = spu_addx(mask, one, spu_rlqwbyte(spu_genc(mask, one), 4));
+
+  equal0 = spu_cmpeq(spu_and((vec_uint4)in, mask), 0);
+  addend = spu_andc(spu_andc(mask_1, pos), spu_and(equal0, spu_shuffle(equal0, equal0, swap_words)));
+
+  insert = spu_andc(spu_andc((vec_uint4)minus_one, pos), 
+		    spu_cmpgt((vec_uint4)spu_add(exp, -1), 1022));
+
+  in = spu_sel(in, (vec_double2)insert, spu_andc((vec_ullong2)mask, sign));
+  out = (vec_double2)spu_addx((vec_uint4)in, addend, spu_rlqwbyte(spu_genc((vec_uint4)in, addend), 4));
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _FLOOR_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmaf.h newlib-1.15.0/newlib/libm/machine/spu/headers/fmaf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmaf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fmaf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,50 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _FMAF_H_
+#define _FMAF_H_		1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+
+static __inline float _fmaf(float x, float y, float z)
+{
+#ifdef __SPU__
+  return (spu_extract(spu_madd(spu_promote(x, 0), spu_promote(y, 0), spu_promote(z, 0)), 0)); 
+#else
+  return (x*y + z);
+#endif 
+}
+
+#endif /* _FMAF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fma.h newlib-1.15.0/newlib/libm/machine/spu/headers/fma.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fma.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fma.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,55 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifdef __SPU__
+
+#ifndef _FMA_H_
+#define _FMA_H_		1
+
+#include <spu_intrinsics.h>
+
+static __inline double _fma(double x, double y, double z)
+{
+  vec_double2 vx, vy, vz, vout;;
+
+  vx = spu_promote(x, 0);
+  vy = spu_promote(y, 0);
+  vz = spu_promote(z, 0);
+
+  vout = spu_madd(vx, vy, vz);
+
+  return (spu_extract(vout, 0));
+}
+
+#endif /* _FMA_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmaxf.h newlib-1.15.0/newlib/libm/machine/spu/headers/fmaxf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmaxf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fmaxf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,57 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _FMAXF_H_
+#define _FMAXF_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+/* Return the maximum numeric value of their arguments. 
+ */
+
+static __inline float _fmaxf(float x, float y)
+{
+#ifdef __SPU__
+  vec_float4 vx, vy;
+
+  vx = spu_promote(x, 0);
+  vy = spu_promote(y, 0);
+
+  return (spu_extract(spu_sel(vx, vy, spu_cmpgt(vy, vx)), 0));
+#else
+  return ((x > y) ? x : y);
+#endif
+}
+
+#endif /* _FMAXF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmax.h newlib-1.15.0/newlib/libm/machine/spu/headers/fmax.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmax.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fmax.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,78 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FMAX_H_
+#define _FMAX_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Return the maximum numeric value of their arguments. If one argument
+ * is a NaN, fmax returns the other value.  If both are NaNs, then a NaN
+ * is returned.
+ *
+ * Notes:
+ * 1) Double precision denorms equate to zero so two denorms compare
+ *    equal thereby making the following true for two denorm inputs
+ *		fmax(a, b) != fmax(b, a);
+ */
+static __inline double _fmax(double x, double y)
+{
+  vec_uint4 nan_x, selector, abs_x, gt, eq;
+  vec_uint4 sign = VEC_LITERAL(vec_uint4, 0x80000000, 0, 0x80000000, 0);
+  vec_uint4 infinity = VEC_LITERAL(vec_uint4, 0x7FF00000, 0, 0x7FF00000, 0);
+  vec_double2 vx, vy, diff, max;
+
+  vx = spu_promote(x, 0);
+  vy = spu_promote(y, 0);
+
+  /* If x is a NaN, then select y as max
+   */
+  abs_x = spu_andc((vec_uint4)vx, sign);
+  gt = spu_cmpgt(abs_x, infinity);
+  eq = spu_cmpeq(abs_x, infinity);
+
+  nan_x = spu_or(gt, spu_and(eq, spu_rlqwbyte(gt, 4)));
+
+  diff = spu_sub(vx, vy);
+  selector = spu_orc(nan_x, spu_cmpgt((vec_int4)diff, -1));
+  selector = spu_maskw(spu_extract(selector, 0));
+
+  max = spu_sel(vx, vy, (vec_ullong2)selector);
+
+  return (spu_extract(max, 0));
+}
+
+#endif /* _FMAX_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fminf.h newlib-1.15.0/newlib/libm/machine/spu/headers/fminf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fminf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fminf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,56 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _FMINF_H_
+#define _FMINF_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+/* Return the minimum numeric value of their arguments.
+ */
+static __inline float _fminf(float x, float y)
+{
+#ifdef __SPU__
+  vec_float4 vx, vy;
+
+  vx = spu_promote(x, 0);
+  vy = spu_promote(y, 0);
+
+  return (spu_extract(spu_sel(vx, vy, spu_cmpgt(vx, vy)), 0));
+#else
+  return ((x > y) ? y : x);
+#endif
+}
+
+#endif /* _FMINF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmin.h newlib-1.15.0/newlib/libm/machine/spu/headers/fmin.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmin.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fmin.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,79 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FMIN_H_
+#define _FMIN_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Return the minimum numeric value of their arguments. If one argument
+ * is a NaN, fmin returns the other value. If both are NaNs, then a NaN
+ * is returned.
+ *
+ * Notes:
+ * 1) Double precision denorms equate to zero so two denorms compare
+ *    equal thereby making the following true for two denorm inputs
+ *		fmin(a, b) != fmin(b, a);
+ */
+
+static __inline double _fmin(double x, double y)
+{
+  vec_uint4 nan_x, selector, abs_x, gt, eq;
+  vec_uint4 sign = VEC_LITERAL(vec_uint4, 0x80000000, 0, 0x80000000, 0);
+  vec_uint4 infinity = VEC_LITERAL(vec_uint4, 0x7FF00000, 0, 0x7FF00000, 0);
+  vec_double2 vx, vy, diff, min;
+
+  vx = spu_promote(x, 0);
+  vy = spu_promote(y, 0);
+
+  /* If x is a NaN, then select y as min
+   */
+  abs_x = spu_andc((vec_uint4)vx, sign);
+  gt = spu_cmpgt(abs_x, infinity);
+  eq = spu_cmpeq(abs_x, infinity);
+
+  nan_x = spu_or(gt, spu_and(eq, spu_rlqwbyte(gt, 4)));
+
+  diff = spu_sub(vy, vx);
+  selector = spu_orc(nan_x, spu_cmpgt((vec_int4)diff, -1));
+  selector = spu_maskw(spu_extract(selector, 0));
+
+  min = spu_sel(vx, vy, (vec_ullong2)selector);
+
+  return (spu_extract(min, 0));
+}
+
+#endif /* _FMIN_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmodf.h newlib-1.15.0/newlib/libm/machine/spu/headers/fmodf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmodf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fmodf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,163 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FMODF_H_
+#define _FMODF_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include <vec_literal.h>
+
+#include "fabsf.h"
+
+/*
+ * FUNCTION
+ *	float _fmodf(float x, float y)
+ *
+ * DESCRIPTION
+ *	The _fmodf subroutine computes the remainder of
+ *	dividing x by y. The return value is x - n*y, where n is
+ *	the quotient of x/y, rounded towards zero.
+ *
+ *	The full range form (default) provides fmod computation on 
+ *	all IEEE floating point values (excluding floating overflow
+ *	or underflow).
+ *
+ *	The limited range form (selected by defining FMODF_INTEGER_RANGE)
+ *	compute fmod of all floating-point x/y values in the 32-bit
+ *	signed integer range. Values outside this range get clamped.
+ */
+
+static __inline float _fmodf(float x, float y)
+{
+#ifdef FMODF_INTEGER_RANGE
+  /* 32-BIT INTEGER DYNAMIC RANGE 
+   */
+  float abs_y;
+  float quotient;
+
+  abs_y = _fabsf(y);
+  quotient = x/abs_y;
+
+  return (abs_y*(quotient - ((float)((int)quotient))));
+
+#else /* !FMODF_INTEGER_RANGE */
+  /* FULL FLOATING-POINT RANGE 
+   */
+  int n;
+  vec_uint4 vx, vy, z;
+  vec_uint4 abs_x, abs_y;
+  vec_uint4 exp_x, exp_y;
+  vec_uint4 zero_x, zero_y;
+  vec_uint4 logb_x, logb_y;
+  vec_uint4 mant_x, mant_y;
+  vec_uint4 result, result0, resultx, cnt, sign;
+  vec_uint4 sign_mask = VEC_SPLAT_U32(0x80000000);
+  vec_uint4 implied_1 = VEC_SPLAT_U32(0x00800000);
+  vec_uint4 mant_mask = VEC_SPLAT_U32(0x007FFFFF);
+
+  vx = (vec_uint4)spu_promote(x, 0);
+  vy = (vec_uint4)spu_promote(y, 0);
+
+  abs_x = spu_andc(vx, sign_mask);
+  abs_y = spu_andc(vy, sign_mask);
+
+  sign = spu_and(vx, sign_mask);
+
+  /* Determine ilogb of abs_x and abs_y and 
+   * extract the mantissas (mant_x, mant_y)
+   */
+  exp_x  = spu_rlmask(abs_x, -23);
+  exp_y  = spu_rlmask(abs_y, -23);
+
+  resultx = spu_cmpgt(abs_y, abs_x);
+
+  zero_x = spu_cmpeq(exp_x, 0);
+  zero_y = spu_cmpeq(exp_y, 0);
+
+  logb_x = spu_add(exp_x, -127);
+  logb_y = spu_add(exp_y, -127);
+
+  mant_x = spu_andc(spu_sel(implied_1, abs_x, mant_mask), zero_x);
+  mant_y = spu_andc(spu_sel(implied_1, abs_y, mant_mask), zero_y);
+
+  /* Compute fixed point fmod of mant_x and mant_y. Set the flag,
+   * result0, to all ones if we detect that the final result is 
+   * ever 0.
+   */
+  result0 = spu_or(zero_x, zero_y);
+
+  n = spu_extract(spu_sub(logb_x, logb_y), 0);
+
+  while (n-- > 0) {
+    z = spu_sub(mant_x, mant_y);
+
+    result0 = spu_or(spu_cmpeq(z, 0), result0);
+    
+    mant_x = spu_sel(spu_add(mant_x, mant_x),
+		     spu_add(z, z),
+		     spu_cmpgt((vec_int4)z, -1));
+  }
+
+  z = spu_sub(mant_x, mant_y);
+  mant_x = spu_sel(mant_x, z, spu_cmpgt((vec_int4)z, -1));
+
+  result0 = spu_or(spu_cmpeq(mant_x, 0), result0);
+
+  /* Convert the result back to floating point and restore
+   * the sign. If we flagged the result to be zero (result0),
+   * zero it. If we flagged the result to equal its input x,
+   * (resultx) then return x.
+   */
+  cnt = spu_add(spu_cntlz(mant_x), -8);
+
+  mant_x = spu_rl(spu_andc(mant_x, implied_1), (vec_int4)cnt);
+
+  exp_y = spu_sub(exp_y, cnt);
+  result0 = spu_orc(result0, spu_cmpgt((vec_int4)exp_y, 0));	/* zero denorm results */
+  exp_y = spu_rl(exp_y, 23);
+
+
+  result = spu_sel(exp_y, spu_or(sign, mant_x), VEC_SPLAT_U32(0x807FFFFF));
+
+  result = spu_sel(spu_andc(result, spu_rlmask(result0, -1)),
+		   vx, resultx);
+  
+  return (spu_extract((vec_float4)result, 0));
+#endif /* FMODF_INTEGER_RANGE */
+}
+#endif /* _FMODF_H_ */
+
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmod.h newlib-1.15.0/newlib/libm/machine/spu/headers/fmod.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/fmod.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/fmod.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,154 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+#ifndef _FMOD_H_
+#define _FMOD_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* This implementation returns zero if y is a denorm or zero.
+ */
+static __inline double _fmod(double x, double y)
+{
+  int n, shift;
+  vec_uchar16 swap_words = VEC_LITERAL(vec_uchar16, 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11);
+  vec_uchar16 propagate = VEC_LITERAL(vec_uchar16, 4,5,6,7, 192,192,192,192, 12,13,14,15, 192,192,192,192);
+  vec_uchar16 splat_hi = VEC_LITERAL(vec_uchar16, 0,1,2,3,0,1,2,3, 8,9,10,11, 8,9,10,11);
+  vec_uint4 vx, vy, z;
+  vec_uint4 x_hi, y_hi;
+  vec_uint4 abs_x, abs_y;
+  vec_uint4 exp_x, exp_y;
+  vec_uint4 zero_x, zero_y;
+  vec_uint4 logb_x, logb_y;
+  vec_uint4 mant_x, mant_y;
+  vec_uint4 normal, norm, denorm;
+  vec_uint4 result, result0, resultx, cnt, sign, borrow;
+  vec_uint4 lsb       = (vec_uint4)(VEC_SPLAT_U64(0x0000000000000001ULL));
+  vec_uint4 sign_mask = (vec_uint4)(VEC_SPLAT_U64(0x8000000000000000ULL));
+  vec_uint4 implied_1 = (vec_uint4)(VEC_SPLAT_U64(0x0010000000000000ULL));
+  vec_uint4 mant_mask = (vec_uint4)(VEC_SPLAT_U64(0x000FFFFFFFFFFFFFULL));
+
+  vx = (vec_uint4)spu_promote(x, 0);
+  vy = (vec_uint4)spu_promote(y, 0);
+
+  abs_x = spu_andc(vx, sign_mask);
+  abs_y = spu_andc(vy, sign_mask);
+
+  sign = spu_and(vx, sign_mask);
+
+  x_hi = spu_shuffle(abs_x, abs_x, splat_hi);
+  y_hi = spu_shuffle(abs_y, abs_y, splat_hi);
+
+  /* Determine ilogb of abs_x and abs_y and 
+   * extract the mantissas (mant_x, mant_y)
+   */
+  exp_x  = spu_rlmask(x_hi, -20);
+  exp_y  = spu_rlmask(y_hi, -20);
+
+  resultx = spu_cmpgt(y_hi, x_hi);
+
+  zero_x = spu_cmpeq(exp_x, 0);
+  zero_y = spu_cmpeq(exp_y, 0);
+
+  logb_x = spu_add(exp_x, -1023);
+  logb_y = spu_add(exp_y, -1023);
+
+  mant_x = spu_andc(spu_sel(implied_1, abs_x, mant_mask), zero_x);
+  mant_y = spu_andc(spu_sel(implied_1, abs_y, mant_mask), zero_y);
+
+  /* Compute fixed point fmod of mant_x and mant_y. Set the flag,
+   * result0, to all ones if we detect that the final result is 
+   * ever 0.
+   */
+  result0 = spu_or(zero_x, zero_y);
+
+  n = spu_extract(spu_sub(logb_x, logb_y), 0);
+
+  while (n-- > 0) {
+    borrow = spu_genb(mant_x, mant_y);
+    borrow = spu_shuffle(borrow, borrow, propagate);
+    z = spu_subx(mant_x, mant_y, borrow);
+
+    result0 = spu_or(spu_cmpeq(spu_or(z, spu_shuffle(z, z, swap_words)), 0), result0);
+    
+    mant_x = spu_sel(spu_slqw(mant_x, 1), spu_andc(spu_slqw(z, 1), lsb), spu_cmpgt((vec_int4)spu_shuffle(z, z, splat_hi), -1));
+  }
+
+  borrow = spu_genb(mant_x, mant_y);
+  borrow = spu_shuffle(borrow, borrow, propagate);
+  z = spu_subx(mant_x, mant_y, borrow);
+
+  mant_x = spu_sel(mant_x, z, spu_cmpgt((vec_int4)spu_shuffle(z, z, splat_hi), -1));
+  mant_x = spu_andc(mant_x, VEC_LITERAL(vec_uint4, 0,0,-1,-1));
+
+  result0 = spu_or(spu_cmpeq(spu_or(mant_x, spu_shuffle(mant_x, mant_x, swap_words)), 0), result0);
+
+  /* Convert the result back to floating point and restore
+   * the sign. If we flagged the result to be zero (result0),
+   * zero it. If we flagged the result to equal its input x,
+   * (resultx) then return x.
+   *
+   * Double precision generates a denorm for an output.
+   */
+  cnt = spu_cntlz(mant_x);
+  cnt = spu_add(cnt, spu_and(spu_rlqwbyte(cnt, 4), spu_cmpeq(cnt, 32)));
+  cnt = spu_add(spu_shuffle(cnt, cnt, splat_hi), -11);
+
+  shift = spu_extract(exp_y, 0) - 1;
+  denorm = spu_slqwbytebc(spu_slqw(mant_x, shift), shift);
+
+  exp_y = spu_sub(exp_y, cnt);
+
+  normal = spu_cmpgt((vec_int4)exp_y, 0);
+
+  /* Normalize normal results, denormalize denorm results.
+   */
+  shift = spu_extract(cnt, 0);			    
+  norm = spu_slqwbytebc(spu_slqw(spu_andc(mant_x, VEC_LITERAL(vec_uint4, 0x00100000, 0, -1, -1)), shift), shift);
+
+  mant_x = spu_sel(denorm, norm, normal);
+
+  exp_y = spu_and(spu_rl(exp_y, 20), normal);
+
+  result = spu_sel(exp_y, spu_or(sign, mant_x), VEC_LITERAL(vec_uint4, 0x800FFFFF, -1, 0x800FFFFF, -1));
+
+  result = spu_sel(spu_andc(result, spu_rlmask(result0, -1)),
+		   vx, resultx);
+
+  return (spu_extract((vec_double2)result, 0));
+}
+
+#endif /* _FMOD_H_ */
+#endif /* __SPU__ */
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/frexpf.h newlib-1.15.0/newlib/libm/machine/spu/headers/frexpf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/frexpf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/frexpf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,73 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FREXPF_H_
+#define _FREXPF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Return the normalized fraction and exponent to the number x.
+ */
+static __inline float _frexpf(float x, int *pexp)
+{
+  vec_int4 exp;
+  vec_uint4 mask;
+  vec_uint4 exp_mask = VEC_SPLAT_U32(0x7F800000);
+  vec_float4 half = VEC_SPLAT_F32(0.5f);
+  vec_float4 in, mant;
+
+  in = spu_promote(x, 0);
+
+  /* Normalize the mantissa (fraction part).
+   */
+  mant = spu_sel(in, half, exp_mask);
+
+  /* Zero the mantissa if the input is a denorm or zero
+   */
+  exp = spu_and(spu_rlmask((vec_int4)in, -23), 0xFF);
+  mask = spu_cmpeq(exp, 0);
+  mant = spu_andc(mant, (vec_float4)mask);
+
+  /* Zero exponent if zero or denorm input. Otherwise, compute
+   * exponent by removing the bias.
+   */
+  exp = spu_andc(spu_add(exp, -126), (vec_int4)mask);
+  *pexp = spu_extract(exp, 0);		
+		
+  return (spu_extract(mant, 0));
+}
+
+#endif /* _FREXPF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/frexp.h newlib-1.15.0/newlib/libm/machine/spu/headers/frexp.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/frexp.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/frexp.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,80 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _FREXP_H_
+#define _FREXP_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Return the normalized fraction and exponent to the number x.
+ * Double precision denorms treated as zero and return a 0 
+ * fraction and 0 exponent. The results are undefined for infinities
+ * and NaNs (double precision only).
+ */
+static __inline double _frexp(double x, int *pexp)
+{
+  vec_int4 exp;
+  vec_uint4 denorm, mask;
+  vec_double2 in, mant;
+  vec_double2 half = VEC_SPLAT_F64(0.5);
+  vec_ullong2 exp_mask = VEC_SPLAT_U64(0x7FF0000000000000ULL);
+
+  in = spu_promote(x, 0);
+
+  /* Normalize the mantissa (fraction part).
+   */
+  mant = spu_sel(in, half, exp_mask);
+
+  /* Zero the mantissa if the input is a denorm or zero
+   */
+  exp = spu_and(spu_rlmask((vec_int4)in, -20), 0x7FF);
+  denorm = spu_cmpeq(exp, 0);
+  mask = spu_shuffle(denorm, denorm, VEC_SPLAT_U8(0));
+  mant = spu_andc(mant, (vec_double2)mask);
+
+  /* Zero exponent if zero or denorm input. Otherwise, compute
+   * exponent by removing the bias.
+   */
+  exp = spu_andc(spu_add(exp, -1022), (vec_int4)mask);
+
+  *pexp = spu_extract(exp, 0);		
+		
+  return (spu_extract(mant, 0));
+}
+
+#endif /* _FREXPF_H_ */
+#endif /* __SPU__ */
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ilogbf.h newlib-1.15.0/newlib/libm/machine/spu/headers/ilogbf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ilogbf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/ilogbf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,57 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _ILOGBF_H_
+#define _ILOGBF_H_	1
+
+#include <spu_intrinsics.h>
+#include <math.h>
+#include <vec_literal.h>
+
+/* Single precision floats do not support infinities and NANs, and
+ * denorms are treated as zero.
+ */
+static __inline int _ilogbf(float x)
+{
+  vec_uint4 v, exp;
+
+  v = (vec_uint4)spu_promote(x, 0);
+  exp = spu_and(spu_rlmask(v, -23), 0xFF);
+  exp = spu_sel(spu_add(exp, -127), VEC_SPLAT_U32(FP_ILOGB0), spu_cmpeq(exp, 0));
+		
+  return (spu_extract((vec_int4)(exp), 0));
+}
+
+#endif /* _ILOGBF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ilogb.h newlib-1.15.0/newlib/libm/machine/spu/headers/ilogb.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ilogb.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/ilogb.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,89 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _ILOGB_H_
+#define _ILOGB_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+#include <math.h>
+
+/* ilogb returns the signed exponent in the floating-point
+ * input. Special numbers include:
+ *     Input     Output
+ *     =====    =====================
+ * 	INF     FP_ILOGBNAN (INT_MAX)
+ * 	NAN     FP_ILOGBNAN (INT_MAX)
+ *     denorm   exponent - leading zeros
+ * 	 0      FP_ILOGB0 (INT_MIN)
+ *      else	signed exponent
+ */
+
+static __inline int _ilogb(double x)
+{
+  vec_uint4 v, exp, exp_0, mant, mask, count;
+  vec_uint4 flg_exp_0, flg_exp_max;
+
+  mask = VEC_SPLAT_U32(0x7FF);
+
+  /* Extract the exponent and mantissa.
+   */
+  v = (vec_uint4)spu_promote(x, 0);
+
+  exp = spu_and(spu_rlmask(v, -20), mask);
+
+  mant = spu_and(v, VEC_LITERAL(vec_uint4, 0x000FFFFF, 0xFFFFFFFF, 0, 0));
+
+  /* Count the leading zeros in the mantissa for denorm handling
+   * and zero identification.
+   */
+  count = spu_cntlz(mant);
+  count = spu_add(count, spu_and(spu_rlqwbyte(count, 4), spu_cmpeq(count, 32)));
+  
+  flg_exp_0 = spu_cmpeq(exp, 0);
+  flg_exp_max = spu_cmpeq(exp, mask);
+
+  exp = spu_add(exp, -1023);
+
+  /* Determine the exponent if the input is a denorm or zero.
+   */
+  exp_0 = spu_sel(spu_sub(spu_add(exp, 12), count), VEC_SPLAT_U32(FP_ILOGB0), spu_cmpeq(count, 64));
+
+  exp = spu_sel(spu_sel(exp, VEC_SPLAT_U32(FP_ILOGBNAN), flg_exp_max), exp_0, flg_exp_0);
+
+  return (spu_extract((vec_int4)(exp), 0));
+}
+
+#endif /* _ILOGB_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ldexpf.h newlib-1.15.0/newlib/libm/machine/spu/headers/ldexpf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ldexpf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/ldexpf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,81 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LDEXPF_H_
+#define _LDEXPF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* ldexpf computes x * 2^exp. This function is computed without
+ * the assistence of any floating point operations and as such does
+ * not set any floating point exceptions.
+ */
+static __inline float _ldexpf(float x, int exp)
+{
+  vec_int4 x_exp;
+  vec_uint4 zero, overflow;
+  vec_uint4 exp_mask = VEC_SPLAT_U32(0x7F800000);
+  vec_float4 in, out;
+
+  in = spu_promote(x, 0);
+
+  /* Extract exponent from x. If the exponent is 0, then
+   * x is either 0 or a denorm and x*2^exp is a zero.
+   */
+  x_exp = spu_and(spu_rlmask((vec_int4)in, -23), 0xFF);
+
+  zero = spu_cmpeq(x_exp, 0);
+
+  /* Compute the expected exponent and determine if the 
+   * result is within range.
+   */
+  x_exp = spu_add(spu_promote(exp, 0), x_exp);
+
+  zero = spu_orc(zero, spu_cmpgt(x_exp, 0));
+  
+  overflow = spu_rlmask(spu_cmpgt(x_exp, 255), -1);
+
+  /* Merge the expect exponent with x's mantissa. Zero the
+   * result if underflow and force to max if overflow.
+   */
+  out = spu_sel(in, (vec_float4)spu_rl(x_exp, 23), exp_mask);
+  out = spu_andc(out, (vec_float4)zero);
+  out = spu_or(out, (vec_float4)overflow);
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _LDEXPF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ldexp.h newlib-1.15.0/newlib/libm/machine/spu/headers/ldexp.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/ldexp.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/ldexp.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,86 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LDEXP_H_
+#define _LDEXP_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* ldexp computes x * 2^exp. This function variant computes the result
+ * and handles overflow, underflow, and denorms by breaking the problem
+ * into:
+ *      exp = MAX(exp, -2044)
+ *      exp = MIN(exp,  2046)
+ *      e1 = exp / 2
+ *      e2 = exp - e1;
+ *	x * 2^e1 * 2^e2
+ */
+static __inline double _ldexp(double x, int exp)
+{
+  vec_int4 e, e1, e2;
+  vec_int4 min = VEC_SPLAT_S32(-2044);
+  vec_int4 max = VEC_SPLAT_S32(2046);
+  vec_uint4 cmp_min, cmp_max;
+  vec_uint4 shift = VEC_LITERAL(vec_uint4, 20, 32, 20, 32);
+  vec_double2 f1, f2;
+  vec_double2 in, out;
+
+  in = spu_promote(x, 0);
+  e = spu_promote(exp, 0);
+
+  /* Clamp the specified exponent to the range -2044 to 2046.
+   */
+  cmp_min = spu_cmpgt(e, min);
+  cmp_max = spu_cmpgt(e, max);
+  e = spu_sel(min, e, cmp_min);
+  e = spu_sel(e, max, cmp_max);
+
+  /* Generate the factors f1 = 2^e1 and f2 = 2^e2
+   */
+  e1 = spu_rlmaska(e, -1);
+  e2 = spu_sub(e, e1);
+
+  f1 = (vec_double2)spu_sl(spu_add(e1, 1023), shift);
+  f2 = (vec_double2)spu_sl(spu_add(e2, 1023), shift);
+
+  /* Compute the product x * 2^e1 * 2^e2
+   */
+  out = spu_mul(spu_mul(in, f1), f2);
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _LDEXP_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/llrintf.h newlib-1.15.0/newlib/libm/machine/spu/headers/llrintf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/llrintf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/llrintf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,85 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LLRINTF_H_
+#define _LLRINTF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+
+static __inline long long int _llrintf(float x)
+{
+  int shift;
+  vec_int4 exp;
+  vec_uint4 mant, sign, borrow;
+  vec_float4 in;
+
+  in = spu_promote(x, 0);
+
+  /* Place mantissa bits (including implied most signficant
+   * bit) into the most significant bits of element 3. Elements
+   * 0, 1, and 2 are zeroed.
+   */
+  mant = spu_sel(spu_rlmaskqwbyte((vec_uint4)in, -11), 
+		 VEC_SPLAT_U32(0x80000000),
+		 VEC_LITERAL(vec_uint4, 0,0,0xFF,0x800000FF));
+
+  /* Determine how many bits to shift the mantissa to correctly
+   * align it into long long element 0.
+   */
+  exp = spu_and(spu_rlmask((vec_int4)in, -23), 0xFF);
+  shift = spu_extract(spu_add(exp, -94), 0);
+
+  /* Algn mantissa bits
+   */
+  mant = spu_slqwbytebc(spu_slqw(mant, shift), shift);
+
+  /* Compute the two's complement of the mantissa if the 
+   * input is negative.
+   */
+  sign = spu_maskw(spu_extract(spu_rlmaska((vec_int4)in, -31), 0));
+
+  mant = spu_xor(mant, sign);
+  borrow = spu_genb(mant, sign);
+  borrow = spu_shuffle(borrow, borrow, VEC_LITERAL(vec_uchar16,
+						   4,5,6,7, 192,192,192,192,
+						   4,5,6,7, 192,192,192,192));
+  mant = spu_subx(mant, sign, borrow);
+
+  return (spu_extract((vec_llong2)(mant), 0));
+}
+
+#endif /* _LLRINTF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/llrint.h newlib-1.15.0/newlib/libm/machine/spu/headers/llrint.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/llrint.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/llrint.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,90 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LLRINT_H_
+#define _LLRINT_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+static __inline long long int _llrint(double x)
+{
+  int shift;
+  vec_int4 exp;
+  vec_uint4 mant, sign, mask, borrow;
+  vec_double2 in, bias;
+
+  in = spu_promote(x, 0);
+
+  /* Round the input according to the current rounding mode.
+   */
+  bias = spu_sel((vec_double2)(VEC_SPLAT_U64(0x4330000000000000ULL)), in, 
+		 VEC_SPLAT_U64(0x8000000000000000ULL));
+  mant = (vec_uint4)(spu_sub(spu_add(in, bias), bias));
+
+  /* Determine how many bits to shift the mantissa to correctly
+   * align it into long long element 0.
+   */
+  exp = spu_and(spu_rlmask((vec_int4)mant, -20), 0x7FF);
+  exp = spu_add(exp, -1011);
+  shift = spu_extract(exp, 0);
+
+  mask = spu_cmpgt(exp, 0);
+  mask = (vec_uint4)spu_maskw(spu_extract(mask, 0));
+
+  /* Algn mantissa bits
+   */
+  mant = spu_sel(spu_rlmaskqwbyte(mant, -8), 
+		 VEC_SPLAT_U32(0x00100000),
+		 VEC_LITERAL(vec_uint4, 0,0,0xFFF00000,0));
+
+  mant = spu_and(spu_slqwbytebc(spu_slqw(mant, shift), shift), mask);
+
+  /* Compute the two's complement of the mantissa if the 
+   * input is negative.
+   */
+  sign = spu_maskw(spu_extract(spu_rlmaska((vec_int4)in, -31), 0)); 
+
+  mant = spu_xor(mant, sign);
+  borrow = spu_genb(mant, sign);
+  borrow = spu_shuffle(borrow, borrow, VEC_LITERAL(vec_uchar16,
+						   4,5,6,7, 192,192,192,192,
+						   4,5,6,7, 192,192,192,192));
+  mant = spu_subx(mant, sign, borrow);
+
+  return (spu_extract((vec_llong2)(mant), 0));
+}
+
+#endif /* _LLRINT_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/llroundf.h newlib-1.15.0/newlib/libm/machine/spu/headers/llroundf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/llroundf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/llroundf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,90 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LLROUNDF_H_
+#define _LLROUNDF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+static __inline long long int _llroundf(float x)
+{
+  int shift;
+  vec_int4 exp;
+  vec_uint4 mant, sign, borrow;
+  vec_float4 in;
+
+  in = spu_promote(x, 0);
+
+  /* Place mantissa bits (including implied most signficant
+   * bit) into the most significant bits of element 3. Elements
+   * 0, 1, and 2 are zeroed.
+   */
+  mant = spu_sel(spu_rlmaskqwbyte((vec_uint4)in, -11), 
+		 VEC_SPLAT_U32(0x80000000),
+		 VEC_LITERAL(vec_uint4, 0,0,0xFF,0x800000FF));
+
+  /* Determine how many bits to shift the mantissa to correctly
+   * align it into long long element 0.
+   */
+  exp = spu_and(spu_rlmask((vec_int4)in, -23), 0xFF);
+  shift = spu_extract(spu_add(exp, -94), 0);
+
+  /* Algn mantissa bits
+   */
+  mant = spu_slqwbytebc(spu_slqw(mant, shift), shift);
+
+  /* Perform round by adding 1 if the fraction bits are 
+   * greater than or equal to .5
+   */
+  mant = spu_add(mant, spu_and(spu_rlqw(mant, 1), VEC_LITERAL(vec_uint4, 0,1,0,0)));
+
+  /* Compute the two's complement of the mantissa if the 
+   * input is negative.
+   */
+  sign = spu_maskw(spu_extract(spu_rlmaska((vec_int4)in, -31), 0));
+
+  mant = spu_xor(mant, sign);
+  borrow = spu_genb(mant, sign);
+
+  borrow = spu_shuffle(borrow, borrow, VEC_LITERAL(vec_uchar16,
+						   4,5,6,7, 192,192,192,192,
+						   4,5,6,7, 192,192,192,192));
+  mant = spu_subx(mant, sign, borrow);
+
+  return (spu_extract((vec_llong2)(mant), 0));
+}
+
+#endif /* _LLROUNDF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/llround.h newlib-1.15.0/newlib/libm/machine/spu/headers/llround.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/llround.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/llround.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,90 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LLROUND_H_
+#define _LLROUND_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+static __inline long long int _llround(double x)
+{
+  int shift;
+  vec_int4 exp;
+  vec_uint4 mant, sign, mask, borrow, addend;
+  vec_double2 in;
+
+  in = spu_promote(x, 0);
+
+  /* Determine how many bits to shift the mantissa to correctly
+   * align it into long long element 0.
+   */
+  exp = spu_and(spu_rlmask((vec_int4)in, -20), 0x7FF);
+  exp = spu_add(exp, -1011);
+  shift = spu_extract(exp, 0);
+
+  mask = spu_cmpgt(exp, 0);
+  mask = (vec_uint4)spu_maskw(spu_extract(mask, 0));
+
+  /* Algn mantissa bits
+   */
+  mant = spu_sel(spu_rlmaskqwbyte((vec_uint4)in, -8), 
+		 VEC_SPLAT_U32(0x00100000),
+		 VEC_LITERAL(vec_uint4, 0,0,0xFFF00000,0));
+
+  mant = spu_and(spu_slqwbytebc(spu_slqw(mant, shift), shift), mask);
+
+  /* Perform round by adding 1 if the fraction bits are 
+   * greater than or equal to .5
+   */
+  addend = spu_and(spu_rlqw(mant, 1), VEC_LITERAL(vec_uint4, 0,1,0,0));
+  mant = spu_addx(mant, addend, spu_rlqwbyte(spu_genc(mant, addend), 4));
+
+  /* Compute the two's complement of the mantissa if the 
+   * input is negative.
+   */
+  sign = spu_maskw(spu_extract(spu_rlmaska((vec_int4)in, -31), 0)); 
+
+  mant = spu_xor(mant, sign);
+  borrow = spu_genb(mant, sign);
+  borrow = spu_shuffle(borrow, borrow, VEC_LITERAL(vec_uchar16,
+						   4,5,6,7, 192,192,192,192,
+						   4,5,6,7, 192,192,192,192));
+  mant = spu_subx(mant, sign, borrow);
+
+  return (spu_extract((vec_llong2)(mant), 0));
+}
+
+#endif /* _LLROUND_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log10f.h newlib-1.15.0/newlib/libm/machine/spu/headers/log10f.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log10f.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/log10f.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,54 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _LOG10F_H_
+#define _LOG10F_H_	1
+
+#include "log2f.h"
+
+/*
+ * FUNCTION
+ *	float _log10f(float x)
+ *
+ * DESCRIPTION
+ *	_log10f computes log (base 10) of the input value x. log10
+ *	is computed using log2 as follows:
+ *	
+ *	   log10f(x) = log2(x) / log2(10);
+ */
+
+static __inline float _log10f(float x)
+{
+  return (_log2f(x) * 0.30102999566398f);
+}
+
+#endif /* _LOG10F_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log10.h newlib-1.15.0/newlib/libm/machine/spu/headers/log10.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log10.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/log10.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,54 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _LOG10_H_
+#define _LOG10_H_	1
+
+#include "log2.h"
+
+/*
+ * FUNCTION
+ *	double _log10(double x)
+ *
+ * DESCRIPTION
+ *	_log10 computes log (base 10) of the input value x. log10
+ *	is computed using log2 as follows:
+ *	
+ *	   log10(x) = log2(x) / log2(10);
+ */
+
+static __inline double _log10(double x)
+{
+  return (_log2(x) * 0.301029995663981195213);
+}
+
+#endif /* _LOG10_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log2f.h newlib-1.15.0/newlib/libm/machine/spu/headers/log2f.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log2f.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/log2f.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,115 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _LOG2F_H_
+#define _LOG2F_H_	1
+
+/*
+ * FUNCTION
+ *	float _log2f(float x)
+ *
+ * DESCRIPTION
+ *	_log2f computes log (base 2) of the input value x. The log2f
+ *	function is approximated as a polynomial of order 8
+ *	(C. Hastings, Jr, 1955).
+ *
+ *                   __8__
+ *		     \
+ *		      \ 
+ *	log2f(1+x) =   /     Ci*x^i
+ *                   /____
+ *                    i=1
+ *
+ *	for x in the range 0.0 to 1.0
+ *
+ *	C1 =  1.4426898816672
+ *	C2 = -0.72116591947498
+ *	C3 =  0.47868480909345
+ *	C4 = -0.34730547155299
+ *	C5 =  0.24187369696082
+ *	C6 = -0.13753123777116
+ *	C7 =  0.052064690894143
+ *	C8 = -0.0093104962134977
+ *
+ *	This function assumes that x is a non-zero positive value.
+ */
+
+static __inline float _log2f(float x)
+{
+  union {
+    unsigned int ui;
+    float f;
+  } in;
+  int exponent;
+  float result;
+  float x2, x4;
+  float hi, lo;
+
+  in.f = x;
+
+  /* Extract the exponent from the input X. 
+   */
+  exponent = (signed)((in.ui >> 23) & 0xFF) - 127;
+
+  /* Compute the remainder after removing the exponent.
+   */
+  in.ui -= exponent << 23;
+  
+  /* Calculate the log2 of the remainder using the polynomial
+   * approximation.
+   */
+  x = in.f - 1.0f;
+
+  /* Instruction counts can be reduced if the polynomial was
+   * computed entirely from nested (dependent) fma's. However, 
+   * to reduce the number of pipeline stalls, the polygon is evaluated 
+   * in two halves (hi amd lo). 
+   */
+  x2 = x * x;
+  x4 = x2 * x2;
+  hi = -0.0093104962134977f*x + 0.052064690894143f;
+  hi =                   hi*x - 0.13753123777116f;
+  hi =                   hi*x + 0.24187369696082f;
+  hi =                   hi*x - 0.34730547155299f;
+  lo =  0.47868480909345f  *x - 0.72116591947498f;
+  lo =                   lo*x + 1.4426898816672f;
+  lo =                   lo*x;
+  result = hi*x4 + lo;
+
+  /* Add the exponent back into the result.
+   */
+  result += (float)(exponent);
+
+  return (result);
+}
+
+#endif /* _LOG2F_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log2.h newlib-1.15.0/newlib/libm/machine/spu/headers/log2.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log2.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/log2.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,53 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _LOG2_H_
+#define _LOG2_H_	1
+
+#include <spu_intrinsics.h>
+#include "log2_v.h"
+
+/*
+ * FUNCTION
+ *	double _log2(double x)
+ *
+ * DESCRIPTION
+ *	_log2 computes the log base 2 of the input x.
+ */
+
+static __inline double _log2(double x)
+{
+  return (spu_extract(_log2_v(spu_promote(x, 0)), 0));
+}
+
+#endif /* _LOG2_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log2_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/log2_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log2_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/log2_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,147 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _LOG2_V_H_
+#define _LOG2_V_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include <vec_literal.h>
+
+/*
+ * FUNCTION
+ *	vector double _log2_v(vector double x)
+ *
+ * DESCRIPTION
+ *	_log2_v computes log base 2 of the input x for each
+ *	of the double word elements of x. The log2 is decomposed
+ *      into two parts, log2 of the exponent and log2 of the 
+ *	fraction. The log2 of the fraction is approximated 
+ *	using a 21st order polynomial of the form:
+ *
+ *                        __20_
+ *                        \
+ *	log(x) = x * (1 +  \   (Ci * x^i))
+ *                         /
+ *                        /____
+ *                         i=0
+ *
+ *      for x in the range 0-1.
+ */
+
+
+#define LOG_C00    0.44269504088896339E+00
+#define LOG_C01   -7.21347520444469934E-01
+#define LOG_C02    4.80898346961226595E-01
+#define LOG_C03   -3.60673760117245982E-01
+#define LOG_C04    2.88539004851839364E-01
+#define LOG_C05   -2.40449108727688962E-01
+#define LOG_C06    2.06098446037376922E-01
+#define LOG_C07   -1.80329036970820794E-01
+#define LOG_C08    1.60245637034704267E-01
+#define LOG_C09   -1.43988260692073185E-01
+#define LOG_C10    1.30009193360025350E-01
+#define LOG_C11   -1.16530490533844182E-01
+#define LOG_C12    1.01392360727236079E-01
+#define LOG_C13   -8.27937055456904317E-02
+#define LOG_C14    6.08335872067172597E-02
+#define LOG_C15   -3.84093543662501949E-02
+#define LOG_C16    1.98461565426430164E-02
+#define LOG_C17   -7.93793829370930689E-03
+#define LOG_C18    2.28193656337578229E-03
+#define LOG_C19   -4.16662127033480827E-04
+#define LOG_C20    3.61276447184348752E-05
+
+
+static __inline vector double _log2_v(vector double vx) 
+{
+   vec_int4 addval;
+   vec_ullong2 exp_mask = VEC_SPLAT_U64(0x7FF0000000000000ULL);
+   vec_double2 vy, vxw;
+   vec_double2 v1 = VEC_SPLAT_F64(1.0);
+   vec_double2 x2, x4, x8, x10, p1, p2;
+
+   /* Extract the fraction component of input by forcing
+    * its exponent so that input is in the range [1.0, 2.0)
+    * and then subtract 1.0 to force it in the range 
+    * [0.0, 1.0).
+    */
+   vxw = spu_sub(spu_sel(vx, v1, exp_mask), v1);
+
+   /* Compute the log2 of the exponent as exp - 1023.
+    */
+   addval = spu_add(spu_rlmask((vec_int4)vx, -20), -1023);
+
+   /* Compute the log2 of the fractional component using a 21st 
+    * order polynomial. The polynomial is evaluated in two halves 
+    * to improve efficiency.
+    */
+   p1 = spu_madd(VEC_SPLAT_F64(LOG_C20), vxw, VEC_SPLAT_F64(LOG_C19));
+   p2 = spu_madd(VEC_SPLAT_F64(LOG_C09), vxw, VEC_SPLAT_F64(LOG_C08));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(LOG_C18));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(LOG_C07));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(LOG_C17));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(LOG_C06));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(LOG_C16));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(LOG_C05));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(LOG_C15));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(LOG_C04));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(LOG_C14));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(LOG_C03));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(LOG_C13));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(LOG_C02));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(LOG_C12));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(LOG_C01));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(LOG_C11));
+   p2 = spu_madd(vxw, p2, VEC_SPLAT_F64(LOG_C00));
+   p1 = spu_madd(vxw, p1, VEC_SPLAT_F64(LOG_C10));
+
+   x2 = spu_mul(vxw, vxw);
+   x4 = spu_mul(x2, x2);
+   x8 = spu_mul(x4, x4);
+   x10 = spu_mul(x8, x2);
+
+   vy = spu_madd(spu_madd(x10, p1, p2), vxw, vxw);
+
+   /* Add the log2(exponent) and the log2(fraction) to 
+    * compute the final result.
+    */
+   vy = spu_add(vy, spu_extend(spu_convtf(addval, 0))); 
+
+   vxw = spu_extend(spu_convtf(addval, 20));
+
+   return(vy);
+}
+
+#endif /* _LOG2_V_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/logf.h newlib-1.15.0/newlib/libm/machine/spu/headers/logf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/logf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/logf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,54 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _LOGF_H_
+#define _LOGF_H_		1
+
+#include "log2f.h"
+
+/*
+ * FUNCTION
+ *	float _logf(float x)
+ *
+ * DESCRIPTION
+ *	_logf computes the natural log (base e) of the input value x. log
+ *	is computed using log2 as follows:
+ *	
+ *	   logf(x) = log2f(x) / log2f(e);
+ */
+
+static __inline float _logf(float x)
+{
+  return (_log2f(x) * 0.69314718055995f);
+}
+
+#endif /* _LOGF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log.h newlib-1.15.0/newlib/libm/machine/spu/headers/log.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/log.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/log.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,61 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _LOG_H_
+#define _LOG_H_	1
+
+#include <spu_intrinsics.h>
+#include "log2_v.h"
+
+#ifndef M_LN2
+#define M_LN2		0.69314718055994530942
+#endif /* M_LN2 */
+
+
+/*
+ * FUNCTION
+ *	double _log(double x)
+ *
+ * DESCRIPTION
+ *	_log computes the natural log of the input x. log is
+ *     computed using log2 as follows:
+ *
+ *	log(x) = log2(x) / log2(e) = log2(x) * log(2)
+ */
+
+static __inline double _log(double x)
+{
+  return (spu_extract(_log2_v(spu_promote(x, 0)), 0) * M_LN2);
+}
+
+#endif /* _LOG_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/lrintf.h newlib-1.15.0/newlib/libm/machine/spu/headers/lrintf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/lrintf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/lrintf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,50 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LRINTF_H_
+#define _LRINTF_H_	1
+
+#include <spu_intrinsics.h>
+
+/* Round the input to the nearest integer according to the current
+ * rounding mode. No special handling is performed when values are
+ * outside the 32-bit range.
+ */
+static __inline long int _lrintf(float x)
+{
+  return ((long int)spu_extract(spu_convts(spu_promote(x, 0), 0), 0));
+}
+
+#endif /* _LRINTF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/lrint.h newlib-1.15.0/newlib/libm/machine/spu/headers/lrint.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/lrint.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/lrint.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,69 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LRINT_H_
+#define _LRINT_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+
+/* Round the input to the nearest integer according to the current
+ * rounding mode. 
+ */
+static __inline long int _lrint(double x)
+{
+  vec_int4 out, sign;
+  vec_double2 in, addend;
+
+  in = spu_promote(x, 0);
+
+  /* Add 2^53 affect a round to be performed by the hardware.
+   */
+  addend = spu_sel((vec_double2)(VEC_SPLAT_U64(0x4330000000000000ULL)), in, VEC_SPLAT_U64(0x8000000000000000ULL));
+  out = (vec_int4)spu_rlqwbyte(spu_add(in, addend), 4);
+
+  /* Correct the output sign.
+   */
+  sign = spu_rlmaska((vec_int4)in, -31);
+  
+  out = spu_sub(spu_xor(out, sign), sign);
+
+  return ((long int)spu_extract(out, 0));
+}
+
+#endif /* _LRINT_H_ */
+#endif /* __SPU__ */
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/lroundf.h newlib-1.15.0/newlib/libm/machine/spu/headers/lroundf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/lroundf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/lroundf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,61 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LROUNDF_H_
+#define _LROUNDF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Round the input to the nearest integer value, rounding halfway cases 
+ * away from zero. No special handling is performed when values are
+ * outside the 32-bit range.
+ */
+static __inline long int _lroundf(float x)
+{
+  vec_int4 out;
+  vec_float4 in, addend;
+
+  in = spu_promote(x, 0);
+  
+  /* Add signed 0.5 */
+  addend = spu_sel(VEC_SPLAT_F32(0.5f), in, VEC_SPLAT_U32(0x80000000));
+  out = spu_convts(spu_add(in, addend), 0);
+
+  return ((long int)spu_extract(out, 0));
+}
+
+
+#endif /* _LROUNDF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/lround.h newlib-1.15.0/newlib/libm/machine/spu/headers/lround.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/lround.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/lround.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,91 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _LROUND_H_
+#define _LROUND_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Round the input to the nearest integer value, rounding halfway cases 
+ * away from zero. No special handling is performed when values are
+ * outside the 32-bit range.
+ */
+
+static __inline long int _lround(double x)
+{
+  int shift;
+  vec_int4 exp;
+  vec_uint4 mant, sign, mask, addend;
+  vec_double2 in;
+
+  in = spu_promote(x, 0);
+
+  /* Determine how many bits to shift the mantissa to correctly
+   * align it into long long element 0.
+   */
+  exp = spu_and(spu_rlmask((vec_int4)in, -20), 0x7FF);
+  exp = spu_add(exp, -979);
+  shift = spu_extract(exp, 0);
+
+  mask = spu_cmpgt(exp, 0);
+
+  /* Algn mantissa bits
+   */
+  mant = spu_sel(spu_rlmaskqwbyte((vec_uint4)in, -8), 
+		 VEC_SPLAT_U32(0x00100000),
+		 VEC_LITERAL(vec_uint4, 0,0,0xFFF00000,0));
+
+  mant = spu_slqwbytebc(spu_slqw(mant, shift), shift);
+
+  /* Perform round by adding 1 if the fraction bits are 
+   * greater than or equal to .5
+   */
+  addend = spu_and(spu_rlqw(mant, 1), 1);
+  mant = spu_and(spu_add(mant, addend), mask);
+
+  /* Compute the two's complement of the mantissa if the 
+   * input is negative.
+   */
+  sign = (vec_uint4)spu_rlmaska((vec_int4)in, -31); 
+
+  mant = spu_sub(spu_xor(mant, sign), sign);
+
+  return ((long int)spu_extract(mant, 0));
+}
+
+
+#endif /* _LROUND_H_ */
+#endif /* __SPU__ */
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/nearbyint.h newlib-1.15.0/newlib/libm/machine/spu/headers/nearbyint.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/nearbyint.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/nearbyint.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,67 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _NEARBYINT_H_
+#define _NEARBYINT_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Round the input to the nearest integer according to the current
+ * rounding mode without raising an inexact exception.
+ */
+static __inline double _nearbyint(double x)
+{
+  vec_uint4 fpscr;
+  vec_ullong2 sign = VEC_SPLAT_U64(0x8000000000000000ULL);
+  vec_double2 in, out, addend;
+  
+  fpscr = spu_mffpscr();
+
+  in = spu_promote(x, 0);
+
+  /* Add 2^53 and then subtract 2^53 to affect a round to be performed by the
+   * hardware. Also preserve the input sign so that negative inputs that 
+   * round to zero generate a -0.0.
+   */
+  addend = spu_sel((vec_double2)(VEC_SPLAT_U64(0x4330000000000000ULL)), in, sign);
+  out = spu_sel(spu_sub(spu_add(in, addend), addend), in, sign);
+
+  spu_mtfpscr(fpscr);
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _NEARBYINT_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/powf.h newlib-1.15.0/newlib/libm/machine/spu/headers/powf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/powf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/powf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,62 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _POWF_H_
+#define _POWF_H_		1
+
+#include "exp2f.h"
+#include "log2f.h"
+
+/*
+ * FUNCTION
+ *	float _powf(float x, float y)
+ *
+ * DESCRIPTION
+ *	_powf computes x raised to the power y. The pow function
+ *	is computed as by decomposing the problem into:
+ *		x^y = 2^(y*log2(x))
+ *
+ *	This function assumes that x is a non-zero positive value.
+ */
+
+static __inline float _powf(float x, float y)
+{
+  return(_exp2f(y*_log2f(x)));
+}
+
+#endif /* _POWF_H_ */
+
+
+
+
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/pow.h newlib-1.15.0/newlib/libm/machine/spu/headers/pow.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/pow.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/pow.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,62 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _POW_H_
+#define _POW_H_	1
+
+#include "exp2.h"
+#include "log2.h"
+
+/*
+ * FUNCTION
+ *	double _pow(double x, double y)
+ *
+ * DESCRIPTION
+ *	_pow computes x raised to the power y. The pow_ function is 
+ *	computed as by decomposing the problem into:
+ *		x^y = 2^(y*log2(x))
+ *
+ *	This function assumes that x is contains non-zero positive values.
+ */
+
+static __inline double _pow(double x, double y)
+{
+  return(_exp2(y * _log2(x)));
+}
+
+#endif /* _POW_H_ */
+
+
+
+
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/remainderf.h newlib-1.15.0/newlib/libm/machine/spu/headers/remainderf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/remainderf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/remainderf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,146 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _REMAINDERF_H_
+#define _REMAINDERF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+static __inline float _remainderf(float x, float y)
+{
+  int n;
+  vec_uint4 vx, vy, z;
+  vec_uint4 abs_x, abs_y, abs_2x, abs_2y;
+  vec_uint4 exp_x, exp_y;
+  vec_uint4 zero_x, zero_y;
+  vec_uint4 logb_x, logb_y;
+  vec_uint4 mant_x, mant_y;
+  vec_uint4 result, result0, resultx, cnt, sign, bias;
+  vec_uint4 sign_mask = VEC_SPLAT_U32(0x80000000);
+  vec_uint4 implied_1 = VEC_SPLAT_U32(0x00800000);
+  vec_uint4 mant_mask = VEC_SPLAT_U32(0x007FFFFF);
+  vec_float4 two = { 2.0f, 2.0f, 2.0f, 2.0f };
+
+  vx = (vec_uint4)spu_promote(x, 0);
+  vy = (vec_uint4)spu_promote(y, 0);
+
+  abs_x = spu_andc(vx, sign_mask);
+  abs_y = spu_andc(vy, sign_mask);
+
+  abs_2y = spu_add(abs_y, implied_1);	/* abs_2y = 2 * abs_y */
+
+  sign = spu_and(vx, sign_mask);
+
+  /* Compute abs_x = fmodf(abs_x, 2*abs_y). If y is greater than 0.5*SMAX 
+   * (SMAX is the maximum representable float), then return abs_x.
+   */
+  {
+    /* Determine ilogb of abs_x and abs_2y and 
+     * extract the mantissas (mant_x, mant_y)
+     */
+    exp_x  = spu_rlmask(abs_x, -23);
+    exp_y  = spu_rlmask(abs_2y, -23);
+
+    resultx = spu_or(spu_cmpgt(abs_2y, abs_x), spu_cmpgt(abs_y, VEC_SPLAT_U32(0x7F7FFFFF)));
+
+    zero_x = spu_cmpeq(exp_x, 0);
+    zero_y = spu_cmpeq(exp_y, 0);
+    
+    logb_x = spu_add(exp_x, -127);
+    logb_y = spu_add(exp_y, -127);
+
+    mant_x = spu_andc(spu_sel(implied_1, abs_x, mant_mask), zero_x);
+    mant_y = spu_andc(spu_sel(implied_1, abs_2y, mant_mask), zero_y);
+
+    /* Compute fixed point fmod of mant_x and mant_y. Set the flag,
+     * result0, to all ones if we detect that the final result is 
+     * ever 0.
+     */
+    result0 = spu_or(zero_x, zero_y);
+
+    n = spu_extract(spu_sub(logb_x, logb_y), 0);
+
+
+    while (n-- > 0) {
+      z = spu_sub(mant_x, mant_y);
+
+      result0 = spu_or(spu_cmpeq(z, 0), result0);
+    
+      mant_x = spu_sel(spu_add(mant_x, mant_x),
+		       spu_add(z, z),
+		       spu_cmpgt((vec_int4)z, -1));
+    }
+
+    z = spu_sub(mant_x, mant_y);
+    mant_x = spu_sel(mant_x, z, spu_cmpgt((vec_int4)z, -1));
+
+    result0 = spu_or(spu_cmpeq(mant_x, 0), result0);
+
+    /* Convert the result back to floating point and restore
+     * the sign. If we flagged the result to be zero (result0),
+     * zero it. If we flagged the result to equal its input x,
+     * (resultx) then return x.
+     */
+    cnt = spu_add(spu_cntlz(mant_x), -8);
+
+    mant_x = spu_rl(spu_andc(mant_x, implied_1), (vec_int4)cnt);
+    
+    exp_y = spu_sub(exp_y, cnt);
+    result0 = spu_orc(result0, spu_cmpgt((vec_int4)exp_y, 0));	/* zero denorm results */
+    exp_y = spu_rl(exp_y, 23);
+
+    result = spu_sel(exp_y, mant_x, mant_mask);
+    abs_x = spu_sel(spu_andc(result, spu_rlmask(result0, -1)), abs_x, resultx);
+  }
+
+  /* if (2*x > y)
+   *     x -= y
+   *     if (2*x >= y) x -= y
+   */
+  abs_2x = spu_add(abs_x, implied_1);
+  bias = spu_cmpgt(abs_2x, abs_y);
+  abs_x = spu_sel(abs_x, (vec_uint4)spu_sub((vec_float4)abs_x, (vec_float4)abs_y), bias);
+  bias = spu_andc(bias, spu_rlmaska((vec_uint4)spu_msub((vec_float4)abs_x, two, (vec_float4)abs_y), -31));
+  abs_x = spu_sel(abs_x, (vec_uint4)spu_sub((vec_float4)abs_x, (vec_float4)abs_y), bias);
+
+  /* Generate a correct final sign 
+   */
+  result = spu_xor(abs_x, sign);
+
+  return (spu_extract((vec_float4)result, 0));
+}
+
+#endif /* _REMAINDERF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/remainder.h newlib-1.15.0/newlib/libm/machine/spu/headers/remainder.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/remainder.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/remainder.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,197 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _REMAINDER_H_
+#define _REMAINDER_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+static __inline double _remainder(double x, double y)
+{
+  int n, shift;
+  vec_uchar16 swap_words = VEC_LITERAL(vec_uchar16, 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11);
+  vec_uchar16 propagate = VEC_LITERAL(vec_uchar16, 4,5,6,7, 192,192,192,192, 12,13,14,15, 192,192,192,192);
+  vec_uchar16 splat_hi = VEC_LITERAL(vec_uchar16, 0,1,2,3,0,1,2,3, 8,9,10,11, 8,9,10,11);
+  vec_uchar16 splat_lo = VEC_LITERAL(vec_uchar16, 4,5,6,7,4,5,6,7, 12,13,14,15, 12,13,14,15);
+  vec_uint4 vx, vy, z;
+  vec_uint4 x_hi, y_hi, y_lo;
+  vec_uint4 abs_x, abs_y, abs_2x, abs_2y;
+  vec_uint4 exp_x, exp_y;
+  vec_uint4 zero_x, zero_y;
+  vec_uint4 logb_x, logb_y;
+  vec_uint4 mant_x, mant_y;
+  vec_uint4 normal, norm, denorm;
+  vec_uint4 gt, eq, bias, y2_hi;
+  vec_uint4 nan_out;
+  vec_uint4 result, result0, resultx, cnt, sign, borrow;
+  vec_uint4 exp_special = VEC_SPLAT_U32(0x7FF00000);
+  vec_uint4 half_smax = VEC_SPLAT_U32(0x7FEFFFFF);
+  vec_uint4 lsb       = (vec_uint4)(VEC_SPLAT_U64(0x0000000000000001ULL));
+  vec_uint4 sign_mask = (vec_uint4)(VEC_SPLAT_U64(0x8000000000000000ULL));
+  vec_uint4 implied_1 = (vec_uint4)(VEC_SPLAT_U64(0x0010000000000000ULL));
+  vec_uint4 mant_mask = (vec_uint4)(VEC_SPLAT_U64(0x000FFFFFFFFFFFFFULL));
+
+  vx = (vec_uint4)spu_promote(x, 0);
+  vy = (vec_uint4)spu_promote(y, 0);
+
+  abs_x = spu_andc(vx, sign_mask);
+  abs_y = spu_andc(vy, sign_mask);
+
+  abs_2y = spu_add(abs_y, implied_1);
+
+  sign = spu_and(vx, sign_mask);
+
+
+  /* Compute abs_x = fmodf(abs_x, 2*abs_y). If y is greater than 0.5*SMAX (SMAX is the maximum
+   * representable float), then return abs_x.
+   */
+  {
+    x_hi = spu_shuffle(abs_x, abs_x, splat_hi);
+    y_lo = spu_shuffle(abs_y, abs_y, splat_lo);
+    y_hi = spu_shuffle(abs_y, abs_y, splat_hi);
+    y2_hi = spu_shuffle(abs_2y, abs_2y, splat_hi);
+
+    /* Force a NaN output if (1) abs_x is infinity or NaN or (2)
+     * abs_y is a NaN.
+     */
+    nan_out = spu_or(spu_cmpgt(x_hi, half_smax), 
+		     spu_or(spu_cmpgt(y_hi, exp_special), 
+			    spu_and(spu_cmpeq(y_hi, exp_special),
+				    spu_cmpgt(y_lo, 0))));
+  
+    /* Determine ilogb of abs_x and abs_y and 
+     * extract the mantissas (mant_x, mant_y)
+     */
+    exp_x  = spu_rlmask(x_hi, -20);
+    exp_y  = spu_rlmask(y2_hi, -20);
+
+    resultx = spu_or(spu_cmpgt(y2_hi, x_hi), spu_cmpgt(y_hi, half_smax));
+
+    zero_x = spu_cmpeq(exp_x, 0);
+    zero_y = spu_cmpeq(exp_y, 0);
+
+    logb_x = spu_add(exp_x, -1023);
+    logb_y = spu_add(exp_y, -1023);
+
+    mant_x = spu_andc(spu_sel(implied_1, abs_x, mant_mask), zero_x);
+    mant_y = spu_andc(spu_sel(implied_1, abs_2y, mant_mask), zero_y);
+
+    /* Compute fixed point fmod of mant_x and mant_y. Set the flag,
+     * result0, to all ones if we detect that the final result is 
+     * ever 0.
+     */
+    result0 = spu_or(zero_x, zero_y);
+
+    n = spu_extract(spu_sub(logb_x, logb_y), 0);
+
+    while (n-- > 0) {
+      borrow = spu_genb(mant_x, mant_y);
+      borrow = spu_shuffle(borrow, borrow, propagate);
+      z = spu_subx(mant_x, mant_y, borrow);
+
+      result0 = spu_or(spu_cmpeq(spu_or(z, spu_shuffle(z, z, swap_words)), 0), result0); 
+    
+      mant_x = spu_sel(spu_slqw(mant_x, 1), spu_andc(spu_slqw(z, 1), lsb), spu_cmpgt((vec_int4)spu_shuffle(z, z, splat_hi), -1));
+    }
+
+
+    borrow = spu_genb(mant_x, mant_y);
+    borrow = spu_shuffle(borrow, borrow, propagate);
+    z = spu_subx(mant_x, mant_y, borrow);
+
+    mant_x = spu_sel(mant_x, z, spu_cmpgt((vec_int4)spu_shuffle(z, z, splat_hi), -1));
+    mant_x = spu_andc(mant_x, VEC_LITERAL(vec_uint4, 0,0,-1,-1));
+
+    result0 = spu_or(spu_cmpeq(spu_or(mant_x, spu_shuffle(mant_x, mant_x, swap_words)), 0), result0);
+
+    /* Convert the result back to floating point and restore
+     * the sign. If we flagged the result to be zero (result0),
+     * zero it. If we flagged the result to equal its input x,
+     * (resultx) then return x.
+     *
+     * Double precision generates a denorm for an output.
+     */
+    cnt = spu_cntlz(mant_x);
+    cnt = spu_add(cnt, spu_and(spu_rlqwbyte(cnt, 4), spu_cmpeq(cnt, 32)));
+    cnt = spu_add(spu_shuffle(cnt, cnt, splat_hi), -11);
+
+    shift = spu_extract(exp_y, 0) - 1;
+    denorm = spu_slqwbytebc(spu_slqw(mant_x, shift), shift);
+
+    exp_y = spu_sub(exp_y, cnt);
+
+    normal = spu_cmpgt((vec_int4)exp_y, 0);
+
+    /* Normalize normal results, denormalize denorm results.
+     */
+    shift = spu_extract(cnt, 0);			    
+    norm = spu_slqwbytebc(spu_slqw(spu_andc(mant_x, VEC_LITERAL(vec_uint4, 0x00100000, 0, -1, -1)), shift), shift);
+
+    mant_x = spu_sel(denorm, norm, normal);
+    
+    exp_y = spu_and(spu_rl(exp_y, 20), normal);
+    
+    result = spu_sel(exp_y, mant_x, mant_mask);
+    
+    abs_x = spu_sel(spu_andc(result, spu_rlmask(result0, -1)), abs_x, resultx);
+
+  }
+
+  /* if (2*x > y)
+   *     x -= y
+   *     if (2*x >= y) x -= y
+   */
+  abs_2x = spu_and(spu_add(abs_x, implied_1), normal);
+
+  gt = spu_cmpgt(abs_2x, abs_y);
+  eq = spu_cmpeq(abs_2x, abs_y);
+  bias = spu_or(gt, spu_and(eq, spu_rlqwbyte(gt, 4)));
+  bias = spu_shuffle(bias, bias, splat_hi);
+  abs_x = spu_sel(abs_x, (vec_uint4)spu_sub((vec_double2)abs_x, (vec_double2)abs_y), bias);
+
+  bias = spu_andc(bias, spu_rlmaska((vec_uint4)spu_msub((vec_double2)abs_x, VEC_SPLAT_F64(2.0), (vec_double2)abs_y), -31));
+  bias = spu_shuffle(bias, bias, splat_hi);
+  abs_x = spu_sel(abs_x, (vec_uint4)spu_sub((vec_double2)abs_x, (vec_double2)abs_y), bias);
+
+  /* Generate a correct final sign 
+   */
+  result = spu_sel(spu_xor(abs_x, sign), exp_special, nan_out);
+
+  return (spu_extract((vec_double2)result, 0));
+}
+
+#endif /* _REMAINDER_H_ */
+#endif /* __SPU__ */
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/remquof.h newlib-1.15.0/newlib/libm/machine/spu/headers/remquof.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/remquof.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/remquof.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,183 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _REMQUOF_H_
+#define _REMQUOF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+
+static __inline float _remquof(float x, float y, int *quo)
+{
+  int n;
+  vec_int4 quotient;
+  vec_int4 four = { 4, 4, 4, 4 };
+  vec_uint4 vx, vy, z, y2, y4;
+  vec_uint4 abs_x, abs_y, abs_2x, abs_8y;
+  vec_uint4 exp_x, exp_y;
+  vec_uint4 zero_x, zero_y;
+  vec_uint4 logb_x, logb_y;
+  vec_uint4 mant_x, mant_y;
+  vec_uint4 not_ge, overflow, quo_pos;
+  vec_uint4 result, result0, resultx, cnt, sign, bias;
+  vec_uint4 sign_mask = VEC_SPLAT_U32(0x80000000);
+  vec_uint4 implied_1 = VEC_SPLAT_U32(0x00800000);
+  vec_uint4 mant_mask = VEC_SPLAT_U32(0x007FFFFF);
+
+  vx = (vec_uint4)spu_promote(x, 0);
+  vy = (vec_uint4)spu_promote(y, 0);
+
+  abs_x = spu_andc(vx, sign_mask);
+  abs_y = spu_andc(vy, sign_mask);
+
+  abs_8y = spu_add(abs_y, VEC_SPLAT_U32(0x01800000));	/* abs_2y = 8 * abs_y */
+
+  sign = spu_and(vx, sign_mask);
+
+  quo_pos = spu_cmpgt((vec_int4)spu_and(spu_xor(vx, vy), sign_mask), -1);
+
+  /* Compute abs_x = fmodf(abs_x, 8*abs_y). If y is greater than 0.125*SMAX 
+   * (SMAX is the maximum representable float), then return abs_x.
+   */
+  {
+    /* Determine ilogb of abs_x and abs_8y and 
+     * extract the mantissas (mant_x, mant_y)
+     */
+    exp_x  = spu_rlmask(abs_x, -23);
+    exp_y  = spu_rlmask(abs_8y, -23);
+
+    resultx = spu_or(spu_cmpgt(abs_8y, abs_x), spu_cmpgt(abs_y, VEC_SPLAT_U32(0x7E7FFFFF)));
+
+    zero_x = spu_cmpeq(exp_x, 0);
+    zero_y = spu_cmpeq(exp_y, 0);
+    
+    logb_x = spu_add(exp_x, -127);
+    logb_y = spu_add(exp_y, -127);
+
+    mant_x = spu_andc(spu_sel(implied_1, abs_x, mant_mask), zero_x);
+    mant_y = spu_andc(spu_sel(implied_1, abs_8y, mant_mask), zero_y);
+
+    /* Compute fixed point fmod of mant_x and mant_y. Set the flag,
+     * result0, to all ones if we detect that the final result is 
+     * ever 0.
+     */
+    result0 = spu_or(zero_x, zero_y);
+
+    n = spu_extract(spu_sub(logb_x, logb_y), 0);
+
+
+    while (n-- > 0) {
+      z = spu_sub(mant_x, mant_y);
+
+      result0 = spu_or(spu_cmpeq(z, 0), result0);
+    
+      mant_x = spu_sel(spu_add(mant_x, mant_x),
+		       spu_add(z, z),
+		       spu_cmpgt((vec_int4)z, -1));
+    }
+
+    z = spu_sub(mant_x, mant_y);
+    mant_x = spu_sel(mant_x, z, spu_cmpgt((vec_int4)z, -1));
+
+    result0 = spu_or(spu_cmpeq(mant_x, 0), result0);
+
+    /* Convert the result back to floating point and restore
+     * the sign. If we flagged the result to be zero (result0),
+     * zero it. If we flagged the result to equal its input x,
+     * (resultx) then return x.
+     */
+    cnt = spu_add(spu_cntlz(mant_x), -8);
+
+    mant_x = spu_rl(spu_andc(mant_x, implied_1), (vec_int4)cnt);
+    
+    exp_y = spu_sub(exp_y, cnt);
+    result0 = spu_orc(result0, spu_cmpgt((vec_int4)exp_y, 0));	/* zero denorm results */
+    exp_y = spu_rl(exp_y, 23);
+
+    result = spu_sel(exp_y, mant_x, mant_mask);
+    abs_x = spu_sel(spu_andc(result, spu_rlmask(result0, -1)), abs_x, resultx);
+  }
+
+  /* if (x >= 4*y)
+   * 	x -= 4*y
+   *    quotient = 4
+   * else 
+   *	quotient = 0
+   */
+  y4 = spu_andc(spu_add(abs_y, VEC_SPLAT_U32(0x01000000)), zero_y);
+
+  overflow = spu_cmpgt(abs_y, VEC_SPLAT_U32(0x7EFFFFFF));
+  not_ge = spu_or(spu_cmpgt(y4, abs_x), overflow);
+
+  abs_x = spu_sel((vec_uint4)spu_sub((vec_float4)abs_x, (vec_float4)y4), abs_x, not_ge);
+  quotient = spu_andc (four, (vec_int4)not_ge);
+
+  /* if (x >= 2*y
+   *	x -= 2*y
+   *    quotient += 2
+   */
+  y2 = spu_andc(spu_add(abs_y, implied_1), zero_y);
+  not_ge = spu_cmpgt(y2, abs_x);
+  
+  abs_x = spu_sel((vec_uint4)spu_sub((vec_float4)abs_x, (vec_float4)y2), abs_x, not_ge);
+  quotient = spu_sel(spu_add(quotient, 2), quotient, not_ge);
+
+  /* if (2*x > y)
+   *     x -= y
+   *     if (2*x >= y) x -= y
+   */
+  abs_2x = spu_add(abs_x, implied_1);
+  bias = spu_cmpgt(abs_2x, abs_y);
+  abs_x = spu_sel(abs_x, (vec_uint4)spu_sub((vec_float4)abs_x, (vec_float4)abs_y), bias);
+  quotient = spu_sub(quotient, (vec_int4)bias);
+
+  bias = spu_andc(bias, spu_rlmaska((vec_uint4)spu_msub((vec_float4)abs_x, VEC_SPLAT_F32(2.0f), (vec_float4)abs_y), -31));
+  abs_x = spu_sel(abs_x, (vec_uint4)spu_sub((vec_float4)abs_x, (vec_float4)abs_y), bias);
+  quotient = spu_sub(quotient, (vec_int4)bias);
+
+  /* Generate a correct final sign 
+   */
+  result = spu_xor(abs_x, sign);
+
+  quotient = spu_and(quotient, 7);
+  quotient = spu_sel(spu_sub(0, quotient), quotient, quo_pos);
+
+  *quo = spu_extract(quotient, 0);
+
+  return (spu_extract((vec_float4)result, 0));
+}
+
+#endif /* _REMQUOF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/remquo.h newlib-1.15.0/newlib/libm/machine/spu/headers/remquo.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/remquo.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/remquo.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,244 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _REMQUO_H_
+#define _REMQUO_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+static __inline double _remquo(double x, double y, int *quo)
+{
+  int n, shift;
+  vec_uchar16 swap_words = VEC_LITERAL(vec_uchar16, 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11);
+  vec_uchar16 propagate = VEC_LITERAL(vec_uchar16, 4,5,6,7, 192,192,192,192, 12,13,14,15, 192,192,192,192);
+  vec_uchar16 splat_hi = VEC_LITERAL(vec_uchar16, 0,1,2,3,0,1,2,3, 8,9,10,11, 8,9,10,11);
+  vec_uchar16 splat_lo = VEC_LITERAL(vec_uchar16, 4,5,6,7,4,5,6,7, 12,13,14,15, 12,13,14,15);
+  vec_int4 quotient;
+  vec_int4 four = { 4, 4, 4, 4 };
+  vec_uint4 vx, vy, z;
+  vec_uint4 x_hi, y_hi, y8_hi, y_lo, y2, y4;
+  vec_uint4 abs_x, abs_y, abs_2x, abs_2y, abs_8y;
+  vec_uint4 exp_x, exp_y;
+  vec_uint4 zero_x, zero_y;
+  vec_uint4 logb_x, logb_y;
+  vec_uint4 mant_x, mant_y;
+  vec_uint4 normal, norm, denorm;
+  vec_uint4 gt, eq, bias;
+  vec_uint4 nan_out, not_ge, quo_pos, overflow;
+  vec_uint4 result, result0, resultx, cnt, sign, borrow;
+  vec_uint4 exp_special = VEC_SPLAT_U32(0x7FF00000);
+  vec_uint4 half_smax = VEC_SPLAT_U32(0x7FEFFFFF);
+  vec_uint4 lsb       = (vec_uint4)(VEC_SPLAT_U64(0x0000000000000001ULL));
+  vec_uint4 sign_mask = (vec_uint4)(VEC_SPLAT_U64(0x8000000000000000ULL));
+  vec_uint4 implied_1 = (vec_uint4)(VEC_SPLAT_U64(0x0010000000000000ULL));
+  vec_uint4 mant_mask = (vec_uint4)(VEC_SPLAT_U64(0x000FFFFFFFFFFFFFULL));
+
+  vx = (vec_uint4)spu_promote(x, 0);
+  vy = (vec_uint4)spu_promote(y, 0);
+
+  abs_x = spu_andc(vx, sign_mask);
+  abs_y = spu_andc(vy, sign_mask);
+
+  abs_2y = spu_add(abs_y, implied_1);
+  abs_8y = spu_add(abs_y, VEC_LITERAL(vec_uint4, 0x00300000, 0, 0x00300000, 0));
+
+  sign = spu_and(vx, sign_mask);
+
+  quo_pos = spu_cmpgt((vec_int4)spu_and(spu_xor(vx, vy), sign_mask), -1);
+  quo_pos = spu_shuffle(quo_pos, quo_pos, splat_hi);
+
+  /* Compute abs_x = fmodf(abs_x, 8*abs_y). If y is greater than 0.125*SMAX 
+   * (SMAX is the maximum representable float), then return abs_x.
+   */
+  {
+    x_hi = spu_shuffle(abs_x, abs_x, splat_hi);
+    y_lo = spu_shuffle(abs_y, abs_y, splat_lo);
+    y_hi = spu_shuffle(abs_y, abs_y, splat_hi);
+    y8_hi = spu_shuffle(abs_8y, abs_8y, splat_hi);
+
+    /* Force a NaN output if (1) abs_x is infinity or NaN or (2)
+     * abs_y is a NaN.
+     */
+    nan_out = spu_or(spu_cmpgt(x_hi, half_smax), 
+		     spu_or(spu_cmpgt(y_hi, exp_special), 
+			    spu_and(spu_cmpeq(y_hi, exp_special),
+				    spu_cmpgt(y_lo, 0))));
+  
+    /* Determine ilogb of abs_x and abs_8y and 
+     * extract the mantissas (mant_x, mant_y)
+     */
+    exp_x  = spu_rlmask(x_hi, -20);
+    exp_y  = spu_rlmask(y8_hi, -20);
+
+    resultx = spu_or(spu_cmpgt(y8_hi, x_hi), spu_cmpgt(y_hi, half_smax));
+
+    zero_x = spu_cmpeq(exp_x, 0);
+    zero_y = spu_cmpeq(exp_y, 0);
+
+    logb_x = spu_add(exp_x, -1023);
+    logb_y = spu_add(exp_y, -1023);
+
+    mant_x = spu_andc(spu_sel(implied_1, abs_x, mant_mask), zero_x);
+    mant_y = spu_andc(spu_sel(implied_1, abs_8y, mant_mask), zero_y);
+
+    /* Compute fixed point fmod of mant_x and mant_y. Set the flag,
+     * result0, to all ones if we detect that the final result is 
+     * ever 0.
+     */
+    result0 = spu_or(zero_x, zero_y);
+
+    n = spu_extract(spu_sub(logb_x, logb_y), 0);
+
+    while (n-- > 0) {
+      borrow = spu_genb(mant_x, mant_y);
+      borrow = spu_shuffle(borrow, borrow, propagate);
+      z = spu_subx(mant_x, mant_y, borrow);
+
+      result0 = spu_or(spu_cmpeq(spu_or(z, spu_shuffle(z, z, swap_words)), 0), result0); 
+    
+      mant_x = spu_sel(spu_slqw(mant_x, 1), spu_andc(spu_slqw(z, 1), lsb), spu_cmpgt((vec_int4)spu_shuffle(z, z, splat_hi), -1));
+    }
+
+
+    borrow = spu_genb(mant_x, mant_y);
+    borrow = spu_shuffle(borrow, borrow, propagate);
+    z = spu_subx(mant_x, mant_y, borrow);
+
+    mant_x = spu_sel(mant_x, z, spu_cmpgt((vec_int4)spu_shuffle(z, z, splat_hi), -1));
+    mant_x = spu_andc(mant_x, VEC_LITERAL(vec_uint4, 0,0,-1,-1));
+
+    result0 = spu_or(spu_cmpeq(spu_or(mant_x, spu_shuffle(mant_x, mant_x, swap_words)), 0), result0);
+
+    /* Convert the result back to floating point and restore
+     * the sign. If we flagged the result to be zero (result0),
+     * zero it. If we flagged the result to equal its input x,
+     * (resultx) then return x.
+     *
+     * Double precision generates a denorm for an output.
+     */
+    cnt = spu_cntlz(mant_x);
+    cnt = spu_add(cnt, spu_and(spu_rlqwbyte(cnt, 4), spu_cmpeq(cnt, 32)));
+    cnt = spu_add(spu_shuffle(cnt, cnt, splat_hi), -11);
+
+    shift = spu_extract(exp_y, 0) - 1;
+    denorm = spu_slqwbytebc(spu_slqw(mant_x, shift), shift);
+
+    exp_y = spu_sub(exp_y, cnt);
+
+    normal = spu_cmpgt((vec_int4)exp_y, 0);
+
+    /* Normalize normal results, denormalize denorm results.
+     */
+    shift = spu_extract(cnt, 0);			    
+    norm = spu_slqwbytebc(spu_slqw(spu_andc(mant_x, VEC_LITERAL(vec_uint4, 0x00100000, 0, -1, -1)), shift), shift);
+
+    mant_x = spu_sel(denorm, norm, normal);
+    
+    exp_y = spu_and(spu_rl(exp_y, 20), normal);
+    
+    result = spu_sel(exp_y, mant_x, mant_mask);
+    
+    abs_x = spu_sel(spu_andc(result, spu_rlmask(result0, -1)), abs_x, resultx);
+
+  }
+
+  /* if (x >= 4*y)
+   * 	x -= 4*y
+   *    quotient = 4
+   * else 
+   *	quotient = 0
+   */
+  y4 = spu_andc(spu_add(abs_y, spu_rl(implied_1, 1)), zero_y);
+
+  overflow = spu_cmpgt(y_hi, VEC_SPLAT_U32(0x7FCFFFFF));
+  gt = spu_cmpgt(y4, abs_x);
+  eq = spu_cmpeq(y4, abs_x);
+  not_ge = spu_or(gt, spu_and(eq, spu_rlqwbyte(gt, 4)));
+  not_ge = spu_shuffle(not_ge, not_ge, splat_hi);
+  not_ge = spu_or(not_ge, overflow);
+
+  abs_x = spu_sel((vec_uint4)spu_sub((vec_double2)abs_x, (vec_double2)y4), abs_x, not_ge);
+  quotient = spu_andc(four, (vec_int4)not_ge);
+
+  /* if (x >= 2*y
+   *	x -= 2*y
+   *    quotient += 2
+   */
+  y2 = spu_andc(spu_add(abs_y, implied_1), zero_y);
+
+  overflow = spu_cmpgt(y_hi, VEC_SPLAT_U32(0x7FDFFFFF));
+  gt = spu_cmpgt(y2, abs_x);
+  eq = spu_cmpeq(y2, abs_x);
+  not_ge = spu_or(gt, spu_and(eq, spu_rlqwbyte(gt, 4)));
+  not_ge = spu_shuffle(not_ge, not_ge, splat_hi);
+  not_ge = spu_or(not_ge, overflow);
+
+  
+  abs_x = spu_sel((vec_uint4)spu_sub((vec_double2)abs_x, (vec_double2)y2), abs_x, not_ge);
+  quotient = spu_sel(spu_add(quotient, 2), quotient, not_ge);
+
+  /* if (2*x > y)
+   *     x -= y
+   *     if (2*x >= y) x -= y
+   */
+  abs_2x = spu_and(spu_add(abs_x, implied_1), normal);
+
+  gt = spu_cmpgt(abs_2x, abs_y);
+  eq = spu_cmpeq(abs_2x, abs_y);
+  bias = spu_or(gt, spu_and(eq, spu_rlqwbyte(gt, 4)));
+  bias = spu_shuffle(bias, bias, splat_hi);
+  abs_x = spu_sel(abs_x, (vec_uint4)spu_sub((vec_double2)abs_x, (vec_double2)abs_y), bias);
+  quotient = spu_sub(quotient, (vec_int4)bias);
+
+  bias = spu_andc(bias, spu_rlmaska((vec_uint4)spu_msub((vec_double2)abs_x, VEC_SPLAT_F64(2.0), (vec_double2)abs_y), -31));
+  bias = spu_shuffle(bias, bias, splat_hi);
+  abs_x = spu_sel(abs_x, (vec_uint4)spu_sub((vec_double2)abs_x, (vec_double2)abs_y), bias);
+  quotient = spu_sub(quotient, (vec_int4)bias);
+
+  /* Generate a correct final sign 
+   */
+  result = spu_sel(spu_xor(abs_x, sign), exp_special, nan_out);
+
+  quotient = spu_and(quotient, 7);
+  quotient = spu_sel(spu_sub(0, quotient), quotient, quo_pos);
+
+  *quo = spu_extract(quotient, 0);
+
+  return (spu_extract((vec_double2)result, 0));
+}
+
+#endif /* _REMQUO_H_ */
+#endif /* __SPU__ */
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/rint.h newlib-1.15.0/newlib/libm/machine/spu/headers/rint.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/rint.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/rint.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,62 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _RINT_H_
+#define _RINT_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Round the input to the nearest integer according to the current
+ * rounding mode. 
+ */
+static __inline double _rint(double x)
+{
+  vec_ullong2 sign = VEC_SPLAT_U64(0x8000000000000000ULL);
+  vec_double2 in, out, addend;
+
+  in = spu_promote(x, 0);
+
+  /* Add 2^53 and then subtract 2^53 to affect a round to be performed by the
+   * hardware. Also preserve the input sign so that negative inputs that 
+   * round to zero generate a -0.0.
+   */
+  addend = spu_sel((vec_double2)(VEC_SPLAT_U64(0x4330000000000000ULL)), in, sign);
+  out = spu_sel(spu_sub(spu_add(in, addend), addend), in, sign);
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _RINT_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/roundf.h newlib-1.15.0/newlib/libm/machine/spu/headers/roundf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/roundf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/roundf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,77 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _ROUNDF_H_
+#define _ROUNDF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Round the input to the nearest integer, rounding halfway
+ * cases away from zero.
+ */
+static __inline float _roundf(float x)
+{
+  vec_int4 exp;
+  vec_uint4 or_mask, and_mask, mask, addend;
+  vec_float4 in, out;
+
+  in = spu_promote(x, 0);
+
+  /* Add 0.5 (fixed precision to eliminate rounding issues)
+   */
+  exp = spu_sub(125, spu_and(spu_rlmask((vec_int4)in, -23), 0xFF));
+
+  addend = spu_and(spu_rlmask(VEC_SPLAT_U32(0x1000000), exp), 
+		   spu_cmpgt((vec_uint4)exp, -31));
+
+  in = (vec_float4)spu_add((vec_uint4)in, addend);
+
+  /* Truncate the result.
+   */
+  exp = spu_sub(127, spu_and(spu_rlmask((vec_int4)in, -23), 0xFF));
+
+  or_mask = spu_cmpgt(exp, 0);
+  and_mask = spu_rlmask(VEC_SPLAT_U32(0x7FFFFF), exp);
+
+  mask = spu_or(spu_and(and_mask, spu_cmpgt(exp, -31)),	or_mask);
+
+  out = spu_andc(in, (vec_float4)(mask));
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _ROUNDF_H_ */
+#endif /* __SPU__ */
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/round.h newlib-1.15.0/newlib/libm/machine/spu/headers/round.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/round.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/round.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,87 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _ROUND_H_
+#define _ROUND_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Round the input to the nearest integer, rounding halfway
+ * cases away from zero.
+ */
+static __inline double _round(double x)
+{
+  vec_uchar16 splat_hi = VEC_LITERAL(vec_uchar16, 0,1,2,3,0,1,2,3, 8,9,10,11, 8,9,10,11);
+  vec_int4 exp, shift;
+  vec_uint4 sign = VEC_LITERAL(vec_uint4, 0x80000000, 0, 0x80000000, 0);
+  vec_uint4 or_mask, and_mask, mask, addend;
+  vec_double2 in, in_hi, out;
+
+  in = spu_promote(x, 0);
+
+  /* Add 0.5 (fixed precision to eliminate rounding issues)
+   */
+  in_hi = spu_shuffle(in, in, splat_hi);
+  exp = spu_and(spu_rlmask((vec_int4)in_hi, -20), 0x7FF);
+
+  shift = spu_sub(VEC_LITERAL(vec_int4, 1022, 1043, 1022, 1043), exp);
+
+  addend = spu_and(spu_rlmask(VEC_LITERAL(vec_uint4, 0x100000, 0x80000000, 0x100000, 0x80000000), shift), 
+		   spu_cmpgt((vec_uint4)spu_add(shift, -1), -33));
+
+  in = (vec_double2)spu_addx((vec_uint4)in, addend, spu_rlqwbyte(spu_genc((vec_uint4)in, addend), 4));
+
+  /* Truncate the result.
+   */
+  in_hi = spu_shuffle(in, in, splat_hi);
+  exp = spu_and(spu_rlmask((vec_int4)in_hi, -20), 0x7FF);
+
+  shift = spu_sub(VEC_LITERAL(vec_int4, 1023, 1043, 1023, 1043), exp);
+  or_mask = spu_andc(spu_cmpgt(shift, 0), sign);
+
+
+  and_mask = spu_rlmask(VEC_LITERAL(vec_uint4, 0xFFFFF, -1, 0xFFFFF, -1), shift);
+  mask = spu_or(spu_and(and_mask, spu_cmpgt(shift, -31)), or_mask);
+
+  /* Apply the mask and return the result.
+   */
+  out = spu_andc(in, (vec_double2)(mask));
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _ROUND_H_ */
+#endif /* __SPU__ */
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/scalbnf.h newlib-1.15.0/newlib/libm/machine/spu/headers/scalbnf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/scalbnf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/scalbnf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,81 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _SCALBNF_H_
+#define _SCALBNF_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* scalbnf computes x * 2^exp. This function is computed without
+ * the assistence of any floating point operations and as such does
+ * not set any floating point exceptions.
+ */
+static __inline float _scalbnf(float x, int exp)
+{
+  vec_int4 x_exp;
+  vec_uint4 zero, overflow;
+  vec_uint4 exp_mask = VEC_SPLAT_U32(0x7F800000);
+  vec_float4 in, out;
+
+  in = spu_promote(x, 0);
+
+  /* Extract exponent from x. If the exponent is 0, then
+   * x is either 0 or a denorm and x*2^exp is a zero.
+   */
+  x_exp = spu_and(spu_rlmask((vec_int4)in, -23), 0xFF);
+
+  zero = spu_cmpeq(x_exp, 0);
+
+  /* Compute the expected exponent and determine if the 
+   * result is within range.
+   */
+  x_exp = spu_add(spu_promote(exp, 0), x_exp);
+
+  zero = spu_orc(zero, spu_cmpgt(x_exp, 0));
+  
+  overflow = spu_rlmask(spu_cmpgt(x_exp, 255), -1);
+
+  /* Merge the expect exponent with x's mantissa. Zero the
+   * result if underflow and force to max if overflow.
+   */
+  out = spu_sel(in, (vec_float4)spu_rl(x_exp, 23), exp_mask);
+  out = spu_andc(out, (vec_float4)zero);
+  out = spu_or(out, (vec_float4)overflow);
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _SCALBNF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/scalbn.h newlib-1.15.0/newlib/libm/machine/spu/headers/scalbn.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/scalbn.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/scalbn.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,87 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _SCALBN_H_
+#define _SCALBN_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* scalbn computes x * 2^exp. This function variant computes the result
+ * and handles overflow, underflow, and denorms by breaking the problem
+ * into:
+ *      exp = MAX(exp, -2044)
+ *      exp = MIN(exp,  2046)
+ *      e1 = exp / 2
+ *      e2 = exp - e1;
+ *	x * 2^e1 * 2^e2
+ */
+static __inline double _scalbn(double x, int exp)
+{
+  vec_int4 e, e1, e2;
+  vec_int4 min = VEC_SPLAT_S32(-2044);
+  vec_int4 max = VEC_SPLAT_S32(2046);
+  vec_uint4 cmp_min, cmp_max;
+  vec_uint4 shift = VEC_LITERAL(vec_uint4, 20, 32, 20, 32);
+  vec_double2 f1, f2;
+  vec_double2 in, out;
+
+  in = spu_promote(x, 0);
+  e = spu_promote(exp, 0);
+
+  /* Clamp the specified exponent to the range -2044 to 2046.
+   */
+  cmp_min = spu_cmpgt(e, min);
+  cmp_max = spu_cmpgt(e, max);
+  e = spu_sel(min, e, cmp_min);
+  e = spu_sel(e, max, cmp_max);
+
+  /* Generate the factors f1 = 2^e1 and f2 = 2^e2
+   */
+  e1 = spu_rlmaska(e, -1);
+  e2 = spu_sub(e, e1);
+
+  f1 = (vec_double2)spu_sl(spu_add(e1, 1023), shift);
+  f2 = (vec_double2)spu_sl(spu_add(e2, 1023), shift);
+
+  /* Compute the product x * 2^e1 * 2^e2
+   */
+  out = spu_mul(spu_mul(in, f1), f2);
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _SCALBN_H_ */
+#endif /* __SPU__ */
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sinf.h newlib-1.15.0/newlib/libm/machine/spu/headers/sinf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sinf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/sinf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,61 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _SINF_H_
+#define _SINF_H_		1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include "sinf_v.h"
+
+static __inline float _sinf(float angle)
+{
+#ifdef __SPU__
+  return(spu_extract(_sinf_v(spu_promote(angle, 0)), 0));
+
+#else /* !__SPU__ */
+
+  union {
+    vector float v;
+    float f[4];
+  } u;
+
+  u.f[0] = angle;
+  u.v = _sinf_v(u.v);
+
+  return (u.f[0]);
+
+#endif /* __SPU__ */
+}
+
+#endif /* _SINF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sinf_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/sinf_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sinf_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/sinf_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,118 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _SINF_V_H_
+#define _SINF_V_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include <vec_literal.h>
+
+#include "cos_sin.h"
+
+static __inline vector float _sinf_v(vector float angle)
+{
+#ifdef __SPU__
+  vec_int4   octant;
+  vec_uint4  select;
+  vec_float4 cos, sin;
+  vec_float4 toggle_sign, answer;
+
+  /* Range reduce the input angle x into the range -PI/4 to PI/4
+   * by performing simple modulus.
+   */
+  MOD_PI_OVER_FOUR_F(angle, octant);
+
+  /* Compute the cosine and sine of the range reduced input.
+   */
+  COMPUTE_COS_SIN_F(angle, cos, sin);
+
+  /* For each SIMD element, select which result (cos or sin) to use
+   * with a sign correction depending upon the octant of the original
+   * angle (Maclaurin series).
+   *
+   *   octants      angles     select  sign toggle 
+   *   -------   ------------  ------  -----------
+   *     0          0 to 45     sin        no      
+   *    1,2        45 to 135    cos        no
+   *    3,4       135 to 225    sin        yes
+   *    5,6       225 to 315    cos        yes
+   *     7        315 to 360    sin        no
+   */ 
+  toggle_sign = (vec_float4)spu_sl(spu_and(octant, 4), 29);
+  select = spu_cmpeq(spu_and(octant, 2), 0);
+
+  answer = spu_xor(spu_sel(cos, sin, select), toggle_sign);
+
+  return (answer);
+
+#else	/* !__SPU__ */
+
+  vector float cos, sin;
+  vector float toggle_sign, answer;
+  vector bool int select;
+  vector signed int octant;
+  vector signed int two = VEC_SPLAT_S32(2);
+  
+  /* Range reduce the input angle x into the range -PI/4 to PI/4
+   * by performing simple modulus.
+   */
+  MOD_PI_OVER_FOUR_F(angle, octant);
+
+  /* Compute the cosine and sine of the range reduced input.
+   */
+  COMPUTE_COS_SIN_F(angle, cos, sin);
+
+
+  /* For each SIMD element, select which result (cos or sin) to use
+   * with a sign correction depending upon the octant of the original
+   * angle (Maclaurin series).
+   *
+   *   octants       angles    select  sign toggle 
+   *   -------   ------------   ------  -----------
+   *     0          0 to 45     sin        no      
+   *    1,2        45 to 135    cos        no
+   *    3,4       135 to 225    sin        yes
+   *    5,6       225 to 315    cos        yes
+   *     7        315 to 360    sin        no
+   */ 
+  toggle_sign = (vector float)vec_sl(vec_and(octant, VEC_SPLAT_S32(4)), VEC_SPLAT_U32(29));
+  select = vec_cmpeq(vec_and(octant, two), VEC_SPLAT_S32(0));
+  answer = vec_xor(vec_sel(cos, sin, select), toggle_sign);;
+
+  return (answer);
+
+#endif	/* __SPU__ */
+}
+
+#endif /* _SINF_V_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sin.h newlib-1.15.0/newlib/libm/machine/spu/headers/sin.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sin.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/sin.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,44 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _SIN_H_
+#define _SIN_H_		1
+
+#include <spu_intrinsics.h>
+#include "sin_v.h"
+
+static __inline double _sin(double x)
+{
+  return (spu_extract(_sin_v(spu_promote(x, 0)), 0));
+}
+
+#endif /* _SIN_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sin_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/sin_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sin_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/sin_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,80 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _SIN_V_H_
+#define _SIN_V_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+#include "cos_sin.h"
+
+static __inline vector double _sin_v(vector double angle)
+{
+  vec_int4    octant;
+  vec_ullong2 select;
+  vec_double2 cos, sin;
+  vec_double2 toggle_sign, answer;
+
+  /* Range reduce the input angle x into the range -PI/4 to PI/4
+   * by performing simple modulus.
+   */
+  MOD_PI_OVER_FOUR(angle, octant);
+
+  /* Compute the cosine and sine of the range reduced input.
+   */
+  COMPUTE_COS_SIN(angle, cos, sin);
+
+  /* For each SIMD element, select which result (cos or sin) to use
+   * with a sign correction depending upon the octant of the original
+   * angle (Maclaurin series).
+   *
+   *   octants      angles     select  sign toggle 
+   *   -------   ------------  ------  -----------
+   *     0          0 to 45     sin        no      
+   *    1,2        45 to 135    cos        no
+   *    3,4       135 to 225    sin        yes
+   *    5,6       225 to 315    sin        yes
+   *     7        315 to 360    cos        no
+   */ 
+  octant = spu_shuffle(octant, octant, VEC_LITERAL(vec_uchar16,
+						   0,1, 2, 3, 0,1, 2, 3,
+						   8,9,10,11, 8,9,10,11));
+
+  toggle_sign = (vec_double2)spu_sl(spu_and(octant, 4), VEC_LITERAL(vec_uint4, 29,32,29,32));
+  select = (vec_ullong2)spu_cmpeq(spu_and(octant, 2), 0);
+
+  answer = spu_xor(spu_sel(cos, sin, select), toggle_sign);
+
+  return (answer);
+}
+
+#endif /* _SIN_V_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sqrtf.h newlib-1.15.0/newlib/libm/machine/spu/headers/sqrtf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sqrtf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/sqrtf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,74 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _SQRTF_H_
+#define _SQRTF_H_	1
+
+/*
+ * FUNCTION
+ *	float _sqrtf(float value)
+ *
+ * DESCRIPTION
+ *	_sqrtf computes the square root of the input "value" and returns the
+ *      result. By noting that sqrt(x) = x / sqrt(x), computation can
+ *      exploit the floating-point reciprocal square root estimate and 
+ *      interpolate instructions. One iteration of a Newton-Raphson
+ *	is performed to improve accuracy to a single precision floating
+ *      point. See inv_sqrt for more details.
+ */
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+#include "sqrtf_v.h"
+
+static __inline float _sqrtf(float value)
+{
+#ifdef __SPU__
+  vec_float4 in, out;
+
+  in = spu_promote(value, 0);
+  out = _sqrtf_v(in);
+  return (spu_extract(out, 0));
+#else /* VMX */
+  union {
+    vector float fv;
+    float f[4];
+  } in, out;
+
+  in.f[0] = value;
+  out.fv = _sqrtf_v(in.fv);
+  return (out.f[0]);
+#endif
+}
+
+#endif /* _SQRTF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sqrtf_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/sqrtf_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sqrtf_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/sqrtf_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,161 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _SQRTF_V_H_
+#define _SQRTF_V_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include <vec_literal.h>
+
+/*
+ * FUNCTION
+ *	vector float _sqrtf_v(vector float in)
+ *
+ * DESCRIPTION
+ *	_sqrtf_v computes the square root of the vector input "in" 
+ *	and returns the result. The SPU versio supports two 
+ *      implementations.
+ *	(1) a fully compliant IEEE implementation to guarantee the 
+ *          correct truncated result for all valid inputs.
+ *      (2) A fast version that is up to 3 ulp (units of least
+ *          position off). Over the input range 1.0 to 3.9999...
+ *          this implementation has a histogram of error of:
+ *           ulp error   count
+ *           =========   =====
+ *		 -3      0
+ *		 -2      68
+ *		 -1      384895
+ *		  0      5985155
+ *		  1      8611186
+ *		  2      1752588
+ *		  3      43324
+ *
+ *	The VMX implementation computes the square root by noting 
+ *      that sqrtf(x) = x / sqrtf(x). However, it does not produce 
+ * 	IEEE accuracy.
+ */
+
+static __inline vector float _sqrtf_v(vector float in) 
+{
+#ifdef __SPU__
+#ifdef IEEE_ACCURATE_SQRTF
+  vec_uint4 exp, valid;
+  vec_uint4 mask = VEC_SPLAT_U32(0xFF000000);
+  vec_uint4 half = VEC_SPLAT_U32(0x00800000);
+  vec_float4 one = VEC_SPLAT_F32(1.0f);
+  vec_float4 three = VEC_SPLAT_F32(3.0f);
+  vec_float4 x, y0, y1, y1_n1, y1_p1, y1_p2, y1_p3;
+  vec_float4 mant, err, err_p1, err_p2, err_p3;
+  vec_float4 out;
+
+  /* Compute the mantissa of the result seperately from 
+   * the exponent to assure complete accuracy over the allowable
+   * input range. The mantissa is computed for inputs in the 
+   * range [0.5, 2.0).
+   */
+  x = spu_sel(in, one, mask);
+  y0 = spu_rsqrte(x);
+  
+  /* Perform one iteration of the Newton-Raphsom method in single precision
+   * arithmetic.
+   */
+  y1 = spu_mul(spu_nmsub(x, spu_mul(y0, y0), three), 
+	       spu_mul(y0, (vec_float4)(spu_sub((vec_uint4)(x), half))));
+
+  /* Correct the result for possible error. The range of error is -3 to +1.
+   * Identify the extent of the error and correct for it.
+   */
+  y1_p3 = (vec_float4)spu_add((vec_uint4)(y1), 3);
+  y1_p2 = (vec_float4)spu_add((vec_uint4)(y1), 2);
+  y1_p1 = (vec_float4)spu_add((vec_uint4)(y1), 1);
+  y1_n1 = (vec_float4)spu_add((vec_uint4)(y1), -1);
+
+  err    = spu_nmsub(y1,    y1,    x);
+  err_p1 = spu_nmsub(y1_p1, y1_p1, x);
+  err_p2 = spu_nmsub(y1_p2, y1_p2, x);
+  err_p3 = spu_nmsub(y1_p3, y1_p3, x);
+
+  mant = spu_sel(y1_n1, y1,    spu_cmpgt((vec_int4)(err),    -1));
+  mant = spu_sel(mant,  y1_p1, spu_cmpgt((vec_int4)(err_p1), -1));
+  mant = spu_sel(mant,  y1_p2, spu_cmpgt((vec_int4)(err_p2), -1));
+  mant = spu_sel(mant,  y1_p3, spu_cmpgt((vec_int4)(err_p3), -1));
+
+  /* Compute the expected exponent. If the exponent is zero or the input is
+   * negative, then set the result to zero.
+   */
+  exp = spu_rlmask(spu_add((vec_uint4)(in), (vec_uint4)(one)), -1);
+
+  valid = spu_cmpgt(spu_and((vec_int4)(in), (vec_int4)(mask)), 0);
+    
+  /* Merge the computed exponent and mantissa.
+   */
+  out = spu_and(spu_sel(mant, (vec_float4)(exp), VEC_SPLAT_U32(0xFF800000)), (vec_float4)(valid));
+
+#else /* FAST */
+
+  vec_float4 y0, out;
+  
+  /* Perform one iteration of the Newton-Raphsom method in single precision
+   * arithmetic.
+   */
+  y0 = spu_rsqrte(in);
+  out = spu_mul(spu_nmsub(in, spu_mul(y0, y0), (vec_float4)(VEC_SPLAT_U32(0x40400001))), 
+		spu_mul(y0, spu_mul(in, VEC_SPLAT_F32(0.5f))));
+
+  out = spu_andc(out, (vec_float4)spu_cmpeq(in, VEC_SPLAT_F32(0.0f)));
+
+#endif /* IEEE_ACCUARTE_SQRTF */
+
+  return (out);
+
+#else	/* VMX */
+
+  vector float y0, out;
+  vector float zero = VEC_SPLAT_F32(0.0f);
+  
+  /* Perform one iteration of the Newton-Raphsom method in single precision
+   * arithmetic.
+   */
+  y0 = vec_rsqrte(in);
+  out = vec_madd(vec_nmsub(in, vec_madd(y0, y0, zero), (vector float)(VEC_SPLAT_U32(0x40400001))), 
+		 vec_madd(y0, vec_madd(in, VEC_SPLAT_F32(0.5f), zero), zero),
+		 zero);
+  out = vec_and(out, (vector float)vec_cmpgt(in, (vector float)(VEC_SPLAT_U32(0x007FFFFF))));
+
+  return (out);
+#endif
+}
+
+#endif /* _SQRTF_V_H_ */
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sqrt.h newlib-1.15.0/newlib/libm/machine/spu/headers/sqrt.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/sqrt.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/sqrt.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,135 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _SQRT_H_
+#define _SQRT_H_	1
+
+/*
+ * FUNCTION
+ *	double _sqrt(double in)
+ *
+ * DESCRIPTION
+ *	_sqrt computes the square root of the input "in" and returns the
+ *      result. 
+ */
+
+#ifdef __SPU__
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+static __inline double _sqrt(double in)
+{
+  vec_int4 bias_exp;
+  vec_uint4 exp;
+  vec_float4 fx, fg, fy, fd, fe, fy2, fhalf;
+  vec_ullong2 nochange;
+  vec_ullong2 mask = VEC_SPLAT_U64(0x7FE0000000000000ULL);
+  vec_double2 x, dx, de, dd, dy, dg, dy2, dhalf;
+  vec_double2 denorm, neg;
+
+  fhalf = VEC_SPLAT_F32(0.5f);
+  dhalf = VEC_SPLAT_F64(0.5);
+
+  /* Coerce the input, in, into the argument reduced space [0.5, 2.0).
+   */
+  x = spu_promote(in, 0);
+  dx = spu_sel(x, dhalf, mask);
+
+  /* Compute an initial single precision guess for the square root (fg)
+   * and half reciprocal (fy2).
+   */
+  fx = spu_roundtf(dx);
+
+  fy2 = spu_rsqrte(fx);
+  fy = spu_mul(fy2, fhalf);
+  fg = spu_mul(fy2, fx);	/* 12-bit approximation to sqrt(cx) */
+  
+  /* Perform one single precision Newton-Raphson iteration to improve 
+   * accuracy to about 22 bits.
+   */
+  fe = spu_nmsub(fy, fg, fhalf);
+  fd = spu_nmsub(fg, fg, fx);
+
+  fy = spu_madd(fy2, fe, fy);
+  fg = spu_madd(fy, fd, fg);	/* 22-bit approximation */
+
+  dy = spu_extend(fy);
+  dg = spu_extend(fg);
+
+  /* Perform two double precision Newton-Raphson iteration to improve 
+   * accuracy to about 44 and 88 bits repectively.
+   */
+  dy2 = spu_add(dy, dy);
+  de = spu_nmsub(dy, dg, dhalf);
+  dd = spu_nmsub(dg, dg, dx);
+  dy = spu_madd(dy2, de, dy);
+  dg = spu_madd(dy, dd, dg);	/* 44 bit approximation */
+
+  dd = spu_nmsub(dg, dg, dx);
+  dg = spu_madd(dy, dd, dg);	/* full double precision approximation */
+
+
+  /* Compute the expected exponent assuming that it is not a special value.
+   * See special value handling below.
+   */
+  bias_exp = spu_rlmaska(spu_sub((vec_int4)spu_and((vec_ullong2)x, mask), 
+				 (vec_int4)VEC_SPLAT_U64(0x3FE0000000000000ULL)),
+			 -1);
+  dg = (vec_double2)spu_add((vec_int4)dg, bias_exp);
+
+
+  /* Handle special inputs. These include:
+   *
+   *   input 		 output
+   * =========		=========
+   *    -0		  -0
+   * +infinity 		+infinity
+   *    NaN		  NaN
+   *    <0		  NaN
+   *   denorm		  zero
+   */
+  exp = (vec_uint4)spu_and((vec_ullong2)x, VEC_SPLAT_U64(0xFFF0000000000000ULL));
+  exp = spu_shuffle(exp, exp, VEC_LITERAL(vec_uchar16, 0,1,2,3,0,1,2,3, 8,9,10,11,8,9,10,11));
+
+  neg = (vec_double2)spu_rlmaska((vec_int4)exp, -31);
+  denorm = (vec_double2)spu_rlmask(spu_cmpeq(spu_sl(exp, 1), 0), VEC_LITERAL(vec_int4, -1,0,-1,0));
+
+  nochange = (vec_ullong2)spu_cmpeq(exp, 0x7FF00000);
+
+  dg = spu_sel(spu_andc(spu_or(dg, neg), denorm), x, nochange);
+
+  return (spu_extract(dg, 0));
+}
+#endif /* __SPU__ */
+
+#endif /* _SQRT_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/tanf.h newlib-1.15.0/newlib/libm/machine/spu/headers/tanf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/tanf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/tanf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,71 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _TANF_H_
+#define _TANF_H_		1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+#include "tanf_v.h"
+
+/*
+ * FUNCTION
+ *	float _tanf(float angle)
+ *
+ * DESCRIPTION
+ *	_tanf computes the tangent of "angle" (expressed in radians)
+ *      to an accuracy of single precision floating point.
+ */
+
+static __inline float _tanf(float angle)
+{
+#ifdef __SPU__
+  return (spu_extract(_tanf_v(spu_promote(angle, 0)), 0));
+
+#else /* !__SPU__ */
+
+  union {
+    vector float v;
+    float f[4];
+  } u;
+
+  u.f[0] = angle;
+  u.v = _tanf_v(u.v);
+
+  return (u.f[0]);
+
+#endif /* __SPU__ */
+}
+
+#endif /* _TANF_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/tanf_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/tanf_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/tanf_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/tanf_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,136 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _TANF_V_H_
+#define _TANF_V_H_	1
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+#include <vec_literal.h>
+
+#include "cos_sin.h"
+#include "divide_v.h"
+
+/*
+ * FUNCTION
+ *	vector float _tanf_v(vector float angle)
+ *
+ * DESCRIPTION
+ *	_tanf_v computes the tangent of a vector of "angle"s (expressed 
+ *	in radians) to an accuracy of single precision floating point.
+ */
+
+static __inline vector float _tanf_v(vector float angle)
+{
+#ifdef __SPU__
+  vec_int4   octant;
+  vec_uint4  select;
+  vec_float4 cos, sin;
+  vec_float4 num, den;
+  vec_float4 toggle_sign, answer;
+
+  /* Range reduce the input angle x into the range -PI/4 to PI/4
+   * by performing simple modulus.
+   */
+  MOD_PI_OVER_FOUR_F(angle, octant);
+
+  /* Compute the cosine and sine of the range reduced input.
+   */
+  COMPUTE_COS_SIN_F(angle, cos, sin);
+
+  /* For each SIMD element, select the numerator, denominator, and sign
+   * correction depending upon the octant of the original angle.
+   *
+   *   octants      angles     numerator denominator sign toggle 
+   *   -------   ------------  --------- ----------- -----------
+   *     0          0 to 45      sin        cos          no      
+   *    1,2        45 to 135     cos        sin         no,yes
+   *    3,4       135 to 225     sin        cos         yes,no
+   *    5,6       225 to 315     cos        sin         no,yes
+   *     7        315 to 360     sin        cos          yes
+   */ 
+  toggle_sign = (vec_float4)spu_sl(spu_and(octant, 2), 30);
+
+  select = spu_cmpeq(spu_and(octant, 2), 0);
+  num = spu_sel(cos, sin, select);
+  den = spu_sel(sin, cos, select);
+
+  answer = spu_xor(_divide_v(num, den), toggle_sign);
+
+  return (answer);
+  
+#else	/* !__SPU__ */
+
+  vector signed int octant_and_2;
+  vector signed int octant;
+  vector bool int select;
+  vector float cos, sin;
+  vector float num, den;
+  vector float toggle_sign, answer;
+
+  /* Range reduce the input angle x into the range -PI/4 to PI/4
+   * by performing simple modulus.
+   */
+  MOD_PI_OVER_FOUR_F(angle, octant);
+
+  /* Compute the cosine and sine of the range reduced input.
+   */
+  COMPUTE_COS_SIN_F(angle, cos, sin);
+
+  /* For each SIMD element, select the numerator, denominator, and sign
+   * correction depending upon the octant of the original angle.
+   *
+   *   octants      angles     numerator denominator sign toggle 
+   *   -------   ------------  --------- ----------- -----------
+   *     0          0 to 45      sin        cos          no      
+   *    1,2        45 to 135     cos        sin         no,yes
+   *    3,4       135 to 225     sin        cos         yes,no
+   *    5,6       225 to 315     cos        sin         no,yes
+   *     7        315 to 360     sin        cos          yes
+   */ 
+  octant_and_2 = vec_and(octant, VEC_SPLAT_S32(2));
+
+  toggle_sign = (vector float)vec_sl(octant_and_2, VEC_SPLAT_U32(30));
+
+  select = vec_cmpeq(octant_and_2, VEC_SPLAT_S32(0));
+  num = vec_sel(cos, sin, select);
+  den = vec_sel(sin, cos, select);
+
+  answer = vec_xor(_divide_v(num, den), toggle_sign);
+
+  return (answer);
+  
+#endif /* __SPU__ */
+}
+
+#endif /* _TANF_V_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/tan.h newlib-1.15.0/newlib/libm/machine/spu/headers/tan.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/tan.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/tan.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,44 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _TAN_H_
+#define _TAN_H_		1
+
+#include <spu_intrinsics.h>
+#include "tan_v.h"
+
+static __inline double _tan(double angle)
+{
+  return (spu_extract(_tan_v(spu_promote(angle, 0)), 0));
+}
+
+#endif /* _TAN_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/tan_v.h newlib-1.15.0/newlib/libm/machine/spu/headers/tan_v.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/tan_v.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/tan_v.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,95 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _TAN_V_H_
+#define _TAN_V_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+#include "cos_sin.h"
+#include "divide_dv.h"
+
+/*
+ * FUNCTION
+ *	vector double _tan_v(vector double angle)
+ *
+ * DESCRIPTION
+ *	_tan_v computes the tangent of a vector of "angle"s (expressed 
+ *	in radians) to an accuracy of double precision floating point.
+ */
+
+static __inline vector double _tan_v(vector double angle)
+{
+  vec_int4    octant;
+  vec_ullong2 select;
+  vec_double2 cos, sin;
+  vec_double2 num, den;
+  vec_double2 toggle_sign, answer;
+
+  /* Range reduce the input angle x into the range -PI/4 to PI/4
+   * by performing simple modulus.
+   */
+  MOD_PI_OVER_FOUR(angle, octant);
+
+  /* Compute the cosine and sine of the range reduced input.
+   */
+  COMPUTE_COS_SIN(angle, cos, sin);
+
+  /* For each SIMD element, select the numerator, denominator, and sign
+   * correction depending upon the octant of the original angle.
+   *
+   *   octants      angles     numerator denominator sign toggle 
+   *   -------   ------------  --------- ----------- -----------
+   *     0          0 to 45      sin        cos          no      
+   *    1,2        45 to 135     cos        sin         no,yes
+   *    3,4       135 to 225     sin        cos         yes,no
+   *    5,6       225 to 315     cos        sin         no,yes
+   *     7        315 to 360     sin        cos          yes
+   */ 
+  octant = spu_shuffle(octant, octant, VEC_LITERAL(vec_uchar16,
+						   0,1, 2, 3, 0,1, 2, 3,
+						   8,9,10,11, 8,9,10,11));
+
+  toggle_sign = spu_and((vec_double2)spu_sl(octant, 30),
+    (vec_double2)VEC_LITERAL(vec_ullong2, 0x8000000000000000LL, 0x8000000000000000LL));
+
+  select = (vec_ullong2)spu_cmpeq(spu_and(octant, 2), 0);
+  num = spu_sel(cos, sin, select);
+  den = spu_sel(sin, cos, select);
+
+  answer = spu_xor(_divide_dv(num, den), toggle_sign);
+
+  return (answer);
+}
+
+#endif /* _TAN_V_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/truncf.h newlib-1.15.0/newlib/libm/machine/spu/headers/truncf.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/truncf.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/truncf.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,71 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _TRUNCF_H_
+#define _TRUNCF_H_	1
+
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+
+static __inline float _truncf(float x)
+{
+  vec_int4 exp;
+  vec_uint4 or_mask, and_mask, mask;
+  vec_float4 in, out;
+
+  in = spu_promote(x, 0);
+
+  /* Construct a mask to remove the fraction bits. The mask
+   * depends on the exponent of the floating point
+   * input value.
+   */
+  exp = spu_sub(127, spu_and(spu_rlmask((vec_int4)in, -23), 0xFF));
+
+  or_mask = spu_cmpgt(exp, 0);
+  and_mask = spu_rlmask(VEC_SPLAT_U32(0x7FFFFF), exp);
+
+  mask = spu_or(spu_and(and_mask, spu_cmpgt(exp, -31)),	or_mask);
+
+  /* Apply the mask and return the result.
+   */
+  out = spu_andc(in, (vec_float4)(mask));
+
+  return (spu_extract(out, 0));
+}
+
+
+#endif /* _TRUNCF_H_ */
+#endif /* __SPU__ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/trunc.h newlib-1.15.0/newlib/libm/machine/spu/headers/trunc.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/trunc.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/trunc.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,76 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __SPU__
+
+#ifndef _TRUNC_H_
+#define _TRUNC_H_	1
+
+#include <spu_intrinsics.h>
+#include <vec_literal.h>
+
+/* Truncate the input downwards to the nearest integer.
+ */
+static __inline double _trunc(double x)
+{
+  vec_uchar16 splat_hi = VEC_LITERAL(vec_uchar16, 0,1,2,3,0,1,2,3, 8,9,10,11, 8,9,10,11);
+  vec_int4 exp, shift;
+  vec_uint4 sign = VEC_LITERAL(vec_uint4, 0x80000000, 0, 0x80000000, 0);
+  vec_uint4 or_mask, and_mask, mask;
+  vec_double2 in, in_hi, out;
+
+  in = spu_promote(x, 0);
+
+  /* Construct a mask to remove the fraction bits. The mask
+   * depends on the exponent of the floating point
+   * input value.
+   */
+  in_hi = spu_shuffle(in, in, splat_hi);
+  exp = spu_and(spu_rlmask((vec_int4)in_hi, -20), 0x7FF);
+
+  shift = spu_sub(VEC_LITERAL(vec_int4, 1023, 1043, 1023, 1043), exp);
+  or_mask = spu_andc(spu_cmpgt(shift, 0), sign);
+
+  and_mask = spu_rlmask(VEC_LITERAL(vec_uint4, 0xFFFFF, -1, 0xFFFFF, -1), shift);
+  mask = spu_or(spu_and(and_mask, spu_cmpgt(shift, -31)), or_mask);
+
+  /* Apply the mask and return the result.
+   */
+  out = spu_andc(in, (vec_double2)(mask));
+
+  return (spu_extract(out, 0));
+}
+
+#endif /* _TRUNC_H_ */
+#endif /* __SPU__ */
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/headers/vec_literal.h newlib-1.15.0/newlib/libm/machine/spu/headers/vec_literal.h
--- orig.newlib-1.15.0/newlib/libm/machine/spu/headers/vec_literal.h	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/headers/vec_literal.h	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,96 @@
+/*
+  (C) Copyright 2001,2006,
+  International Business Machines Corporation,
+  Sony Computer Entertainment, Incorporated,
+  Toshiba Corporation,
+
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+    * Neither the names of the copyright holders nor the names of their
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _VEC_LITERAL_H_
+#define _VEC_LITERAL_H_
+
+/* This header files provides an abstraction for the various implementations
+ * of vector literal construction. The two formats are:
+ *
+ * 1) Altivec styled using parenthesis
+ * 2) C grammer friendly styled using curly braces
+ *
+ * The macro, VEC_LITERAL has been developed to provide some portability
+ * in these two styles. To achieve true portability, user must specify all
+ * elements of the vector being initialized. A single element can be provided
+ * but only the first element guarenteed across both construction styles.
+ *
+ * The VEC_SPLAT_* macros have been provided for portability of vector literal
+ * construction when all the elements of the vector contain the same value.
+ */
+
+#ifdef __SPU__
+#include <spu_intrinsics.h>
+#endif
+
+
+#ifdef __ALTIVEC_LITERAL_STYLE__
+/* Use altivec style.
+ */
+#define VEC_LITERAL(_type, ...)	((_type)(__VA_ARGS__))
+
+#define VEC_SPLAT_U8(_val)	((vector unsigned char)(_val))
+#define VEC_SPLAT_S8(_val)	((vector signed char)(_val))
+
+#define VEC_SPLAT_U16(_val)	((vector unsigned short)(_val))
+#define VEC_SPLAT_S16(_val)	((vector signed short)(_val))
+
+#define VEC_SPLAT_U32(_val)	((vector unsigned int)(_val))
+#define VEC_SPLAT_S32(_val)	((vector signed int)(_val))
+#define VEC_SPLAT_F32(_val)	((vector float)(_val))
+
+#define VEC_SPLAT_U64(_val)	((vector unsigned long long)(_val))
+#define VEC_SPLAT_S64(_val)	((vector signed long long)(_val))
+#define VEC_SPLAT_F64(_val)	((vector double)(_val))
+
+#else
+/* Use curly brace style.
+ */
+#define VEC_LITERAL(_type, ...)	((_type){__VA_ARGS__})
+
+#define VEC_SPLAT_U8(_val)	((vector unsigned char){_val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val})
+#define VEC_SPLAT_S8(_val)	((vector signed char){_val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val, _val})
+
+#define VEC_SPLAT_U16(_val)	((vector unsigned short){_val, _val, _val, _val, _val, _val, _val, _val})
+#define VEC_SPLAT_S16(_val)	((vector signed short){_val, _val, _val, _val, _val, _val, _val, _val})
+
+#define VEC_SPLAT_U32(_val)	((vector unsigned int){_val, _val, _val, _val})
+#define VEC_SPLAT_S32(_val)	((vector signed int){_val, _val, _val, _val})
+#define VEC_SPLAT_F32(_val)	((vector float){_val, _val, _val, _val})
+
+#define VEC_SPLAT_U64(_val)	((vector unsigned long long){_val, _val})
+#define VEC_SPLAT_S64(_val)	((vector signed long long){_val, _val})
+#define VEC_SPLAT_F64(_val)	((vector double){_val, _val})
+
+#endif
+
+#endif /* _VEC_LITERAL_H_ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/llrint.c newlib-1.15.0/newlib/libm/machine/spu/llrint.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/llrint.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/llrint.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/llrint.h"
+
+long long int llrint(double x)
+{
+    return _llrint(x);
+}
+long long int llrintl(long double) __attribute__ ((strong, alias ("llrint")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/llrintf.c newlib-1.15.0/newlib/libm/machine/spu/llrintf.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/llrintf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/llrintf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/llrintf.h"
+
+long long int llrintf(float x)
+{
+    return _llrintf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/llround.c newlib-1.15.0/newlib/libm/machine/spu/llround.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/llround.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/llround.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/llround.h"
+
+long long int llround(double x)
+{
+    return _llround(x);
+}
+long long int llroundl(long double) __attribute__ ((strong, alias ("llround")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/llroundf.c newlib-1.15.0/newlib/libm/machine/spu/llroundf.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/llroundf.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/llroundf.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/llroundf.h"
+
+long long int llroundf(float x)
+{
+    return _llroundf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/log2.c newlib-1.15.0/newlib/libm/machine/spu/log2.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/log2.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/log2.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/log2.h"
+
+double log2(double x)
+{
+    return _log2(x);
+}
+long double log2l(long double x) __attribute__ ((strong, alias ("log2")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/log2f.c newlib-1.15.0/newlib/libm/machine/spu/log2f.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/log2f.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/log2f.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/log2f.h"
+
+float log2f(float x)
+{
+    return _log2f(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/Makefile.am newlib-1.15.0/newlib/libm/machine/spu/Makefile.am
--- orig.newlib-1.15.0/newlib/libm/machine/spu/Makefile.am	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/Makefile.am	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,36 @@
+## Process this file with automake to generate Makefile.in
+
+AUTOMAKE_OPTIONS = cygnus
+
+INCLUDES = -I $(newlib_basedir)/../newlib/libm/common $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I $(newlib_basedir)/../newlib/libm/machine/spu/headers
+
+# add headers XXX
+
+LIB_SOURCES = \
+	llrint.c llrintf.c llround.c llroundf.c log2.c log2f.c s_cbrt.c \
+	s_ceil.c s_copysign.c s_cos.c s_fabs.c sf_atan.c sf_cbrt.c \
+	sf_ceil.c sf_copysign.c sf_cos.c s_fdim.c sf_fabs.c sf_fdim.c \
+	sf_floor.c sf_fma.c sf_fmax.c sf_fmin.c sf_frexp.c sf_ilogb.c \
+	sf_ldexp.c s_floor.c sf_lrint.c sf_lround.c sf_nearbyint.c s_fma.c \
+	s_fmax.c s_fmin.c sf_remquo.c sf_rint.c s_frexp.c sf_round.c \
+	sf_scalbln.c sf_scalbn.c sf_sin.c sf_tan.c sf_trunc.c s_ilogb.c \
+	s_ldexp.c s_lrint.c s_lround.c s_nearbyint.c s_remquo.c s_rint.c \
+	s_round.c s_scalbn.c s_sin.c s_tan.c s_trunc.c w_exp2.c w_exp.c \
+	wf_acos.c wf_asin.c wf_exp2.c wf_exp.c wf_fmod.c wf_log10.c \
+	wf_log.c w_fmod.c wf_pow.c wf_remainder.c wf_sqrt.c w_log10.c \
+	w_log.c w_pow.c w_remainder.c w_sqrt.c \
+	feclearexcept.c fegetround.c fesetenv.c fetestexcept.c fegetenv.c \
+ 	feholdexcept.c fesetexceptflag.c feupdateenv.c fegetexceptflag.c \
+ 	feraiseexcept.c fesetround.c fe_dfl_env.c \
+	cbrt_factors.c
+
+noinst_LIBRARIES = lib.a
+lib_a_SOURCES = $(LIB_SOURCES)
+lib_a_CFLAGS = $(AM_CFLAGS)
+lib_a_CCASFLAGS = $(AM_CCASFLAGS)
+noinst_DATA =
+
+include $(srcdir)/../../../Makefile.shared
+
+ACLOCAL_AMFLAGS = -I ../../..
+CONFIG_STATUS_DEPENDENCIES = $(newlib_basedir)/configure.host
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/Makefile.in newlib-1.15.0/newlib/libm/machine/spu/Makefile.in
--- orig.newlib-1.15.0/newlib/libm/machine/spu/Makefile.in	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/Makefile.in	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,1009 @@
+# Makefile.in generated by automake 1.9.5 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+SOURCES = $(lib_a_SOURCES)
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = .
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+DIST_COMMON = $(srcdir)/../../../Makefile.shared \
+	$(srcdir)/../../../../config.guess \
+	$(srcdir)/../../../../config.sub $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/configure \
+	$(am__configure_deps) $(srcdir)/../../../../mkinstalldirs \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile $(srcdir)/../../../../compile \
+	$(srcdir)/../../../../compile
+subdir = .
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../../../acinclude.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno configure.status.lineno
+mkinstalldirs = $(SHELL) $(top_srcdir)/../../../../mkinstalldirs
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+lib_a_AR = $(AR) $(ARFLAGS)
+lib_a_LIBADD =
+am__objects_1 = lib_a-llrint.$(OBJEXT) lib_a-llrintf.$(OBJEXT) \
+	lib_a-llround.$(OBJEXT) lib_a-llroundf.$(OBJEXT) \
+	lib_a-log2.$(OBJEXT) lib_a-log2f.$(OBJEXT) \
+	lib_a-s_cbrt.$(OBJEXT) lib_a-s_ceil.$(OBJEXT) \
+	lib_a-s_copysign.$(OBJEXT) lib_a-s_cos.$(OBJEXT) \
+	lib_a-s_fabs.$(OBJEXT) lib_a-sf_atan.$(OBJEXT) \
+	lib_a-sf_cbrt.$(OBJEXT) lib_a-sf_ceil.$(OBJEXT) \
+	lib_a-sf_copysign.$(OBJEXT) lib_a-sf_cos.$(OBJEXT) \
+	lib_a-s_fdim.$(OBJEXT) lib_a-sf_fabs.$(OBJEXT) \
+	lib_a-sf_fdim.$(OBJEXT) lib_a-sf_floor.$(OBJEXT) \
+	lib_a-sf_fma.$(OBJEXT) lib_a-sf_fmax.$(OBJEXT) \
+	lib_a-sf_fmin.$(OBJEXT) lib_a-sf_frexp.$(OBJEXT) \
+	lib_a-sf_ilogb.$(OBJEXT) lib_a-sf_ldexp.$(OBJEXT) \
+	lib_a-s_floor.$(OBJEXT) lib_a-sf_lrint.$(OBJEXT) \
+	lib_a-sf_lround.$(OBJEXT) lib_a-sf_nearbyint.$(OBJEXT) \
+	lib_a-s_fma.$(OBJEXT) lib_a-s_fmax.$(OBJEXT) \
+	lib_a-s_fmin.$(OBJEXT) lib_a-sf_remquo.$(OBJEXT) \
+	lib_a-sf_rint.$(OBJEXT) lib_a-s_frexp.$(OBJEXT) \
+	lib_a-sf_round.$(OBJEXT) lib_a-sf_scalbln.$(OBJEXT) \
+	lib_a-sf_scalbn.$(OBJEXT) lib_a-sf_sin.$(OBJEXT) \
+	lib_a-sf_tan.$(OBJEXT) lib_a-sf_trunc.$(OBJEXT) \
+	lib_a-s_ilogb.$(OBJEXT) lib_a-s_ldexp.$(OBJEXT) \
+	lib_a-s_lrint.$(OBJEXT) lib_a-s_lround.$(OBJEXT) \
+	lib_a-s_nearbyint.$(OBJEXT) lib_a-s_remquo.$(OBJEXT) \
+	lib_a-s_rint.$(OBJEXT) lib_a-s_round.$(OBJEXT) \
+	lib_a-s_scalbn.$(OBJEXT) lib_a-s_sin.$(OBJEXT) \
+	lib_a-s_tan.$(OBJEXT) lib_a-s_trunc.$(OBJEXT) \
+	lib_a-w_exp2.$(OBJEXT) lib_a-w_exp.$(OBJEXT) \
+	lib_a-wf_acos.$(OBJEXT) lib_a-wf_asin.$(OBJEXT) \
+	lib_a-wf_exp2.$(OBJEXT) lib_a-wf_exp.$(OBJEXT) \
+	lib_a-wf_fmod.$(OBJEXT) lib_a-wf_log10.$(OBJEXT) \
+	lib_a-wf_log.$(OBJEXT) lib_a-w_fmod.$(OBJEXT) \
+	lib_a-wf_pow.$(OBJEXT) lib_a-wf_remainder.$(OBJEXT) \
+	lib_a-wf_sqrt.$(OBJEXT) lib_a-w_log10.$(OBJEXT) \
+	lib_a-w_log.$(OBJEXT) lib_a-w_pow.$(OBJEXT) \
+	lib_a-w_remainder.$(OBJEXT) lib_a-w_sqrt.$(OBJEXT) \
+	lib_a-feclearexcept.$(OBJEXT) lib_a-fegetround.$(OBJEXT) \
+	lib_a-fesetenv.$(OBJEXT) lib_a-fetestexcept.$(OBJEXT) \
+	lib_a-fegetenv.$(OBJEXT) lib_a-feholdexcept.$(OBJEXT) \
+	lib_a-fesetexceptflag.$(OBJEXT) lib_a-feupdateenv.$(OBJEXT) \
+	lib_a-fegetexceptflag.$(OBJEXT) lib_a-feraiseexcept.$(OBJEXT) \
+	lib_a-fesetround.$(OBJEXT) lib_a-fe_dfl_env.$(OBJEXT) \
+	lib_a-cbrt_factors.$(OBJEXT)
+am_lib_a_OBJECTS = $(am__objects_1)
+lib_a_OBJECTS = $(am_lib_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(lib_a_SOURCES)
+DATA = $(noinst_DATA)
+ETAGS = etags
+CTAGS = ctags
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCAS = @CCAS@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+ELIX_LEVEL_0_FALSE = @ELIX_LEVEL_0_FALSE@
+ELIX_LEVEL_0_TRUE = @ELIX_LEVEL_0_TRUE@
+ELIX_LEVEL_1_FALSE = @ELIX_LEVEL_1_FALSE@
+ELIX_LEVEL_1_TRUE = @ELIX_LEVEL_1_TRUE@
+ELIX_LEVEL_2_FALSE = @ELIX_LEVEL_2_FALSE@
+ELIX_LEVEL_2_TRUE = @ELIX_LEVEL_2_TRUE@
+ELIX_LEVEL_3_FALSE = @ELIX_LEVEL_3_FALSE@
+ELIX_LEVEL_3_TRUE = @ELIX_LEVEL_3_TRUE@
+ELIX_LEVEL_4_FALSE = @ELIX_LEVEL_4_FALSE@
+ELIX_LEVEL_4_TRUE = @ELIX_LEVEL_4_TRUE@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+MAY_SUPPLY_SYSCALLS_FALSE = @MAY_SUPPLY_SYSCALLS_FALSE@
+MAY_SUPPLY_SYSCALLS_TRUE = @MAY_SUPPLY_SYSCALLS_TRUE@
+NEWLIB_CFLAGS = @NEWLIB_CFLAGS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+READELF = @READELF@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+USE_LIBTOOL_FALSE = @USE_LIBTOOL_FALSE@
+USE_LIBTOOL_TRUE = @USE_LIBTOOL_TRUE@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_AS = @ac_ct_AS@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_READELF = @ac_ct_READELF@
+ac_ct_STRIP = @ac_ct_STRIP@
+aext = @aext@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+libm_machine_dir = @libm_machine_dir@
+localstatedir = @localstatedir@
+lpfx = @lpfx@
+machine_dir = @machine_dir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+newlib_basedir = @newlib_basedir@
+oext = @oext@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sys_dir = @sys_dir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+AUTOMAKE_OPTIONS = cygnus
+INCLUDES = -I $(newlib_basedir)/../newlib/libm/common $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I $(newlib_basedir)/../newlib/libm/machine/spu/headers
+
+# add headers XXX
+LIB_SOURCES = \
+	llrint.c llrintf.c llround.c llroundf.c log2.c log2f.c s_cbrt.c \
+	s_ceil.c s_copysign.c s_cos.c s_fabs.c sf_atan.c sf_cbrt.c \
+	sf_ceil.c sf_copysign.c sf_cos.c s_fdim.c sf_fabs.c sf_fdim.c \
+	sf_floor.c sf_fma.c sf_fmax.c sf_fmin.c sf_frexp.c sf_ilogb.c \
+	sf_ldexp.c s_floor.c sf_lrint.c sf_lround.c sf_nearbyint.c s_fma.c \
+	s_fmax.c s_fmin.c sf_remquo.c sf_rint.c s_frexp.c sf_round.c \
+	sf_scalbln.c sf_scalbn.c sf_sin.c sf_tan.c sf_trunc.c s_ilogb.c \
+	s_ldexp.c s_lrint.c s_lround.c s_nearbyint.c s_remquo.c s_rint.c \
+	s_round.c s_scalbn.c s_sin.c s_tan.c s_trunc.c w_exp2.c w_exp.c \
+	wf_acos.c wf_asin.c wf_exp2.c wf_exp.c wf_fmod.c wf_log10.c \
+	wf_log.c w_fmod.c wf_pow.c wf_remainder.c wf_sqrt.c w_log10.c \
+	w_log.c w_pow.c w_remainder.c w_sqrt.c \
+	feclearexcept.c fegetround.c fesetenv.c fetestexcept.c fegetenv.c \
+ 	feholdexcept.c fesetexceptflag.c feupdateenv.c fegetexceptflag.c \
+ 	feraiseexcept.c fesetround.c fe_dfl_env.c \
+	cbrt_factors.c
+
+noinst_LIBRARIES = lib.a
+lib_a_SOURCES = $(LIB_SOURCES)
+lib_a_CFLAGS = $(AM_CFLAGS)
+lib_a_CCASFLAGS = $(AM_CCASFLAGS)
+noinst_DATA = 
+ACLOCAL_AMFLAGS = -I ../../..
+CONFIG_STATUS_DEPENDENCIES = $(newlib_basedir)/configure.host
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+am--refresh:
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(srcdir)/../../../Makefile.shared $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --cygnus '; \
+	      cd $(srcdir) && $(AUTOMAKE) --cygnus  \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --cygnus  Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --cygnus  Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+lib.a: $(lib_a_OBJECTS) $(lib_a_DEPENDENCIES) 
+	-rm -f lib.a
+	$(lib_a_AR) lib.a $(lib_a_OBJECTS) $(lib_a_LIBADD)
+	$(RANLIB) lib.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.c.o:
+	$(COMPILE) -c $<
+
+.c.obj:
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+lib_a-llrint.o: llrint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-llrint.o `test -f 'llrint.c' || echo '$(srcdir)/'`llrint.c
+
+lib_a-llrint.obj: llrint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-llrint.obj `if test -f 'llrint.c'; then $(CYGPATH_W) 'llrint.c'; else $(CYGPATH_W) '$(srcdir)/llrint.c'; fi`
+
+lib_a-llrintf.o: llrintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-llrintf.o `test -f 'llrintf.c' || echo '$(srcdir)/'`llrintf.c
+
+lib_a-llrintf.obj: llrintf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-llrintf.obj `if test -f 'llrintf.c'; then $(CYGPATH_W) 'llrintf.c'; else $(CYGPATH_W) '$(srcdir)/llrintf.c'; fi`
+
+lib_a-llround.o: llround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-llround.o `test -f 'llround.c' || echo '$(srcdir)/'`llround.c
+
+lib_a-llround.obj: llround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-llround.obj `if test -f 'llround.c'; then $(CYGPATH_W) 'llround.c'; else $(CYGPATH_W) '$(srcdir)/llround.c'; fi`
+
+lib_a-llroundf.o: llroundf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-llroundf.o `test -f 'llroundf.c' || echo '$(srcdir)/'`llroundf.c
+
+lib_a-llroundf.obj: llroundf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-llroundf.obj `if test -f 'llroundf.c'; then $(CYGPATH_W) 'llroundf.c'; else $(CYGPATH_W) '$(srcdir)/llroundf.c'; fi`
+
+lib_a-log2.o: log2.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-log2.o `test -f 'log2.c' || echo '$(srcdir)/'`log2.c
+
+lib_a-log2.obj: log2.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-log2.obj `if test -f 'log2.c'; then $(CYGPATH_W) 'log2.c'; else $(CYGPATH_W) '$(srcdir)/log2.c'; fi`
+
+lib_a-log2f.o: log2f.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-log2f.o `test -f 'log2f.c' || echo '$(srcdir)/'`log2f.c
+
+lib_a-log2f.obj: log2f.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-log2f.obj `if test -f 'log2f.c'; then $(CYGPATH_W) 'log2f.c'; else $(CYGPATH_W) '$(srcdir)/log2f.c'; fi`
+
+lib_a-s_cbrt.o: s_cbrt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_cbrt.o `test -f 's_cbrt.c' || echo '$(srcdir)/'`s_cbrt.c
+
+lib_a-s_cbrt.obj: s_cbrt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_cbrt.obj `if test -f 's_cbrt.c'; then $(CYGPATH_W) 's_cbrt.c'; else $(CYGPATH_W) '$(srcdir)/s_cbrt.c'; fi`
+
+lib_a-s_ceil.o: s_ceil.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_ceil.o `test -f 's_ceil.c' || echo '$(srcdir)/'`s_ceil.c
+
+lib_a-s_ceil.obj: s_ceil.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_ceil.obj `if test -f 's_ceil.c'; then $(CYGPATH_W) 's_ceil.c'; else $(CYGPATH_W) '$(srcdir)/s_ceil.c'; fi`
+
+lib_a-s_copysign.o: s_copysign.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_copysign.o `test -f 's_copysign.c' || echo '$(srcdir)/'`s_copysign.c
+
+lib_a-s_copysign.obj: s_copysign.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_copysign.obj `if test -f 's_copysign.c'; then $(CYGPATH_W) 's_copysign.c'; else $(CYGPATH_W) '$(srcdir)/s_copysign.c'; fi`
+
+lib_a-s_cos.o: s_cos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_cos.o `test -f 's_cos.c' || echo '$(srcdir)/'`s_cos.c
+
+lib_a-s_cos.obj: s_cos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_cos.obj `if test -f 's_cos.c'; then $(CYGPATH_W) 's_cos.c'; else $(CYGPATH_W) '$(srcdir)/s_cos.c'; fi`
+
+lib_a-s_fabs.o: s_fabs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fabs.o `test -f 's_fabs.c' || echo '$(srcdir)/'`s_fabs.c
+
+lib_a-s_fabs.obj: s_fabs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fabs.obj `if test -f 's_fabs.c'; then $(CYGPATH_W) 's_fabs.c'; else $(CYGPATH_W) '$(srcdir)/s_fabs.c'; fi`
+
+lib_a-sf_atan.o: sf_atan.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_atan.o `test -f 'sf_atan.c' || echo '$(srcdir)/'`sf_atan.c
+
+lib_a-sf_atan.obj: sf_atan.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_atan.obj `if test -f 'sf_atan.c'; then $(CYGPATH_W) 'sf_atan.c'; else $(CYGPATH_W) '$(srcdir)/sf_atan.c'; fi`
+
+lib_a-sf_cbrt.o: sf_cbrt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_cbrt.o `test -f 'sf_cbrt.c' || echo '$(srcdir)/'`sf_cbrt.c
+
+lib_a-sf_cbrt.obj: sf_cbrt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_cbrt.obj `if test -f 'sf_cbrt.c'; then $(CYGPATH_W) 'sf_cbrt.c'; else $(CYGPATH_W) '$(srcdir)/sf_cbrt.c'; fi`
+
+lib_a-sf_ceil.o: sf_ceil.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_ceil.o `test -f 'sf_ceil.c' || echo '$(srcdir)/'`sf_ceil.c
+
+lib_a-sf_ceil.obj: sf_ceil.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_ceil.obj `if test -f 'sf_ceil.c'; then $(CYGPATH_W) 'sf_ceil.c'; else $(CYGPATH_W) '$(srcdir)/sf_ceil.c'; fi`
+
+lib_a-sf_copysign.o: sf_copysign.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_copysign.o `test -f 'sf_copysign.c' || echo '$(srcdir)/'`sf_copysign.c
+
+lib_a-sf_copysign.obj: sf_copysign.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_copysign.obj `if test -f 'sf_copysign.c'; then $(CYGPATH_W) 'sf_copysign.c'; else $(CYGPATH_W) '$(srcdir)/sf_copysign.c'; fi`
+
+lib_a-sf_cos.o: sf_cos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_cos.o `test -f 'sf_cos.c' || echo '$(srcdir)/'`sf_cos.c
+
+lib_a-sf_cos.obj: sf_cos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_cos.obj `if test -f 'sf_cos.c'; then $(CYGPATH_W) 'sf_cos.c'; else $(CYGPATH_W) '$(srcdir)/sf_cos.c'; fi`
+
+lib_a-s_fdim.o: s_fdim.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fdim.o `test -f 's_fdim.c' || echo '$(srcdir)/'`s_fdim.c
+
+lib_a-s_fdim.obj: s_fdim.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fdim.obj `if test -f 's_fdim.c'; then $(CYGPATH_W) 's_fdim.c'; else $(CYGPATH_W) '$(srcdir)/s_fdim.c'; fi`
+
+lib_a-sf_fabs.o: sf_fabs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fabs.o `test -f 'sf_fabs.c' || echo '$(srcdir)/'`sf_fabs.c
+
+lib_a-sf_fabs.obj: sf_fabs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fabs.obj `if test -f 'sf_fabs.c'; then $(CYGPATH_W) 'sf_fabs.c'; else $(CYGPATH_W) '$(srcdir)/sf_fabs.c'; fi`
+
+lib_a-sf_fdim.o: sf_fdim.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fdim.o `test -f 'sf_fdim.c' || echo '$(srcdir)/'`sf_fdim.c
+
+lib_a-sf_fdim.obj: sf_fdim.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fdim.obj `if test -f 'sf_fdim.c'; then $(CYGPATH_W) 'sf_fdim.c'; else $(CYGPATH_W) '$(srcdir)/sf_fdim.c'; fi`
+
+lib_a-sf_floor.o: sf_floor.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_floor.o `test -f 'sf_floor.c' || echo '$(srcdir)/'`sf_floor.c
+
+lib_a-sf_floor.obj: sf_floor.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_floor.obj `if test -f 'sf_floor.c'; then $(CYGPATH_W) 'sf_floor.c'; else $(CYGPATH_W) '$(srcdir)/sf_floor.c'; fi`
+
+lib_a-sf_fma.o: sf_fma.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fma.o `test -f 'sf_fma.c' || echo '$(srcdir)/'`sf_fma.c
+
+lib_a-sf_fma.obj: sf_fma.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fma.obj `if test -f 'sf_fma.c'; then $(CYGPATH_W) 'sf_fma.c'; else $(CYGPATH_W) '$(srcdir)/sf_fma.c'; fi`
+
+lib_a-sf_fmax.o: sf_fmax.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fmax.o `test -f 'sf_fmax.c' || echo '$(srcdir)/'`sf_fmax.c
+
+lib_a-sf_fmax.obj: sf_fmax.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fmax.obj `if test -f 'sf_fmax.c'; then $(CYGPATH_W) 'sf_fmax.c'; else $(CYGPATH_W) '$(srcdir)/sf_fmax.c'; fi`
+
+lib_a-sf_fmin.o: sf_fmin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fmin.o `test -f 'sf_fmin.c' || echo '$(srcdir)/'`sf_fmin.c
+
+lib_a-sf_fmin.obj: sf_fmin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_fmin.obj `if test -f 'sf_fmin.c'; then $(CYGPATH_W) 'sf_fmin.c'; else $(CYGPATH_W) '$(srcdir)/sf_fmin.c'; fi`
+
+lib_a-sf_frexp.o: sf_frexp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_frexp.o `test -f 'sf_frexp.c' || echo '$(srcdir)/'`sf_frexp.c
+
+lib_a-sf_frexp.obj: sf_frexp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_frexp.obj `if test -f 'sf_frexp.c'; then $(CYGPATH_W) 'sf_frexp.c'; else $(CYGPATH_W) '$(srcdir)/sf_frexp.c'; fi`
+
+lib_a-sf_ilogb.o: sf_ilogb.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_ilogb.o `test -f 'sf_ilogb.c' || echo '$(srcdir)/'`sf_ilogb.c
+
+lib_a-sf_ilogb.obj: sf_ilogb.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_ilogb.obj `if test -f 'sf_ilogb.c'; then $(CYGPATH_W) 'sf_ilogb.c'; else $(CYGPATH_W) '$(srcdir)/sf_ilogb.c'; fi`
+
+lib_a-sf_ldexp.o: sf_ldexp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_ldexp.o `test -f 'sf_ldexp.c' || echo '$(srcdir)/'`sf_ldexp.c
+
+lib_a-sf_ldexp.obj: sf_ldexp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_ldexp.obj `if test -f 'sf_ldexp.c'; then $(CYGPATH_W) 'sf_ldexp.c'; else $(CYGPATH_W) '$(srcdir)/sf_ldexp.c'; fi`
+
+lib_a-s_floor.o: s_floor.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_floor.o `test -f 's_floor.c' || echo '$(srcdir)/'`s_floor.c
+
+lib_a-s_floor.obj: s_floor.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_floor.obj `if test -f 's_floor.c'; then $(CYGPATH_W) 's_floor.c'; else $(CYGPATH_W) '$(srcdir)/s_floor.c'; fi`
+
+lib_a-sf_lrint.o: sf_lrint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_lrint.o `test -f 'sf_lrint.c' || echo '$(srcdir)/'`sf_lrint.c
+
+lib_a-sf_lrint.obj: sf_lrint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_lrint.obj `if test -f 'sf_lrint.c'; then $(CYGPATH_W) 'sf_lrint.c'; else $(CYGPATH_W) '$(srcdir)/sf_lrint.c'; fi`
+
+lib_a-sf_lround.o: sf_lround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_lround.o `test -f 'sf_lround.c' || echo '$(srcdir)/'`sf_lround.c
+
+lib_a-sf_lround.obj: sf_lround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_lround.obj `if test -f 'sf_lround.c'; then $(CYGPATH_W) 'sf_lround.c'; else $(CYGPATH_W) '$(srcdir)/sf_lround.c'; fi`
+
+lib_a-sf_nearbyint.o: sf_nearbyint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_nearbyint.o `test -f 'sf_nearbyint.c' || echo '$(srcdir)/'`sf_nearbyint.c
+
+lib_a-sf_nearbyint.obj: sf_nearbyint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_nearbyint.obj `if test -f 'sf_nearbyint.c'; then $(CYGPATH_W) 'sf_nearbyint.c'; else $(CYGPATH_W) '$(srcdir)/sf_nearbyint.c'; fi`
+
+lib_a-s_fma.o: s_fma.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fma.o `test -f 's_fma.c' || echo '$(srcdir)/'`s_fma.c
+
+lib_a-s_fma.obj: s_fma.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fma.obj `if test -f 's_fma.c'; then $(CYGPATH_W) 's_fma.c'; else $(CYGPATH_W) '$(srcdir)/s_fma.c'; fi`
+
+lib_a-s_fmax.o: s_fmax.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fmax.o `test -f 's_fmax.c' || echo '$(srcdir)/'`s_fmax.c
+
+lib_a-s_fmax.obj: s_fmax.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fmax.obj `if test -f 's_fmax.c'; then $(CYGPATH_W) 's_fmax.c'; else $(CYGPATH_W) '$(srcdir)/s_fmax.c'; fi`
+
+lib_a-s_fmin.o: s_fmin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fmin.o `test -f 's_fmin.c' || echo '$(srcdir)/'`s_fmin.c
+
+lib_a-s_fmin.obj: s_fmin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_fmin.obj `if test -f 's_fmin.c'; then $(CYGPATH_W) 's_fmin.c'; else $(CYGPATH_W) '$(srcdir)/s_fmin.c'; fi`
+
+lib_a-sf_remquo.o: sf_remquo.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_remquo.o `test -f 'sf_remquo.c' || echo '$(srcdir)/'`sf_remquo.c
+
+lib_a-sf_remquo.obj: sf_remquo.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_remquo.obj `if test -f 'sf_remquo.c'; then $(CYGPATH_W) 'sf_remquo.c'; else $(CYGPATH_W) '$(srcdir)/sf_remquo.c'; fi`
+
+lib_a-sf_rint.o: sf_rint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_rint.o `test -f 'sf_rint.c' || echo '$(srcdir)/'`sf_rint.c
+
+lib_a-sf_rint.obj: sf_rint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_rint.obj `if test -f 'sf_rint.c'; then $(CYGPATH_W) 'sf_rint.c'; else $(CYGPATH_W) '$(srcdir)/sf_rint.c'; fi`
+
+lib_a-s_frexp.o: s_frexp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_frexp.o `test -f 's_frexp.c' || echo '$(srcdir)/'`s_frexp.c
+
+lib_a-s_frexp.obj: s_frexp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_frexp.obj `if test -f 's_frexp.c'; then $(CYGPATH_W) 's_frexp.c'; else $(CYGPATH_W) '$(srcdir)/s_frexp.c'; fi`
+
+lib_a-sf_round.o: sf_round.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_round.o `test -f 'sf_round.c' || echo '$(srcdir)/'`sf_round.c
+
+lib_a-sf_round.obj: sf_round.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_round.obj `if test -f 'sf_round.c'; then $(CYGPATH_W) 'sf_round.c'; else $(CYGPATH_W) '$(srcdir)/sf_round.c'; fi`
+
+lib_a-sf_scalbln.o: sf_scalbln.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_scalbln.o `test -f 'sf_scalbln.c' || echo '$(srcdir)/'`sf_scalbln.c
+
+lib_a-sf_scalbln.obj: sf_scalbln.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_scalbln.obj `if test -f 'sf_scalbln.c'; then $(CYGPATH_W) 'sf_scalbln.c'; else $(CYGPATH_W) '$(srcdir)/sf_scalbln.c'; fi`
+
+lib_a-sf_scalbn.o: sf_scalbn.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_scalbn.o `test -f 'sf_scalbn.c' || echo '$(srcdir)/'`sf_scalbn.c
+
+lib_a-sf_scalbn.obj: sf_scalbn.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_scalbn.obj `if test -f 'sf_scalbn.c'; then $(CYGPATH_W) 'sf_scalbn.c'; else $(CYGPATH_W) '$(srcdir)/sf_scalbn.c'; fi`
+
+lib_a-sf_sin.o: sf_sin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_sin.o `test -f 'sf_sin.c' || echo '$(srcdir)/'`sf_sin.c
+
+lib_a-sf_sin.obj: sf_sin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_sin.obj `if test -f 'sf_sin.c'; then $(CYGPATH_W) 'sf_sin.c'; else $(CYGPATH_W) '$(srcdir)/sf_sin.c'; fi`
+
+lib_a-sf_tan.o: sf_tan.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_tan.o `test -f 'sf_tan.c' || echo '$(srcdir)/'`sf_tan.c
+
+lib_a-sf_tan.obj: sf_tan.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_tan.obj `if test -f 'sf_tan.c'; then $(CYGPATH_W) 'sf_tan.c'; else $(CYGPATH_W) '$(srcdir)/sf_tan.c'; fi`
+
+lib_a-sf_trunc.o: sf_trunc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_trunc.o `test -f 'sf_trunc.c' || echo '$(srcdir)/'`sf_trunc.c
+
+lib_a-sf_trunc.obj: sf_trunc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sf_trunc.obj `if test -f 'sf_trunc.c'; then $(CYGPATH_W) 'sf_trunc.c'; else $(CYGPATH_W) '$(srcdir)/sf_trunc.c'; fi`
+
+lib_a-s_ilogb.o: s_ilogb.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_ilogb.o `test -f 's_ilogb.c' || echo '$(srcdir)/'`s_ilogb.c
+
+lib_a-s_ilogb.obj: s_ilogb.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_ilogb.obj `if test -f 's_ilogb.c'; then $(CYGPATH_W) 's_ilogb.c'; else $(CYGPATH_W) '$(srcdir)/s_ilogb.c'; fi`
+
+lib_a-s_ldexp.o: s_ldexp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_ldexp.o `test -f 's_ldexp.c' || echo '$(srcdir)/'`s_ldexp.c
+
+lib_a-s_ldexp.obj: s_ldexp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_ldexp.obj `if test -f 's_ldexp.c'; then $(CYGPATH_W) 's_ldexp.c'; else $(CYGPATH_W) '$(srcdir)/s_ldexp.c'; fi`
+
+lib_a-s_lrint.o: s_lrint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_lrint.o `test -f 's_lrint.c' || echo '$(srcdir)/'`s_lrint.c
+
+lib_a-s_lrint.obj: s_lrint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_lrint.obj `if test -f 's_lrint.c'; then $(CYGPATH_W) 's_lrint.c'; else $(CYGPATH_W) '$(srcdir)/s_lrint.c'; fi`
+
+lib_a-s_lround.o: s_lround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_lround.o `test -f 's_lround.c' || echo '$(srcdir)/'`s_lround.c
+
+lib_a-s_lround.obj: s_lround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_lround.obj `if test -f 's_lround.c'; then $(CYGPATH_W) 's_lround.c'; else $(CYGPATH_W) '$(srcdir)/s_lround.c'; fi`
+
+lib_a-s_nearbyint.o: s_nearbyint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_nearbyint.o `test -f 's_nearbyint.c' || echo '$(srcdir)/'`s_nearbyint.c
+
+lib_a-s_nearbyint.obj: s_nearbyint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_nearbyint.obj `if test -f 's_nearbyint.c'; then $(CYGPATH_W) 's_nearbyint.c'; else $(CYGPATH_W) '$(srcdir)/s_nearbyint.c'; fi`
+
+lib_a-s_remquo.o: s_remquo.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_remquo.o `test -f 's_remquo.c' || echo '$(srcdir)/'`s_remquo.c
+
+lib_a-s_remquo.obj: s_remquo.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_remquo.obj `if test -f 's_remquo.c'; then $(CYGPATH_W) 's_remquo.c'; else $(CYGPATH_W) '$(srcdir)/s_remquo.c'; fi`
+
+lib_a-s_rint.o: s_rint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_rint.o `test -f 's_rint.c' || echo '$(srcdir)/'`s_rint.c
+
+lib_a-s_rint.obj: s_rint.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_rint.obj `if test -f 's_rint.c'; then $(CYGPATH_W) 's_rint.c'; else $(CYGPATH_W) '$(srcdir)/s_rint.c'; fi`
+
+lib_a-s_round.o: s_round.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_round.o `test -f 's_round.c' || echo '$(srcdir)/'`s_round.c
+
+lib_a-s_round.obj: s_round.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_round.obj `if test -f 's_round.c'; then $(CYGPATH_W) 's_round.c'; else $(CYGPATH_W) '$(srcdir)/s_round.c'; fi`
+
+lib_a-s_scalbn.o: s_scalbn.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_scalbn.o `test -f 's_scalbn.c' || echo '$(srcdir)/'`s_scalbn.c
+
+lib_a-s_scalbn.obj: s_scalbn.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_scalbn.obj `if test -f 's_scalbn.c'; then $(CYGPATH_W) 's_scalbn.c'; else $(CYGPATH_W) '$(srcdir)/s_scalbn.c'; fi`
+
+lib_a-s_sin.o: s_sin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_sin.o `test -f 's_sin.c' || echo '$(srcdir)/'`s_sin.c
+
+lib_a-s_sin.obj: s_sin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_sin.obj `if test -f 's_sin.c'; then $(CYGPATH_W) 's_sin.c'; else $(CYGPATH_W) '$(srcdir)/s_sin.c'; fi`
+
+lib_a-s_tan.o: s_tan.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_tan.o `test -f 's_tan.c' || echo '$(srcdir)/'`s_tan.c
+
+lib_a-s_tan.obj: s_tan.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_tan.obj `if test -f 's_tan.c'; then $(CYGPATH_W) 's_tan.c'; else $(CYGPATH_W) '$(srcdir)/s_tan.c'; fi`
+
+lib_a-s_trunc.o: s_trunc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_trunc.o `test -f 's_trunc.c' || echo '$(srcdir)/'`s_trunc.c
+
+lib_a-s_trunc.obj: s_trunc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-s_trunc.obj `if test -f 's_trunc.c'; then $(CYGPATH_W) 's_trunc.c'; else $(CYGPATH_W) '$(srcdir)/s_trunc.c'; fi`
+
+lib_a-w_exp2.o: w_exp2.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_exp2.o `test -f 'w_exp2.c' || echo '$(srcdir)/'`w_exp2.c
+
+lib_a-w_exp2.obj: w_exp2.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_exp2.obj `if test -f 'w_exp2.c'; then $(CYGPATH_W) 'w_exp2.c'; else $(CYGPATH_W) '$(srcdir)/w_exp2.c'; fi`
+
+lib_a-w_exp.o: w_exp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_exp.o `test -f 'w_exp.c' || echo '$(srcdir)/'`w_exp.c
+
+lib_a-w_exp.obj: w_exp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_exp.obj `if test -f 'w_exp.c'; then $(CYGPATH_W) 'w_exp.c'; else $(CYGPATH_W) '$(srcdir)/w_exp.c'; fi`
+
+lib_a-wf_acos.o: wf_acos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_acos.o `test -f 'wf_acos.c' || echo '$(srcdir)/'`wf_acos.c
+
+lib_a-wf_acos.obj: wf_acos.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_acos.obj `if test -f 'wf_acos.c'; then $(CYGPATH_W) 'wf_acos.c'; else $(CYGPATH_W) '$(srcdir)/wf_acos.c'; fi`
+
+lib_a-wf_asin.o: wf_asin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_asin.o `test -f 'wf_asin.c' || echo '$(srcdir)/'`wf_asin.c
+
+lib_a-wf_asin.obj: wf_asin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_asin.obj `if test -f 'wf_asin.c'; then $(CYGPATH_W) 'wf_asin.c'; else $(CYGPATH_W) '$(srcdir)/wf_asin.c'; fi`
+
+lib_a-wf_exp2.o: wf_exp2.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_exp2.o `test -f 'wf_exp2.c' || echo '$(srcdir)/'`wf_exp2.c
+
+lib_a-wf_exp2.obj: wf_exp2.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_exp2.obj `if test -f 'wf_exp2.c'; then $(CYGPATH_W) 'wf_exp2.c'; else $(CYGPATH_W) '$(srcdir)/wf_exp2.c'; fi`
+
+lib_a-wf_exp.o: wf_exp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_exp.o `test -f 'wf_exp.c' || echo '$(srcdir)/'`wf_exp.c
+
+lib_a-wf_exp.obj: wf_exp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_exp.obj `if test -f 'wf_exp.c'; then $(CYGPATH_W) 'wf_exp.c'; else $(CYGPATH_W) '$(srcdir)/wf_exp.c'; fi`
+
+lib_a-wf_fmod.o: wf_fmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_fmod.o `test -f 'wf_fmod.c' || echo '$(srcdir)/'`wf_fmod.c
+
+lib_a-wf_fmod.obj: wf_fmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_fmod.obj `if test -f 'wf_fmod.c'; then $(CYGPATH_W) 'wf_fmod.c'; else $(CYGPATH_W) '$(srcdir)/wf_fmod.c'; fi`
+
+lib_a-wf_log10.o: wf_log10.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_log10.o `test -f 'wf_log10.c' || echo '$(srcdir)/'`wf_log10.c
+
+lib_a-wf_log10.obj: wf_log10.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_log10.obj `if test -f 'wf_log10.c'; then $(CYGPATH_W) 'wf_log10.c'; else $(CYGPATH_W) '$(srcdir)/wf_log10.c'; fi`
+
+lib_a-wf_log.o: wf_log.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_log.o `test -f 'wf_log.c' || echo '$(srcdir)/'`wf_log.c
+
+lib_a-wf_log.obj: wf_log.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_log.obj `if test -f 'wf_log.c'; then $(CYGPATH_W) 'wf_log.c'; else $(CYGPATH_W) '$(srcdir)/wf_log.c'; fi`
+
+lib_a-w_fmod.o: w_fmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_fmod.o `test -f 'w_fmod.c' || echo '$(srcdir)/'`w_fmod.c
+
+lib_a-w_fmod.obj: w_fmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_fmod.obj `if test -f 'w_fmod.c'; then $(CYGPATH_W) 'w_fmod.c'; else $(CYGPATH_W) '$(srcdir)/w_fmod.c'; fi`
+
+lib_a-wf_pow.o: wf_pow.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_pow.o `test -f 'wf_pow.c' || echo '$(srcdir)/'`wf_pow.c
+
+lib_a-wf_pow.obj: wf_pow.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_pow.obj `if test -f 'wf_pow.c'; then $(CYGPATH_W) 'wf_pow.c'; else $(CYGPATH_W) '$(srcdir)/wf_pow.c'; fi`
+
+lib_a-wf_remainder.o: wf_remainder.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_remainder.o `test -f 'wf_remainder.c' || echo '$(srcdir)/'`wf_remainder.c
+
+lib_a-wf_remainder.obj: wf_remainder.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_remainder.obj `if test -f 'wf_remainder.c'; then $(CYGPATH_W) 'wf_remainder.c'; else $(CYGPATH_W) '$(srcdir)/wf_remainder.c'; fi`
+
+lib_a-wf_sqrt.o: wf_sqrt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_sqrt.o `test -f 'wf_sqrt.c' || echo '$(srcdir)/'`wf_sqrt.c
+
+lib_a-wf_sqrt.obj: wf_sqrt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wf_sqrt.obj `if test -f 'wf_sqrt.c'; then $(CYGPATH_W) 'wf_sqrt.c'; else $(CYGPATH_W) '$(srcdir)/wf_sqrt.c'; fi`
+
+lib_a-w_log10.o: w_log10.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_log10.o `test -f 'w_log10.c' || echo '$(srcdir)/'`w_log10.c
+
+lib_a-w_log10.obj: w_log10.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_log10.obj `if test -f 'w_log10.c'; then $(CYGPATH_W) 'w_log10.c'; else $(CYGPATH_W) '$(srcdir)/w_log10.c'; fi`
+
+lib_a-w_log.o: w_log.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_log.o `test -f 'w_log.c' || echo '$(srcdir)/'`w_log.c
+
+lib_a-w_log.obj: w_log.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_log.obj `if test -f 'w_log.c'; then $(CYGPATH_W) 'w_log.c'; else $(CYGPATH_W) '$(srcdir)/w_log.c'; fi`
+
+lib_a-w_pow.o: w_pow.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_pow.o `test -f 'w_pow.c' || echo '$(srcdir)/'`w_pow.c
+
+lib_a-w_pow.obj: w_pow.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_pow.obj `if test -f 'w_pow.c'; then $(CYGPATH_W) 'w_pow.c'; else $(CYGPATH_W) '$(srcdir)/w_pow.c'; fi`
+
+lib_a-w_remainder.o: w_remainder.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_remainder.o `test -f 'w_remainder.c' || echo '$(srcdir)/'`w_remainder.c
+
+lib_a-w_remainder.obj: w_remainder.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_remainder.obj `if test -f 'w_remainder.c'; then $(CYGPATH_W) 'w_remainder.c'; else $(CYGPATH_W) '$(srcdir)/w_remainder.c'; fi`
+
+lib_a-w_sqrt.o: w_sqrt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_sqrt.o `test -f 'w_sqrt.c' || echo '$(srcdir)/'`w_sqrt.c
+
+lib_a-w_sqrt.obj: w_sqrt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-w_sqrt.obj `if test -f 'w_sqrt.c'; then $(CYGPATH_W) 'w_sqrt.c'; else $(CYGPATH_W) '$(srcdir)/w_sqrt.c'; fi`
+
+lib_a-feclearexcept.o: feclearexcept.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feclearexcept.o `test -f 'feclearexcept.c' || echo '$(srcdir)/'`feclearexcept.c
+
+lib_a-feclearexcept.obj: feclearexcept.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feclearexcept.obj `if test -f 'feclearexcept.c'; then $(CYGPATH_W) 'feclearexcept.c'; else $(CYGPATH_W) '$(srcdir)/feclearexcept.c'; fi`
+
+lib_a-fegetround.o: fegetround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fegetround.o `test -f 'fegetround.c' || echo '$(srcdir)/'`fegetround.c
+
+lib_a-fegetround.obj: fegetround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fegetround.obj `if test -f 'fegetround.c'; then $(CYGPATH_W) 'fegetround.c'; else $(CYGPATH_W) '$(srcdir)/fegetround.c'; fi`
+
+lib_a-fesetenv.o: fesetenv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fesetenv.o `test -f 'fesetenv.c' || echo '$(srcdir)/'`fesetenv.c
+
+lib_a-fesetenv.obj: fesetenv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fesetenv.obj `if test -f 'fesetenv.c'; then $(CYGPATH_W) 'fesetenv.c'; else $(CYGPATH_W) '$(srcdir)/fesetenv.c'; fi`
+
+lib_a-fetestexcept.o: fetestexcept.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fetestexcept.o `test -f 'fetestexcept.c' || echo '$(srcdir)/'`fetestexcept.c
+
+lib_a-fetestexcept.obj: fetestexcept.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fetestexcept.obj `if test -f 'fetestexcept.c'; then $(CYGPATH_W) 'fetestexcept.c'; else $(CYGPATH_W) '$(srcdir)/fetestexcept.c'; fi`
+
+lib_a-fegetenv.o: fegetenv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fegetenv.o `test -f 'fegetenv.c' || echo '$(srcdir)/'`fegetenv.c
+
+lib_a-fegetenv.obj: fegetenv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fegetenv.obj `if test -f 'fegetenv.c'; then $(CYGPATH_W) 'fegetenv.c'; else $(CYGPATH_W) '$(srcdir)/fegetenv.c'; fi`
+
+lib_a-feholdexcept.o: feholdexcept.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feholdexcept.o `test -f 'feholdexcept.c' || echo '$(srcdir)/'`feholdexcept.c
+
+lib_a-feholdexcept.obj: feholdexcept.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feholdexcept.obj `if test -f 'feholdexcept.c'; then $(CYGPATH_W) 'feholdexcept.c'; else $(CYGPATH_W) '$(srcdir)/feholdexcept.c'; fi`
+
+lib_a-fesetexceptflag.o: fesetexceptflag.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fesetexceptflag.o `test -f 'fesetexceptflag.c' || echo '$(srcdir)/'`fesetexceptflag.c
+
+lib_a-fesetexceptflag.obj: fesetexceptflag.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fesetexceptflag.obj `if test -f 'fesetexceptflag.c'; then $(CYGPATH_W) 'fesetexceptflag.c'; else $(CYGPATH_W) '$(srcdir)/fesetexceptflag.c'; fi`
+
+lib_a-feupdateenv.o: feupdateenv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feupdateenv.o `test -f 'feupdateenv.c' || echo '$(srcdir)/'`feupdateenv.c
+
+lib_a-feupdateenv.obj: feupdateenv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feupdateenv.obj `if test -f 'feupdateenv.c'; then $(CYGPATH_W) 'feupdateenv.c'; else $(CYGPATH_W) '$(srcdir)/feupdateenv.c'; fi`
+
+lib_a-fegetexceptflag.o: fegetexceptflag.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fegetexceptflag.o `test -f 'fegetexceptflag.c' || echo '$(srcdir)/'`fegetexceptflag.c
+
+lib_a-fegetexceptflag.obj: fegetexceptflag.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fegetexceptflag.obj `if test -f 'fegetexceptflag.c'; then $(CYGPATH_W) 'fegetexceptflag.c'; else $(CYGPATH_W) '$(srcdir)/fegetexceptflag.c'; fi`
+
+lib_a-feraiseexcept.o: feraiseexcept.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feraiseexcept.o `test -f 'feraiseexcept.c' || echo '$(srcdir)/'`feraiseexcept.c
+
+lib_a-feraiseexcept.obj: feraiseexcept.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-feraiseexcept.obj `if test -f 'feraiseexcept.c'; then $(CYGPATH_W) 'feraiseexcept.c'; else $(CYGPATH_W) '$(srcdir)/feraiseexcept.c'; fi`
+
+lib_a-fesetround.o: fesetround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fesetround.o `test -f 'fesetround.c' || echo '$(srcdir)/'`fesetround.c
+
+lib_a-fesetround.obj: fesetround.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fesetround.obj `if test -f 'fesetround.c'; then $(CYGPATH_W) 'fesetround.c'; else $(CYGPATH_W) '$(srcdir)/fesetround.c'; fi`
+
+lib_a-fe_dfl_env.o: fe_dfl_env.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fe_dfl_env.o `test -f 'fe_dfl_env.c' || echo '$(srcdir)/'`fe_dfl_env.c
+
+lib_a-fe_dfl_env.obj: fe_dfl_env.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fe_dfl_env.obj `if test -f 'fe_dfl_env.c'; then $(CYGPATH_W) 'fe_dfl_env.c'; else $(CYGPATH_W) '$(srcdir)/fe_dfl_env.c'; fi`
+
+lib_a-cbrt_factors.o: cbrt_factors.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-cbrt_factors.o `test -f 'cbrt_factors.c' || echo '$(srcdir)/'`cbrt_factors.c
+
+lib_a-cbrt_factors.obj: cbrt_factors.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-cbrt_factors.obj `if test -f 'cbrt_factors.c'; then $(CYGPATH_W) 'cbrt_factors.c'; else $(CYGPATH_W) '$(srcdir)/cbrt_factors.c'; fi`
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+check-am:
+check: check-am
+all-am: Makefile $(LIBRARIES) $(DATA)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \
+	clean-generic clean-noinstLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-tags dvi dvi-am \
+	html html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
+
+objectlist.awk.in: $(noinst_LTLIBRARIES)
+	-rm -f objectlist.awk.in
+	for i in `ls *.lo` ; \
+	do \
+	  echo $$i `pwd`/$$i >> objectlist.awk.in ; \
+	done
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_cbrt.c newlib-1.15.0/newlib/libm/machine/spu/s_cbrt.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_cbrt.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_cbrt.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/cbrt.h"
+
+double cbrt(double x)
+{
+    return _cbrt(x);
+}
+long double cbrtl(long double) __attribute__ ((strong, alias ("cbrt")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_ceil.c newlib-1.15.0/newlib/libm/machine/spu/s_ceil.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_ceil.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_ceil.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/ceil.h"
+
+double ceil(double x)
+{
+    return _ceil(x);
+}
+long double ceill(long double) __attribute__ ((strong, alias ("ceil")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_copysign.c newlib-1.15.0/newlib/libm/machine/spu/s_copysign.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_copysign.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_copysign.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/copysign.h"
+
+double copysign(double x, double y)
+{
+    return _copysign(x, y);
+}
+long double copysignl(long double, long double) __attribute__ ((strong, alias ("copysign")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_cos.c newlib-1.15.0/newlib/libm/machine/spu/s_cos.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_cos.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_cos.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/cos.h"
+
+double cos(double x)
+{
+    return _cos(x);
+}
+long double cosl(long double angle)  __attribute__ ((strong, alias ("cos")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_fabs.c newlib-1.15.0/newlib/libm/machine/spu/s_fabs.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_fabs.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_fabs.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/fabs.h"
+
+double fabs(double x)
+{
+    return _fabs(x);
+}
+long double fabsl(long double) __attribute__ ((strong, alias ("fabs")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_atan.c newlib-1.15.0/newlib/libm/machine/spu/sf_atan.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_atan.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_atan.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/atanf.h"
+
+float atanf(float x)
+{
+    return _atanf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_cbrt.c newlib-1.15.0/newlib/libm/machine/spu/sf_cbrt.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_cbrt.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_cbrt.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/cbrtf.h"
+
+float cbrtf(float x)
+{
+    return _cbrtf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_ceil.c newlib-1.15.0/newlib/libm/machine/spu/sf_ceil.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_ceil.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_ceil.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/ceilf.h"
+
+float ceilf(float value)
+{
+    return _ceilf(value);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_copysign.c newlib-1.15.0/newlib/libm/machine/spu/sf_copysign.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_copysign.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_copysign.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/copysignf.h"
+
+float copysignf(float x, float y)
+{
+    return _copysignf(x, y);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_cos.c newlib-1.15.0/newlib/libm/machine/spu/sf_cos.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_cos.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_cos.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/cosf.h"
+
+float cosf(float angle)
+{
+    return _cosf(angle);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_fdim.c newlib-1.15.0/newlib/libm/machine/spu/s_fdim.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_fdim.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_fdim.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/fdim.h"
+
+double fdim(double x, double y)
+{
+    return _fdim(x, y);
+}
+long double fdiml(long double, long double) __attribute__ ((strong, alias ("fdim")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fabs.c newlib-1.15.0/newlib/libm/machine/spu/sf_fabs.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fabs.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_fabs.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fabsf.h"
+
+float fabsf(float value)
+{
+    return _fabsf(value);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fdim.c newlib-1.15.0/newlib/libm/machine/spu/sf_fdim.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fdim.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_fdim.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fdimf.h"
+
+float fdimf(float x, float y)
+{
+    return _fdimf(x, y);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_floor.c newlib-1.15.0/newlib/libm/machine/spu/sf_floor.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_floor.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_floor.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/floorf.h"
+
+float floorf(float value)
+{
+    return _floorf(value);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fma.c newlib-1.15.0/newlib/libm/machine/spu/sf_fma.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fma.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_fma.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fmaf.h"
+
+float fmaf(float x, float y, float z)
+{
+    return _fmaf(x, y, z);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fmax.c newlib-1.15.0/newlib/libm/machine/spu/sf_fmax.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fmax.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_fmax.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fmaxf.h"
+
+float fmaxf(float x, float y)
+{
+    return _fmaxf(x, y);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fmin.c newlib-1.15.0/newlib/libm/machine/spu/sf_fmin.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_fmin.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_fmin.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fminf.h"
+
+float fminf(float x, float y)
+{
+    return _fminf(x, y);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_frexp.c newlib-1.15.0/newlib/libm/machine/spu/sf_frexp.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_frexp.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_frexp.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/frexpf.h"
+
+float frexpf(float x, int *pexp)
+{
+    return _frexpf(x, pexp);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_ilogb.c newlib-1.15.0/newlib/libm/machine/spu/sf_ilogb.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_ilogb.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_ilogb.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/ilogbf.h"
+
+int ilogbf(float x)
+{
+    return _ilogbf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_ldexp.c newlib-1.15.0/newlib/libm/machine/spu/sf_ldexp.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_ldexp.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_ldexp.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/ldexpf.h"
+
+float ldexpf(float x, int exp)
+{
+    return _ldexpf(x, exp);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_floor.c newlib-1.15.0/newlib/libm/machine/spu/s_floor.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_floor.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_floor.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/floor.h"
+
+double floor(double x)
+{
+    return _floor(x);
+}
+long double floorl(long double) __attribute__ ((strong, alias ("floor")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_lrint.c newlib-1.15.0/newlib/libm/machine/spu/sf_lrint.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_lrint.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_lrint.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/lrintf.h"
+
+long int lrintf(float x)
+{
+    return _lrintf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_lround.c newlib-1.15.0/newlib/libm/machine/spu/sf_lround.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_lround.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_lround.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/lroundf.h"
+
+long int lroundf(float x)
+{
+    return _lroundf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_fma.c newlib-1.15.0/newlib/libm/machine/spu/s_fma.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_fma.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_fma.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/fma.h"
+
+double fma(double x, double y, double z)
+{
+    return _fma(x, y, z);
+}
+long double fmal(long double, long double, long double) __attribute__ ((strong, alias ("fma")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_fmax.c newlib-1.15.0/newlib/libm/machine/spu/s_fmax.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_fmax.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_fmax.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/fmax.h"
+
+double fmax(double x, double y)
+{
+    return _fmax(x, y);
+}
+long double fmaxl(long double, long double) __attribute__ ((strong, alias ("fmax")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_fmin.c newlib-1.15.0/newlib/libm/machine/spu/s_fmin.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_fmin.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_fmin.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/fmin.h"
+
+double fmin(double x, double y)
+{
+    return _fmin(x, y);
+}
+long double fminl(long double, long double) __attribute__ ((strong, alias ("fmin")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_nearbyint.c newlib-1.15.0/newlib/libm/machine/spu/sf_nearbyint.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_nearbyint.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_nearbyint.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,4 @@
+/*
+ * Empty file, so we overwrite the file containing the common nearbyintf,
+ * and use the alias in the spu sf_nearbyint.c file.
+ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_remquo.c newlib-1.15.0/newlib/libm/machine/spu/sf_remquo.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_remquo.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_remquo.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/remquof.h"
+
+float remquof(float x, float y, int *quo)
+{
+    return _remquof(x, y, quo);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_frexp.c newlib-1.15.0/newlib/libm/machine/spu/s_frexp.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_frexp.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_frexp.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/frexp.h"
+
+double frexp(double x, int *pexp)
+{
+    return _frexp(x, pexp);
+}
+long double frexpl(long double, int *) __attribute__ ((strong, alias ("frexp")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_rint.c newlib-1.15.0/newlib/libm/machine/spu/sf_rint.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_rint.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_rint.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,4 @@
+/*
+ * Empty file, so we overwrite the file containing the common rintf,
+ * and use the alias in the spu sf_nearbyint.c file.
+ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_round.c newlib-1.15.0/newlib/libm/machine/spu/sf_round.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_round.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_round.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/roundf.h"
+
+float roundf(float x)
+{
+    return _roundf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_scalbln.c newlib-1.15.0/newlib/libm/machine/spu/sf_scalbln.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_scalbln.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_scalbln.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,4 @@
+/*
+ * Empty file, so we overwrite the file containing the common scalblnf,
+ * and use the alias in the spu sf_scalbn.c file.
+ */
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_scalbn.c newlib-1.15.0/newlib/libm/machine/spu/sf_scalbn.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_scalbn.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_scalbn.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/scalbnf.h"
+
+float scalbnf(float x, int exp)
+{
+    return _scalbnf(x, exp);
+}
+float scalblnf(float, long int) __attribute__ ((strong, alias ("scalbnf")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_sin.c newlib-1.15.0/newlib/libm/machine/spu/sf_sin.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_sin.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_sin.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/sinf.h"
+
+float sinf(float angle)
+{
+    return _sinf(angle);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_tan.c newlib-1.15.0/newlib/libm/machine/spu/sf_tan.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_tan.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_tan.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/tanf.h"
+
+float tanf(float angle)
+{
+    return _tanf(angle);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/sf_trunc.c newlib-1.15.0/newlib/libm/machine/spu/sf_trunc.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/sf_trunc.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/sf_trunc.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,8 @@
+#include "../headers/truncf.h"
+
+float truncf(float x)
+{
+    return _truncf(x);
+}
+float nearbyintf(float) __attribute__ ((strong, alias ("truncf")));
+float rintf(float) __attribute__ ((strong, alias ("truncf")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_ilogb.c newlib-1.15.0/newlib/libm/machine/spu/s_ilogb.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_ilogb.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_ilogb.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/ilogb.h"
+
+int ilogb(double x)
+{
+    return _ilogb(x);
+}
+int ilogbl(long double) __attribute__ ((strong, alias ("ilogb")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_ldexp.c newlib-1.15.0/newlib/libm/machine/spu/s_ldexp.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_ldexp.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_ldexp.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/ldexp.h"
+
+double ldexp(double x, int exp)
+{
+    return _ldexp(x, exp);
+}
+long double ldexpl(long double, int) __attribute__ ((strong, alias ("ldexp")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_lrint.c newlib-1.15.0/newlib/libm/machine/spu/s_lrint.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_lrint.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_lrint.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/lrint.h"
+
+long int lrint(double x)
+{
+    return _lrint(x);
+}
+long int lrintl(long double) __attribute__ ((strong, alias ("lrint")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_lround.c newlib-1.15.0/newlib/libm/machine/spu/s_lround.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_lround.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_lround.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/lround.h"
+
+long int lround(double x)
+{
+    return _lround(x);
+}
+long int lroundl(long double) __attribute__ ((strong, alias ("lround")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_nearbyint.c newlib-1.15.0/newlib/libm/machine/spu/s_nearbyint.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_nearbyint.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_nearbyint.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/nearbyint.h"
+
+double nearbyint(double x)
+{
+    return _nearbyint(x);
+}
+long double nearbyintl(long double) __attribute__ ((strong, alias ("nearbyint")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_remquo.c newlib-1.15.0/newlib/libm/machine/spu/s_remquo.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_remquo.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_remquo.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/remquo.h"
+
+double remquo(double x, double y, int *quo)
+{
+    return _remquo(x, y, quo);
+}
+long double remquol(long double, long double, int *) __attribute__ ((strong, alias ("remquo")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_rint.c newlib-1.15.0/newlib/libm/machine/spu/s_rint.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_rint.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_rint.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/rint.h"
+
+double rint(double x)
+{
+    return _rint(x);
+}
+long double rintl(long double) __attribute__ ((strong, alias ("rint")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_round.c newlib-1.15.0/newlib/libm/machine/spu/s_round.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_round.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_round.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/round.h"
+
+double round(double x)
+{
+    return _round(x);
+}
+long double roundl(long double) __attribute__ ((strong, alias ("round")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_scalbn.c newlib-1.15.0/newlib/libm/machine/spu/s_scalbn.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_scalbn.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_scalbn.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/scalbn.h"
+
+double scalbn(double x, int exp)
+{
+    return _scalbn(x, exp);
+}
+long double scalbnl() __attribute__ ((strong, alias ("scalbn")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_sin.c newlib-1.15.0/newlib/libm/machine/spu/s_sin.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_sin.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_sin.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/sin.h"
+
+double sin(double x)
+{
+    return _sin(x);
+}
+long double sinl(long double angle) __attribute__ ((strong, alias ("sin")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_tan.c newlib-1.15.0/newlib/libm/machine/spu/s_tan.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_tan.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_tan.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/tan.h"
+
+double tan(double angle)
+{
+    return _tan(angle);
+}
+long double tanl(long double angle) __attribute__ ((strong, alias ("tan")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/s_trunc.c newlib-1.15.0/newlib/libm/machine/spu/s_trunc.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/s_trunc.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/s_trunc.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/trunc.h"
+
+double trunc(double x)
+{
+    return _trunc(x);
+}
+long double truncl(long double) __attribute__ ((strong, alias ("trunc")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/w_exp2.c newlib-1.15.0/newlib/libm/machine/spu/w_exp2.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/w_exp2.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/w_exp2.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/exp2.h"
+
+double exp2(double x)
+{
+    return _exp2(x);
+}
+long double exp2l(long double x) __attribute__ ((strong, alias ("exp2")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/w_exp.c newlib-1.15.0/newlib/libm/machine/spu/w_exp.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/w_exp.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/w_exp.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/exp.h"
+
+double exp(double x)
+{
+    return _exp(x);
+}
+long double expl(long double x) __attribute__ ((strong, alias ("exp")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_acos.c newlib-1.15.0/newlib/libm/machine/spu/wf_acos.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_acos.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_acos.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/acosf.h"
+
+float acosf(float x)
+{
+    return _acosf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_asin.c newlib-1.15.0/newlib/libm/machine/spu/wf_asin.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_asin.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_asin.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/asinf.h"
+
+float asinf(float x)
+{
+    return _asinf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_exp2.c newlib-1.15.0/newlib/libm/machine/spu/wf_exp2.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_exp2.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_exp2.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/exp2f.h"
+
+float exp2f(float x)
+{
+    return _exp2f(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_exp.c newlib-1.15.0/newlib/libm/machine/spu/wf_exp.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_exp.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_exp.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/expf.h"
+
+float expf(float x)
+{
+    return _expf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_fmod.c newlib-1.15.0/newlib/libm/machine/spu/wf_fmod.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_fmod.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_fmod.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/fmodf.h"
+
+float fmodf(float x, float y)
+{
+    return _fmodf(x, y);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_log10.c newlib-1.15.0/newlib/libm/machine/spu/wf_log10.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_log10.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_log10.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/log10f.h"
+
+float log10f(float x)
+{
+    return _log10f(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_log.c newlib-1.15.0/newlib/libm/machine/spu/wf_log.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_log.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_log.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/logf.h"
+
+float logf(float x)
+{
+    return _logf(x);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/w_fmod.c newlib-1.15.0/newlib/libm/machine/spu/w_fmod.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/w_fmod.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/w_fmod.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/fmod.h"
+
+double fmod(double x, double y)
+{
+    return _fmod(x, y);
+}
+long double fmodl(long double, long double) __attribute__ ((strong, alias ("fmod")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_pow.c newlib-1.15.0/newlib/libm/machine/spu/wf_pow.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_pow.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_pow.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/powf.h"
+
+float powf(float x, float y)
+{
+    return _powf(x, y);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_remainder.c newlib-1.15.0/newlib/libm/machine/spu/wf_remainder.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_remainder.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_remainder.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/remainderf.h"
+
+float remainderf(float x, float y)
+{
+    return _remainderf(x, y);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/wf_sqrt.c newlib-1.15.0/newlib/libm/machine/spu/wf_sqrt.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/wf_sqrt.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/wf_sqrt.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,6 @@
+#include "../headers/sqrtf.h"
+
+float sqrtf(float value)
+{
+    return _sqrtf(value);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/w_log10.c newlib-1.15.0/newlib/libm/machine/spu/w_log10.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/w_log10.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/w_log10.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/log10.h"
+
+double log10(double x)
+{
+    return _log10(x);
+}
+long double log10l(long double x) __attribute__ ((strong, alias ("log10")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/w_log.c newlib-1.15.0/newlib/libm/machine/spu/w_log.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/w_log.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/w_log.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/log.h"
+
+double log(double x)
+{
+    return _log(x);
+}
+long double logl(long double x) __attribute__ ((strong, alias ("log")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/w_pow.c newlib-1.15.0/newlib/libm/machine/spu/w_pow.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/w_pow.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/w_pow.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/pow.h"
+
+double pow(double x, double y)
+{
+    return _pow(x, y);
+}
+long double powl(long double x, long double y) __attribute__ ((strong, alias ("pow")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/w_remainder.c newlib-1.15.0/newlib/libm/machine/spu/w_remainder.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/w_remainder.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/w_remainder.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/remainder.h"
+
+double remainder(double x, double y)
+{
+    return _remainder(x, y);
+}
+long double remainderl(long double, long double) __attribute__ ((strong, alias ("remainder")));
diff -burN orig.newlib-1.15.0/newlib/libm/machine/spu/w_sqrt.c newlib-1.15.0/newlib/libm/machine/spu/w_sqrt.c
--- orig.newlib-1.15.0/newlib/libm/machine/spu/w_sqrt.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/machine/spu/w_sqrt.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,7 @@
+#include "../headers/sqrt.h"
+
+double sqrt(double in)
+{
+    return _sqrt(in);
+}
+long double sqrtl(long double value) __attribute__ ((strong, alias ("sqrt")));
diff -burN orig.newlib-1.15.0/newlib/libm/test/dcvt.c newlib-1.15.0/newlib/libm/test/dcvt.c
--- orig.newlib-1.15.0/newlib/libm/test/dcvt.c	2000-02-17 15:39:52.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/dcvt.c	2007-06-12 16:59:18.000000000 -0300
@@ -195,7 +195,7 @@
   
 }
 int
-_DEFUN(round,(in, start, now, ch),
+_DEFUN(myround,(in, start, now, ch),
        cvt_info_type *in _AND
        char *start _AND
        char *now _AND
@@ -312,7 +312,7 @@
     
   }
 
-  if (round(in,
+  if (myround(in,
 	    in->buffer,
 	    in->buffer+buffer_idx,
 	    nextdigit(&(in->value)))) 
@@ -420,7 +420,7 @@
 
   in->null_idx = buffer_idx;  
   in->buffer[buffer_idx] = 0;
-  if (round(in, in->buffer, in->buffer+buffer_idx,
+  if (myround(in, in->buffer, in->buffer+buffer_idx,
 	    nextdigit(&(in->value)))) 
   {
       _cvtf(in);
diff -burN orig.newlib-1.15.0/newlib/libm/test/dvec.c newlib-1.15.0/newlib/libm/test/dvec.c
--- orig.newlib-1.15.0/newlib/libm/test/dvec.c	2000-02-17 15:39:52.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/dvec.c	2007-06-12 16:59:18.000000000 -0300
@@ -1,6 +1,7 @@
 #include "test.h"
 
 ddouble_type ddoubles[] = {
+#ifndef __SPU__
 __LINE__, 7.411456790099004e+08,"7411",4,9,0,"7411456790099",4,9,0,"7.411e+08",4,
 
 __LINE__, 6.779433073319225e-23,"6779433",7,-22,0,"6779433",7,-22,0,"6.779433e-23",7,
@@ -578,6 +579,7 @@
 
 __LINE__, 4.744768215108924e-02,"474477",6,-1,0,"474477",6,-1,0,".047448",6,
 
+#endif
 __LINE__, 3.523947347400251e+10,"35",2,11,0,"3523947347400",2,11,0,"3.5e+10",2,
 
 __LINE__, 4.703989947348573e+08,"4704",4,9,0,"4703989947349",4,9,0,"4.704e+08",4,
diff -burN orig.newlib-1.15.0/newlib/libm/test/iconv_vec.c newlib-1.15.0/newlib/libm/test/iconv_vec.c
--- orig.newlib-1.15.0/newlib/libm/test/iconv_vec.c	2000-02-17 15:39:52.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/iconv_vec.c	2007-06-12 16:59:18.000000000 -0300
@@ -2,6 +2,7 @@
 #include "test.h"
 
 int_type ints[]={
+#ifndef __SPU__
 __LINE__,0x00000000, 3,0,0x00000000, 3,0,0x7fffffff,12,34,0x7fffffff,12,34,0x00000000, 3,0, " +0xa73231122",
 __LINE__,0x00000000, 3,0,0x00000000, 3,0,0x000000a7, 6,0,0x000000a7, 6,0,0x00000000, 3,0, " +0xa7w",
 __LINE__,0x00000000, 3,0,0x00000000, 3,0,0x00000a73, 7,0,0x00000a73, 7,0,0x00000000, 3,0, " +0xa73",
@@ -1143,6 +1144,7 @@
 __LINE__,0x0000007b, 3,0,0x000000ad, 3,0,0x00000173, 3,0,0x000000ad, 3,0,0x0000035d, 3,0, "173",
 __LINE__,0x0000000f, 2,0,0x00000011, 2,0,0x00000017, 2,0,0x00000011, 2,0,0x00000021, 2,0, "17",
 __LINE__,0x542d3252,12,0,0x7fffffff,11,34,0x7fffffff,11,34,0x7fffffff,11,34,0x7fffffff, 8,34, "112413231122",
+#endif
 __LINE__,0x000012a1, 5,0,0x00002be9, 5,0,0x00011241, 5,0,0x00002be9, 5,0,0x00074369, 5,0, "11241w",
 __LINE__,0x0000950b, 6,0,0x0001b71d, 6,0,0x00112413, 6,0,0x0001b71d, 6,0,0x00bcd8ad, 6,0, "112413",
 __LINE__,0x000012a1, 5,0,0x00002be9, 5,0,0x00011241, 5,0,0x00002be9, 5,0,0x00074369, 5,0, "11241",
diff -burN orig.newlib-1.15.0/newlib/libm/test/math_template.c newlib-1.15.0/newlib/libm/test/math_template.c
--- orig.newlib-1.15.0/newlib/libm/test/math_template.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/math_template.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,415 @@
+/*
+  Test the library maths functions using trusted precomputed test
+  vectors.
+
+  These vectors were originally generated on a sun3 with a 68881 using
+  80 bit precision, but ...
+
+  Each function is called with a variety of interesting arguments.
+  Note that many of the polynomials we use behave badly when the
+  domain is stressed, so the numbers in the vectors depend on what is
+  useful to test - eg sin(1e30) is pointless - the arg has to be
+  reduced modulo pi, and after that there's no bits of significance
+  left to evaluate with - any number would be just as precise as any
+  other.
+
+
+*/
+
+#include "test.h"
+#include <math.h>
+#include <ieeefp.h>
+#include <float.h>
+#include <math.h>
+#include <errno.h>
+#include <stdio.h>
+
+int inacc;
+
+int merror;
+double mretval = 64;
+int traperror = 1;
+char *mname;
+
+int verbose;
+
+/* To test exceptions - we trap them all and return a known value */
+int
+_DEFUN(matherr,(e),
+       struct exception *e)
+{
+  if (traperror)
+  {
+    merror = e->type + 12;
+    mname = e->name;
+    e->retval = mretval;
+    errno = merror + 24;
+    return 1;
+  }
+  return 0;
+}
+
+
+void _DEFUN(translate_to,(file,r),
+	    FILE *file _AND
+	    double r)
+{
+  __ieee_double_shape_type bits;
+  bits.value = r;
+  fprintf(file, "0x%08x, 0x%08x", bits.parts.msw, bits.parts.lsw);
+}
+
+int
+_DEFUN(ffcheck,( is, p, name, serrno, merror),
+       double is _AND
+       one_line_type *p _AND
+       char *name _AND
+       int serrno _AND
+       int merror)
+{
+  /* Make sure the answer isn't to far wrong from the correct value */
+  __ieee_double_shape_type correct, isbits;
+  int mag;
+  isbits.value = is;
+
+  correct.parts.msw = p->qs[0].msw;
+  correct.parts.lsw = p->qs[0].lsw;
+
+  mag = mag_of_error(correct.value, is);
+
+  if (mag < p->error_bit)
+  {
+    inacc ++;
+
+    printf("%s:%d, inaccurate answer: bit %d (%08x%08x %08x%08x) (%g %g)\n",
+	   name,  p->line, mag,
+	   correct.parts.msw,
+	   correct.parts.lsw,
+	   isbits.parts.msw,
+	   isbits.parts.lsw,
+	   correct.value, is);
+  }
+
+#if 0
+  if (p->qs[0].merror != merror)
+  {
+    printf("testing %s_vec.c:%d, matherr wrong: %d %d\n",
+	   name, p->line, merror, p->qs[0].merror);
+  }
+
+  if (p->qs[0].errno_val != errno)
+  {
+    printf("testing %s_vec.c:%d, errno wrong: %d %d\n",
+	   name, p->line, errno, p->qs[0].errno_val);
+
+  }
+#endif
+  return mag;
+}
+
+double
+_DEFUN(thedouble, (msw, lsw),
+       long msw _AND
+       long lsw)
+{
+  __ieee_double_shape_type x;
+
+  x.parts.msw = msw;
+  x.parts.lsw = lsw;
+  return x.value;
+}
+
+int calc;
+int reduce;
+
+
+_DEFUN(frontline,(f, mag, p, result, merror, myerrno, args, name),
+       FILE *f _AND
+       int mag _AND
+       one_line_type *p _AND
+       double result _AND
+       int merror _AND
+       int myerrno _AND
+       char *args _AND
+       char *name)
+{
+  if (reduce && p->error_bit < mag)
+  {
+    fprintf(f, "{%2d,", p->error_bit);
+  }
+  else
+  {
+    fprintf(f, "{%2d,",mag);
+  }
+
+
+  fprintf(f,"%2d,%3d,", merror,myerrno);
+  fprintf(f, "__LINE__, ");
+
+  if (calc)
+  {
+    translate_to(f, result);
+  }
+  else
+  {
+    translate_to(f, thedouble(p->qs[0].msw, p->qs[0].lsw));
+  }
+
+  fprintf(f, ", ");
+
+  fprintf(f,"0x%08x, 0x%08x", p->qs[1].msw, p->qs[1].lsw);
+
+
+  if (args[2])
+  {
+    fprintf(f, ", ");
+    fprintf(f,"0x%08x, 0x%08x", p->qs[2].msw, p->qs[2].lsw);
+  }
+	
+  fprintf(f,"},	/* %g=f(%g",result,
+  	  thedouble(p->qs[1].msw, p->qs[1].lsw));
+
+  if (args[2])
+  {
+    fprintf(f,", %g", thedouble(p->qs[2].msw,p->qs[2].lsw));
+  }
+  fprintf(f, ")*/\n");
+}
+
+#ifdef CRASH_SPU_GCC
+_DEFUN(finish,(f, vector,  result , p, args, name),
+       FILE *f _AND
+       int vector _AND
+       double result _AND
+       one_line_type *p _AND
+       char *args _AND
+       char *name)
+#else
+finish(FILE *f, int vector,  double result, one_line_type *p, char *args, char *name)
+#endif
+{
+  int mag;
+
+  mag = ffcheck(result, p,name,  merror, errno);
+  if (vector)
+  {
+    frontline(f, mag, p, result, merror, errno, args, name);
+  }
+}
+int redo;
+
+#ifdef CRASH_SPU_GCC
+_DEFUN(run_vector_1,(vector, p, func, name, args),
+       int vector _AND
+       one_line_type *p _AND
+       char *func _AND
+       char *name _AND
+       char *args)
+#else
+run_vector_1 (int vector, one_line_type *p, char *func, char * name, char *args)
+#endif
+{
+  FILE *f;
+  int mag;
+  double result;
+
+  if (vector)
+  {
+
+    VECOPEN(name, f);
+
+    if (redo)
+    {
+      double k;
+
+      for (k = -.2; k < .2; k+= 0.00132)
+      {
+
+	fprintf(f,"{1,1, 1,1, 0,0,0x%08x,0x%08x, 0x%08x, 0x%08x},\n",
+		k,k+4);
+
+      }
+
+      for (k = -1.2; k < 1.2; k+= 0.01)
+      {
+
+	fprintf(f,"{1,1, 1,1, 0,0,0x%08x,0x%08x, 0x%08x, 0x%08x},\n",
+		k,k+4);
+
+      }
+      for (k = -M_PI *2; k < M_PI *2; k+= M_PI/2)
+      {
+
+	fprintf(f,"{1,1, 1,1, 0,0,0x%08x,0x%08x, 0x%08x, 0x%08x},\n",
+		k,k+4);
+
+      }
+
+      for (k = -30; k < 30; k+= 1.7)
+      {
+
+	fprintf(f,"{2,2, 1,1, 0,0, 0x%08x,0x%08x, 0x%08x, 0x%08x},\n",
+		k,k+4);
+
+      }
+      VECCLOSE(f, name, args);
+      return;
+    }
+  }
+
+  newfunc(name);
+  while (p->line)
+  {
+    double arg1 = thedouble(p->qs[1].msw, p->qs[1].lsw);
+    double arg2 = thedouble(p->qs[2].msw, p->qs[2].lsw);
+
+    double r;
+    double rf;
+
+    errno = 0;
+    merror = 0;
+    mname = 0;
+
+
+    line(p->line);
+
+    merror = 0;
+    errno = 123;
+
+    if (strcmp(args,"dd")==0)
+    {
+      typedef double _EXFUN((*pdblfunc),(double));
+
+      /* Double function returning a double */
+
+      result = ((pdblfunc)(func))(arg1);
+
+      finish(f,vector, result, p, args, name);
+    }
+    else  if (strcmp(args,"ff")==0)
+    {
+      float arga;
+      double a;
+
+      typedef float _EXFUN((*pdblfunc),(float));
+
+      /* Double function returning a double */
+
+      if (arg1 < FLT_MAX )
+      {
+	arga = arg1;
+	result = ((pdblfunc)(func))(arga);
+	finish(f, vector, result, p,args, name);
+      }
+    }
+    else if (strcmp(args,"ddd")==0)
+     {
+       typedef double _EXFUN((*pdblfunc),(double,double));
+
+       result = ((pdblfunc)(func))(arg1,arg2);
+       finish(f, vector, result, p,args, name);
+     }
+     else  if (strcmp(args,"fff")==0)
+     {
+       double a,b;
+
+       float arga;
+       float argb;
+
+       typedef float _EXFUN((*pdblfunc),(float,float));
+
+
+       if (arg1 < FLT_MAX && arg2 < FLT_MAX)
+       {
+	 arga = arg1;
+	 argb = arg2;
+	 result = ((pdblfunc)(func))(arga, argb);
+	 finish(f, vector, result, p,args, name);
+       }
+     }
+     else if (strcmp(args,"did")==0)
+     {
+       typedef double _EXFUN((*pdblfunc),(int,double));
+
+       result = ((pdblfunc)(func))((int)arg1,arg2);
+       finish(f, vector, result, p,args, name);
+     }
+     else  if (strcmp(args,"fif")==0)
+     {
+       double a,b;
+
+       float arga;
+       float argb;
+
+       typedef float _EXFUN((*pdblfunc),(int,float));
+
+
+       if (arg1 < FLT_MAX && arg2 < FLT_MAX)
+       {
+	 arga = arg1;
+	 argb = arg2;
+	 result = ((pdblfunc)(func))((int)arga, argb);
+	 finish(f, vector, result, p,args, name);
+       }
+     }
+
+    p++;
+  }
+  if (vector)
+  {
+    VECCLOSE(f, name, args);
+  }
+}
+
+void
+_DEFUN_VOID(test_math)
+{
+  TEST_NAME(0);
+}
+
+/* These have to be played with to get to compile on machines which
+   don't have the fancy <foo>f entry points
+*/
+
+#if 0
+float _DEFUN(cosf,(a), float a) { return cos((double)a); }
+float _DEFUN(sinf,(a), float  a) { return sin((double)a); }
+float _DEFUN(log1pf,(a), float a) { return log1p((double)a); }
+float _DEFUN(tanf,(a), float a) { return tan((double)a); }
+float _DEFUN(ceilf,(a), float a) { return ceil(a); }
+float _DEFUN(floorf,(a), float a) { return floor(a); }
+#endif
+
+/*ndef HAVE_FLOAT*/
+#if 0
+
+float fmodf(a,b) float a,b; { return fmod(a,b); }
+float hypotf(a,b) float a,b; { return hypot(a,b); }
+
+float acosf(a) float a; { return acos(a); }
+float acoshf(a) float a; { return acosh(a); }
+float asinf(a) float a; { return asin(a); }
+float asinhf(a) float a; { return asinh(a); }
+float atanf(a) float a; { return atan(a); }
+float atanhf(a) float a; { return atanh(a); }
+
+float coshf(a) float a; { return cosh(a); }
+float erff(a) float a; { return erf(a); }
+float erfcf(a) float a; { return erfc(a); }
+float expf(a) float a; { return exp(a); }
+float fabsf(a) float a; { return fabs(a); }
+
+float gammaf(a) float a; { return gamma(a); }
+float j0f(a) float a; { return j0(a); }
+float j1f(a) float a; { return j1(a); }
+float log10f(a) float a; { return log10(a); }
+
+float logf(a) float a; { return log(a); }
+
+float sinhf(a) float a; { return sinh(a); }
+float sqrtf(a) float a; { return sqrt(a); }
+
+float tanhf(a) float a; { return tanh(a); }
+float y0f(a) float a; { return y0(a); }
+float y1f(a) float a; { return y1(a); }
+#endif
diff -burN orig.newlib-1.15.0/newlib/libm/test/sprint_ivec.c newlib-1.15.0/newlib/libm/test/sprint_ivec.c
--- orig.newlib-1.15.0/newlib/libm/test/sprint_ivec.c	2000-02-17 15:39:52.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/sprint_ivec.c	2007-06-12 16:59:18.000000000 -0300
@@ -2,6 +2,10 @@
 
 sprint_int_type sprint_ints[] = 
 {
+	/*
+	 * Skip a lot for SPU, as we don't have enough memory
+	 */
+#ifndef __SPU__
 __LINE__, 0x000838d2,	"838d2", "%.4x",
 __LINE__, 0x0063be46,	"63BE46", "%-6X",
 __LINE__, -0x1b236c0,	"-28456640", "%#0.d",
@@ -5005,7 +5009,7 @@
 __LINE__, 0x0a68ba6e,	"a68ba6e", "%3.1x",
 __LINE__, 0xfe29c810,	"FE29C810", "%+X",
 #endif
-
+#endif
 __LINE__, 0x00000000,	"0", "%o",
 __LINE__, 0000000123,	"123", "%o",
 __LINE__, 0000123456,	"0123456", "%#o",
diff -burN orig.newlib-1.15.0/newlib/libm/test/sprint_vec.c newlib-1.15.0/newlib/libm/test/sprint_vec.c
--- orig.newlib-1.15.0/newlib/libm/test/sprint_vec.c	2000-02-17 15:39:52.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/sprint_vec.c	2007-06-12 16:59:18.000000000 -0300
@@ -2,6 +2,10 @@
 
 sprint_double_type sprint_doubles[] = 
 {
+	/*
+	 * Skip a lot for SPU, as we don't have enough memory
+	 */
+#ifndef __SPU__
 __LINE__, -1.002121970718271e+29,	"-1.0E+29", "%.1E",
 __LINE__, -1.002126048612756e-02,	"-1.002126E-02", "%+#E",
 __LINE__, -1.002653755271637e+00,	"-1.00265", "%G",
@@ -3979,6 +3983,7 @@
 __LINE__, 9.962084643867200e+14,	"+996208464386720.038419", "%+f",
 __LINE__, 9.977706708809947e-09,	"9.9777E-09", "%#.4E",
 #endif
+#endif
 __LINE__, 9.978034352999867e+15,	"9.978034e+15", "%2.6e",
 __LINE__, 9.998315286730175e-30,	"9.998315e-30", "%6e",
 0
diff -burN orig.newlib-1.15.0/newlib/libm/test/test_ieee_file.c newlib-1.15.0/newlib/libm/test/test_ieee_file.c
--- orig.newlib-1.15.0/newlib/libm/test/test_ieee_file.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/test_ieee_file.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,180 @@
+
+#include "test.h"
+#include <ieeefp.h>
+
+
+/* Test fp getround and fp setround */
+
+void
+_DEFUN_VOID(test_getround)
+{
+
+  newfunc("fpgetround/fpsetround");
+  line(1);
+  fpsetround(FP_RN);
+  test_iok(fpgetround(), FP_RN);
+  line(2);
+  fpsetround(FP_RM);
+  test_iok(fpgetround(), FP_RM);
+  line(3);  
+  fpsetround(FP_RP);
+  test_iok(fpgetround(), FP_RP);
+  line(4);  
+  fpsetround(FP_RZ);
+  test_iok(fpgetround(), FP_RZ);
+}
+
+/* And fpset/fpgetmask */
+void
+_DEFUN_VOID(test_getmask)
+{
+  newfunc("fpsetmask/fpgetmask");
+  line(1);
+  fpsetmask(FP_X_INV);
+  test_iok(fpgetmask(),FP_X_INV);
+  line(2);
+  fpsetmask(FP_X_DX);
+  test_iok(fpgetmask(),FP_X_DX);
+  line(3);
+  fpsetmask(FP_X_OFL );
+  test_iok(fpgetmask(),FP_X_OFL);
+  line(4);  
+  fpsetmask(FP_X_UFL);
+  test_iok(fpgetmask(),FP_X_UFL);
+  line(5);  
+  fpsetmask(FP_X_IMP);
+  test_iok(fpgetmask(),FP_X_IMP);
+}
+
+void
+_DEFUN_VOID(test_getsticky)
+{
+  newfunc("fpsetsticky/fpgetsticky");
+  line(1);
+  fpsetsticky(FP_X_INV);
+  test_iok(fpgetsticky(),FP_X_INV);
+  line(2);
+  fpsetsticky(FP_X_DX);
+  test_iok(fpgetsticky(),FP_X_DX);
+  line(3);
+  fpsetsticky(FP_X_OFL );
+  test_iok(fpgetsticky(),FP_X_OFL);
+  line(4);  
+  fpsetsticky(FP_X_UFL);
+  test_iok(fpgetsticky(),FP_X_UFL);
+  line(5);  
+  fpsetsticky(FP_X_IMP);
+  test_iok(fpgetsticky(),FP_X_IMP);
+}
+
+void
+_DEFUN_VOID(test_getroundtoi)
+{
+  newfunc("fpsetroundtoi/fpgetroundtoi");
+  line(1);
+  fpsetroundtoi(FP_RDI_TOZ);
+  test_iok(fpgetroundtoi(),FP_RDI_TOZ);
+
+  line(2);
+  fpsetroundtoi(FP_RDI_RD);
+  test_iok(fpgetroundtoi(),FP_RDI_RD);
+
+}
+
+double
+ _DEFUN(dnumber,(msw, lsw),
+	int msw _AND
+	int lsw)
+{
+  
+  __ieee_double_shape_type v;
+  v.parts.lsw = lsw;
+  v.parts.msw = msw;
+  return v.value;
+}
+
+  /* Lets see if changing the rounding alters the arithmetic.
+     Test by creating numbers which will have to be rounded when
+     added, and seeing what happens to them */
+ /* Keep them out here to stop  the compiler from folding the results */
+double n;
+double m;
+double add_rounded_up;
+double add_rounded_down;
+double sub_rounded_down ;
+double sub_rounded_up ;
+  double r1,r2,r3,r4;
+void
+_DEFUN_VOID(test_round)
+{
+  n =                dnumber(0x40000000, 0x00000008); /* near 2 */
+  m =                dnumber(0x40400000, 0x00000003); /* near 3.4 */
+  
+  add_rounded_up   = dnumber(0x40410000, 0x00000004); /* For RN, RP */
+  add_rounded_down = dnumber(0x40410000, 0x00000003); /* For RM, RZ */
+  sub_rounded_down = dnumber(0xc0410000, 0x00000004); /* for RN, RM */
+  sub_rounded_up   = dnumber(0xc0410000, 0x00000003); /* for RP, RZ */
+
+  newfunc("fpsetround");
+  
+  line(1);
+  
+  fpsetround(FP_RN);
+  r1 = n + m;
+  test_mok(r1, add_rounded_up, 64);
+  
+  line(2);
+  fpsetround(FP_RM);
+  r2 = n + m;
+  test_mok(r2, add_rounded_down, 64);
+  
+  fpsetround(FP_RP);
+  line(3);
+  r3 = n + m;
+  test_mok(r3,add_rounded_up, 64);
+  
+  fpsetround(FP_RZ);
+  line(4);
+  r4 = n + m;
+  test_mok(r4,add_rounded_down,64);
+
+
+  fpsetround(FP_RN);
+  r1 = - n - m;
+  line(5);
+  test_mok(r1,sub_rounded_down,64);
+  
+  fpsetround(FP_RM);
+  r2 = - n - m;
+  line(6);
+  test_mok(r2,sub_rounded_down,64);
+
+
+  fpsetround(FP_RP);
+  r3 = - n - m;
+  line(7);
+  test_mok(r3,sub_rounded_up,64);
+
+  fpsetround(FP_RZ);
+  r4 = - n - m;
+  line(8);
+  test_mok(r4,sub_rounded_up,64);
+}
+
+
+void
+_DEFUN_VOID(test_ieee)
+{
+  fp_rnd old = fpgetround();
+  test_getround();
+  test_getmask();
+  test_getsticky();
+  test_getroundtoi();
+
+  test_round();
+  fpsetround(old);
+
+  
+}
+
+
diff -burN orig.newlib-1.15.0/newlib/libm/test/test_is.c newlib-1.15.0/newlib/libm/test/test_is.c
--- orig.newlib-1.15.0/newlib/libm/test/test_is.c	2000-02-17 15:39:52.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/test_is.c	1969-12-31 20:00:00.000000000 -0400
@@ -1,2031 +0,0 @@
-#include "test.h"
-#include <ctype.h>
-
-int setascii;
-int setlower;
-int setupper;
-int myascii;
-int mycntrl;
-int myspace;
-int myprint;
-int myalnum;
-int mydigit;
-int myxdigit;
-int myalpha;
-int myupper;
-int mylower;
-int mygraph;
-int mypunct;
-
-void
-_DEFUN(test_is_single,(i),
-       int i)
-{
-  setascii = 0;
-  setlower = 0;
-  setupper = 0;
-
-  myascii = 0;
-  mycntrl = 0;
-  myspace = 0;
-  myprint = 0;
-  myalnum = 0;
-  mydigit = 0;
-  myxdigit = 0;
-  myalpha = 0;
-  myupper = 0;
-  mylower = 0;
-  mygraph = 0;
-  mypunct = 0;
-
-  switch (i) {
-    case 0000:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 0;
-      setlower = 0;
-      setupper = 0;
-      break;
-    case 0001:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 1;
-      setlower = 1;
-      setupper = 1;
-      break;
-    case 0002:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 2;
-      setlower = 2;
-      setupper = 2;
-      break;
-    case 0003:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 3;
-      setlower = 3;
-      setupper = 3;
-      break;
-    case 0004:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 4;
-      setlower = 4;
-      setupper = 4;
-      break;
-    case 0005:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 5;
-      setlower = 5;
-      setupper = 5;
-      break;
-    case 0006:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 6;
-      setlower = 6;
-      setupper = 6;
-      break;
-    case 0007:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 7;
-      setlower = 7;
-      setupper = 7;
-      break;
-    case 0010:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 8;
-      setlower = 8;
-      setupper = 8;
-      break;
-    case 0011:
-      myascii = 1;
-      mycntrl = 1;
-      myspace = 1;
-      setascii = 9;
-      setlower = 9;
-      setupper = 9;
-      break;
-    case 0012:
-      myascii = 1;
-      mycntrl = 1;
-      myspace = 1;
-      setascii = 10;
-      setlower = 10;
-      setupper = 10;
-      break;
-    case 0013:
-      myascii = 1;
-      mycntrl = 1;
-      myspace = 1;
-      setascii = 11;
-      setlower = 11;
-      setupper = 11;
-      break;
-    case 0014:
-      myascii = 1;
-      mycntrl = 1;
-      myspace = 1;
-      setascii = 12;
-      setlower = 12;
-      setupper = 12;
-      break;
-    case 0015:
-      myascii = 1;
-      mycntrl = 1;
-      myspace = 1;
-      setascii = 13;
-      setlower = 13;
-      setupper = 13;
-      break;
-    case 0016:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 14;
-      setlower = 14;
-      setupper = 14;
-      break;
-    case 0017:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 15;
-      setlower = 15;
-      setupper = 15;
-      break;
-    case 0020:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 16;
-      setlower = 16;
-      setupper = 16;
-      break;
-    case 0021:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 17;
-      setlower = 17;
-      setupper = 17;
-      break;
-    case 0022:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 18;
-      setlower = 18;
-      setupper = 18;
-      break;
-    case 0023:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 19;
-      setlower = 19;
-      setupper = 19;
-      break;
-    case 0024:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 20;
-      setlower = 20;
-      setupper = 20;
-      break;
-    case 0025:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 21;
-      setlower = 21;
-      setupper = 21;
-      break;
-    case 0026:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 22;
-      setlower = 22;
-      setupper = 22;
-      break;
-    case 0027:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 23;
-      setlower = 23;
-      setupper = 23;
-      break;
-    case 0030:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 24;
-      setlower = 24;
-      setupper = 24;
-      break;
-    case 0031:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 25;
-      setlower = 25;
-      setupper = 25;
-      break;
-    case 0032:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 26;
-      setlower = 26;
-      setupper = 26;
-      break;
-    case 0033:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 27;
-      setlower = 27;
-      setupper = 27;
-      break;
-    case 0034:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 28;
-      setlower = 28;
-      setupper = 28;
-      break;
-    case 0035:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 29;
-      setlower = 29;
-      setupper = 29;
-      break;
-    case 0036:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 30;
-      setlower = 30;
-      setupper = 30;
-      break;
-    case 0037:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 31;
-      setlower = 31;
-      setupper = 31;
-      break;
-    case ' ':
-      myascii = 1;
-      myprint = 1;
-      myspace = 1;
-      setascii = 32;
-      setlower = 32;
-      setupper = 32;
-      break;
-    case '!':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 33;
-      setlower = 33;
-      setupper = 33;
-      break;
-    case '"':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 34;
-      setlower = 34;
-      setupper = 34;
-      break;
-    case '#':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 35;
-      setlower = 35;
-      setupper = 35;
-      break;
-    case '$':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 36;
-      setlower = 36;
-      setupper = 36;
-      break;
-    case '%':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 37;
-      setlower = 37;
-      setupper = 37;
-      break;
-    case '&':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 38;
-      setlower = 38;
-      setupper = 38;
-      break;
-    case '\'':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 39;
-      setlower = 39;
-      setupper = 39;
-      break;
-    case '\(':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 40;
-      setlower = 40;
-      setupper = 40;
-      break;
-    case ')':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 41;
-      setlower = 41;
-      setupper = 41;
-      break;
-    case '*':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 42;
-      setlower = 42;
-      setupper = 42;
-      break;
-    case '+':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 43;
-      setlower = 43;
-      setupper = 43;
-      break;
-    case ',':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 44;
-      setlower = 44;
-      setupper = 44;
-      break;
-    case '-':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 45;
-      setlower = 45;
-      setupper = 45;
-      break;
-    case '.':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 46;
-      setlower = 46;
-      setupper = 46;
-      break;
-    case '/':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 47;
-      setlower = 47;
-      setupper = 47;
-      break;
-    case '0':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 48;
-      setlower = 48;
-      setupper = 48;
-      break;
-    case '1':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 49;
-      setlower = 49;
-      setupper = 49;
-      break;
-    case '2':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 50;
-      setlower = 50;
-      setupper = 50;
-      break;
-    case '3':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 51;
-      setlower = 51;
-      setupper = 51;
-      break;
-    case '4':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 52;
-      setlower = 52;
-      setupper = 52;
-      break;
-    case '5':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 53;
-      setlower = 53;
-      setupper = 53;
-      break;
-    case '6':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 54;
-      setlower = 54;
-      setupper = 54;
-      break;
-    case '7':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 55;
-      setlower = 55;
-      setupper = 55;
-      break;
-    case '8':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 56;
-      setlower = 56;
-      setupper = 56;
-      break;
-    case '9':
-      myalnum = 1;
-      myascii = 1;
-      mydigit = 1;
-      mygraph = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 57;
-      setlower = 57;
-      setupper = 57;
-      break;
-    case ':':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 58;
-      setlower = 58;
-      setupper = 58;
-      break;
-    case ';':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 59;
-      setlower = 59;
-      setupper = 59;
-      break;
-    case '<':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 60;
-      setlower = 60;
-      setupper = 60;
-      break;
-    case '=':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 61;
-      setlower = 61;
-      setupper = 61;
-      break;
-    case '>':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 62;
-      setlower = 62;
-      setupper = 62;
-      break;
-    case '?':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 63;
-      setlower = 63;
-      setupper = 63;
-      break;
-    case '@':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 64;
-      setlower = 64;
-      setupper = 64;
-      break;
-    case 'A':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      myxdigit = 1;
-      setascii = 65;
-      setlower = 97;
-      setupper = 65;
-      break;
-    case 'B':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      myxdigit = 1;
-      setascii = 66;
-      setlower = 98;
-      setupper = 66;
-      break;
-    case 'C':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      myxdigit = 1;
-      setascii = 67;
-      setlower = 99;
-      setupper = 67;
-      break;
-    case 'D':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      myxdigit = 1;
-      setascii = 68;
-      setlower = 100;
-      setupper = 68;
-      break;
-    case 'E':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      myxdigit = 1;
-      setascii = 69;
-      setlower = 101;
-      setupper = 69;
-      break;
-    case 'F':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      myxdigit = 1;
-      setascii = 70;
-      setlower = 102;
-      setupper = 70;
-      break;
-    case 'G':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 71;
-      setlower = 103;
-      setupper = 71;
-      break;
-    case 'H':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 72;
-      setlower = 104;
-      setupper = 72;
-      break;
-    case 'I':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 73;
-      setlower = 105;
-      setupper = 73;
-      break;
-    case 'J':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 74;
-      setlower = 106;
-      setupper = 74;
-      break;
-    case 'K':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 75;
-      setlower = 107;
-      setupper = 75;
-      break;
-    case 'L':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 76;
-      setlower = 108;
-      setupper = 76;
-      break;
-    case 'M':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 77;
-      setlower = 109;
-      setupper = 77;
-      break;
-    case 'N':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 78;
-      setlower = 110;
-      setupper = 78;
-      break;
-    case 'O':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 79;
-      setlower = 111;
-      setupper = 79;
-      break;
-    case 'P':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 80;
-      setlower = 112;
-      setupper = 80;
-      break;
-    case 'Q':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 81;
-      setlower = 113;
-      setupper = 81;
-      break;
-    case 'R':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 82;
-      setlower = 114;
-      setupper = 82;
-      break;
-    case 'S':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 83;
-      setlower = 115;
-      setupper = 83;
-      break;
-    case 'T':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 84;
-      setlower = 116;
-      setupper = 84;
-      break;
-    case 'U':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 85;
-      setlower = 117;
-      setupper = 85;
-      break;
-    case 'V':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 86;
-      setlower = 118;
-      setupper = 86;
-      break;
-    case 'W':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 87;
-      setlower = 119;
-      setupper = 87;
-      break;
-    case 'X':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 88;
-      setlower = 120;
-      setupper = 88;
-      break;
-    case 'Y':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 89;
-      setlower = 121;
-      setupper = 89;
-      break;
-    case 'Z':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      myupper = 1;
-      setascii = 90;
-      setlower = 122;
-      setupper = 90;
-      break;
-    case '[':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 91;
-      setlower = 91;
-      setupper = 91;
-      break;
-    case '\\':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 92;
-      setlower = 92;
-      setupper = 92;
-      break;
-    case ']':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 93;
-      setlower = 93;
-      setupper = 93;
-      break;
-    case '^':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 94;
-      setlower = 94;
-      setupper = 94;
-      break;
-    case '_':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 95;
-      setlower = 95;
-      setupper = 95;
-      break;
-    case '`':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 96;
-      setlower = 96;
-      setupper = 96;
-      break;
-    case 'a':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 97;
-      setlower = 97;
-      setupper = 65;
-      break;
-    case 'b':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 98;
-      setlower = 98;
-      setupper = 66;
-      break;
-    case 'c':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 99;
-      setlower = 99;
-      setupper = 67;
-      break;
-    case 'd':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 100;
-      setlower = 100;
-      setupper = 68;
-      break;
-    case 'e':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 101;
-      setlower = 101;
-      setupper = 69;
-      break;
-    case 'f':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      myxdigit = 1;
-      setascii = 102;
-      setlower = 102;
-      setupper = 70;
-      break;
-    case 'g':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 103;
-      setlower = 103;
-      setupper = 71;
-      break;
-    case 'h':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 104;
-      setlower = 104;
-      setupper = 72;
-      break;
-    case 'i':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 105;
-      setlower = 105;
-      setupper = 73;
-      break;
-    case 'j':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 106;
-      setlower = 106;
-      setupper = 74;
-      break;
-    case 'k':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 107;
-      setlower = 107;
-      setupper = 75;
-      break;
-    case 'l':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 108;
-      setlower = 108;
-      setupper = 76;
-      break;
-    case 'm':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 109;
-      setlower = 109;
-      setupper = 77;
-      break;
-    case 'n':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 110;
-      setlower = 110;
-      setupper = 78;
-      break;
-    case 'o':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 111;
-      setlower = 111;
-      setupper = 79;
-      break;
-    case 'p':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 112;
-      setlower = 112;
-      setupper = 80;
-      break;
-    case 'q':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 113;
-      setlower = 113;
-      setupper = 81;
-      break;
-    case 'r':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 114;
-      setlower = 114;
-      setupper = 82;
-      break;
-    case 's':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 115;
-      setlower = 115;
-      setupper = 83;
-      break;
-    case 't':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 116;
-      setlower = 116;
-      setupper = 84;
-      break;
-    case 'u':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 117;
-      setlower = 117;
-      setupper = 85;
-      break;
-    case 'v':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 118;
-      setlower = 118;
-      setupper = 86;
-      break;
-    case 'w':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 119;
-      setlower = 119;
-      setupper = 87;
-      break;
-    case 'x':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 120;
-      setlower = 120;
-      setupper = 88;
-      break;
-    case 'y':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 121;
-      setlower = 121;
-      setupper = 89;
-      break;
-    case 'z':
-      myalnum = 1;
-      myalpha = 1;
-      myascii = 1;
-      mygraph = 1;
-      mylower = 1;
-      myprint = 1;
-      setascii = 122;
-      setlower = 122;
-      setupper = 90;
-      break;
-    case '{':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 123;
-      setlower = 123;
-      setupper = 123;
-      break;
-    case '|':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 124;
-      setlower = 124;
-      setupper = 124;
-      break;
-    case '}':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 125;
-      setlower = 125;
-      setupper = 125;
-      break;
-    case '~':
-      myascii = 1;
-      mygraph = 1;
-      myprint = 1;
-      mypunct = 1;
-      setascii = 126;
-      setlower = 126;
-      setupper = 126;
-      break;
-    case 0177:
-      myascii = 1;
-      mycntrl = 1;
-      setascii = 127;
-      setlower = 127;
-      setupper = 127;
-      break;
-    case 0200:
-      setascii = 0;
-      setlower = 128;
-      setupper = 128;
-      break;
-    case 0201:
-      setascii = 1;
-      setlower = 129;
-      setupper = 129;
-      break;
-    case 0202:
-      setascii = 2;
-      setlower = 130;
-      setupper = 130;
-      break;
-    case 0203:
-      setascii = 3;
-      setlower = 131;
-      setupper = 131;
-      break;
-    case 0204:
-      setascii = 4;
-      setlower = 132;
-      setupper = 132;
-      break;
-    case 0205:
-      setascii = 5;
-      setlower = 133;
-      setupper = 133;
-      break;
-    case 0206:
-      setascii = 6;
-      setlower = 134;
-      setupper = 134;
-      break;
-    case 0207:
-      setascii = 7;
-      setlower = 135;
-      setupper = 135;
-      break;
-    case 0210:
-      setascii = 8;
-      setlower = 136;
-      setupper = 136;
-      break;
-    case 0211:
-      setascii = 9;
-      setlower = 137;
-      setupper = 137;
-      break;
-    case 0212:
-      setascii = 10;
-      setlower = 138;
-      setupper = 138;
-      break;
-    case 0213:
-      setascii = 11;
-      setlower = 139;
-      setupper = 139;
-      break;
-    case 0214:
-      setascii = 12;
-      setlower = 140;
-      setupper = 140;
-      break;
-    case 0215:
-      setascii = 13;
-      setlower = 141;
-      setupper = 141;
-      break;
-    case 0216:
-      setascii = 14;
-      setlower = 142;
-      setupper = 142;
-      break;
-    case 0217:
-      setascii = 15;
-      setlower = 143;
-      setupper = 143;
-      break;
-    case 0220:
-      setascii = 16;
-      setlower = 144;
-      setupper = 144;
-      break;
-    case 0221:
-      setascii = 17;
-      setlower = 145;
-      setupper = 145;
-      break;
-    case 0222:
-      setascii = 18;
-      setlower = 146;
-      setupper = 146;
-      break;
-    case 0223:
-      setascii = 19;
-      setlower = 147;
-      setupper = 147;
-      break;
-    case 0224:
-      setascii = 20;
-      setlower = 148;
-      setupper = 148;
-      break;
-    case 0225:
-      setascii = 21;
-      setlower = 149;
-      setupper = 149;
-      break;
-    case 0226:
-      setascii = 22;
-      setlower = 150;
-      setupper = 150;
-      break;
-    case 0227:
-      setascii = 23;
-      setlower = 151;
-      setupper = 151;
-      break;
-    case 0230:
-      setascii = 24;
-      setlower = 152;
-      setupper = 152;
-      break;
-    case 0231:
-      setascii = 25;
-      setlower = 153;
-      setupper = 153;
-      break;
-    case 0232:
-      setascii = 26;
-      setlower = 154;
-      setupper = 154;
-      break;
-    case 0233:
-      setascii = 27;
-      setlower = 155;
-      setupper = 155;
-      break;
-    case 0234:
-      setascii = 28;
-      setlower = 156;
-      setupper = 156;
-      break;
-    case 0235:
-      setascii = 29;
-      setlower = 157;
-      setupper = 157;
-      break;
-    case 0236:
-      setascii = 30;
-      setlower = 158;
-      setupper = 158;
-      break;
-    case 0237:
-      setascii = 31;
-      setlower = 159;
-      setupper = 159;
-      break;
-    case 0240:
-      setascii = 32;
-      setlower = 160;
-      setupper = 160;
-      break;
-    case 0241:
-      setascii = 33;
-      setlower = 161;
-      setupper = 161;
-      break;
-    case 0242:
-      setascii = 34;
-      setlower = 162;
-      setupper = 162;
-      break;
-    case 0243:
-      setascii = 35;
-      setlower = 163;
-      setupper = 163;
-      break;
-    case 0244:
-      setascii = 36;
-      setlower = 164;
-      setupper = 164;
-      break;
-    case 0245:
-      setascii = 37;
-      setlower = 165;
-      setupper = 165;
-      break;
-    case 0246:
-      setascii = 38;
-      setlower = 166;
-      setupper = 166;
-      break;
-    case 0247:
-      setascii = 39;
-      setlower = 167;
-      setupper = 167;
-      break;
-    case 0250:
-      setascii = 40;
-      setlower = 168;
-      setupper = 168;
-      break;
-    case 0251:
-      setascii = 41;
-      setlower = 169;
-      setupper = 169;
-      break;
-    case 0252:
-      setascii = 42;
-      setlower = 170;
-      setupper = 170;
-      break;
-    case 0253:
-      setascii = 43;
-      setlower = 171;
-      setupper = 171;
-      break;
-    case 0254:
-      setascii = 44;
-      setlower = 172;
-      setupper = 172;
-      break;
-    case 0255:
-      setascii = 45;
-      setlower = 173;
-      setupper = 173;
-      break;
-    case 0256:
-      setascii = 46;
-      setlower = 174;
-      setupper = 174;
-      break;
-    case 0257:
-      setascii = 47;
-      setlower = 175;
-      setupper = 175;
-      break;
-    case 0260:
-      setascii = 48;
-      setlower = 176;
-      setupper = 176;
-      break;
-    case 0261:
-      setascii = 49;
-      setlower = 177;
-      setupper = 177;
-      break;
-    case 0262:
-      setascii = 50;
-      setlower = 178;
-      setupper = 178;
-      break;
-    case 0263:
-      setascii = 51;
-      setlower = 179;
-      setupper = 179;
-      break;
-    case 0264:
-      setascii = 52;
-      setlower = 180;
-      setupper = 180;
-      break;
-    case 0265:
-      setascii = 53;
-      setlower = 181;
-      setupper = 181;
-      break;
-    case 0266:
-      setascii = 54;
-      setlower = 182;
-      setupper = 182;
-      break;
-    case 0267:
-      setascii = 55;
-      setlower = 183;
-      setupper = 183;
-      break;
-    case 0270:
-      setascii = 56;
-      setlower = 184;
-      setupper = 184;
-      break;
-    case 0271:
-      setascii = 57;
-      setlower = 185;
-      setupper = 185;
-      break;
-    case 0272:
-      setascii = 58;
-      setlower = 186;
-      setupper = 186;
-      break;
-    case 0273:
-      setascii = 59;
-      setlower = 187;
-      setupper = 187;
-      break;
-    case 0274:
-      setascii = 60;
-      setlower = 188;
-      setupper = 188;
-      break;
-    case 0275:
-      setascii = 61;
-      setlower = 189;
-      setupper = 189;
-      break;
-    case 0276:
-      setascii = 62;
-      setlower = 190;
-      setupper = 190;
-      break;
-    case 0277:
-      setascii = 63;
-      setlower = 191;
-      setupper = 191;
-      break;
-    case 0300:
-      setascii = 64;
-      setlower = 192;
-      setupper = 192;
-      break;
-    case 0301:
-      setascii = 65;
-      setlower = 193;
-      setupper = 193;
-      break;
-    case 0302:
-      setascii = 66;
-      setlower = 194;
-      setupper = 194;
-      break;
-    case 0303:
-      setascii = 67;
-      setlower = 195;
-      setupper = 195;
-      break;
-    case 0304:
-      setascii = 68;
-      setlower = 196;
-      setupper = 196;
-      break;
-    case 0305:
-      setascii = 69;
-      setlower = 197;
-      setupper = 197;
-      break;
-    case 0306:
-      setascii = 70;
-      setlower = 198;
-      setupper = 198;
-      break;
-    case 0307:
-      setascii = 71;
-      setlower = 199;
-      setupper = 199;
-      break;
-    case 0310:
-      setascii = 72;
-      setlower = 200;
-      setupper = 200;
-      break;
-    case 0311:
-      setascii = 73;
-      setlower = 201;
-      setupper = 201;
-      break;
-    case 0312:
-      setascii = 74;
-      setlower = 202;
-      setupper = 202;
-      break;
-    case 0313:
-      setascii = 75;
-      setlower = 203;
-      setupper = 203;
-      break;
-    case 0314:
-      setascii = 76;
-      setlower = 204;
-      setupper = 204;
-      break;
-    case 0315:
-      setascii = 77;
-      setlower = 205;
-      setupper = 205;
-      break;
-    case 0316:
-      setascii = 78;
-      setlower = 206;
-      setupper = 206;
-      break;
-    case 0317:
-      setascii = 79;
-      setlower = 207;
-      setupper = 207;
-      break;
-    case 0320:
-      setascii = 80;
-      setlower = 208;
-      setupper = 208;
-      break;
-    case 0321:
-      setascii = 81;
-      setlower = 209;
-      setupper = 209;
-      break;
-    case 0322:
-      setascii = 82;
-      setlower = 210;
-      setupper = 210;
-      break;
-    case 0323:
-      setascii = 83;
-      setlower = 211;
-      setupper = 211;
-      break;
-    case 0324:
-      setascii = 84;
-      setlower = 212;
-      setupper = 212;
-      break;
-    case 0325:
-      setascii = 85;
-      setlower = 213;
-      setupper = 213;
-      break;
-    case 0326:
-      setascii = 86;
-      setlower = 214;
-      setupper = 214;
-      break;
-    case 0327:
-      setascii = 87;
-      setlower = 215;
-      setupper = 215;
-      break;
-    case 0330:
-      setascii = 88;
-      setlower = 216;
-      setupper = 216;
-      break;
-    case 0331:
-      setascii = 89;
-      setlower = 217;
-      setupper = 217;
-      break;
-    case 0332:
-      setascii = 90;
-      setlower = 218;
-      setupper = 218;
-      break;
-    case 0333:
-      setascii = 91;
-      setlower = 219;
-      setupper = 219;
-      break;
-    case 0334:
-      setascii = 92;
-      setlower = 220;
-      setupper = 220;
-      break;
-    case 0335:
-      setascii = 93;
-      setlower = 221;
-      setupper = 221;
-      break;
-    case 0336:
-      setascii = 94;
-      setlower = 222;
-      setupper = 222;
-      break;
-    case 0337:
-      setascii = 95;
-      setlower = 223;
-      setupper = 223;
-      break;
-    case 0340:
-      setascii = 96;
-      setlower = 224;
-      setupper = 224;
-      break;
-    case 0341:
-      setascii = 97;
-      setlower = 225;
-      setupper = 225;
-      break;
-    case 0342:
-      setascii = 98;
-      setlower = 226;
-      setupper = 226;
-      break;
-    case 0343:
-      setascii = 99;
-      setlower = 227;
-      setupper = 227;
-      break;
-    case 0344:
-      setascii = 100;
-      setlower = 228;
-      setupper = 228;
-      break;
-    case 0345:
-      setascii = 101;
-      setlower = 229;
-      setupper = 229;
-      break;
-    case 0346:
-      setascii = 102;
-      setlower = 230;
-      setupper = 230;
-      break;
-    case 0347:
-      setascii = 103;
-      setlower = 231;
-      setupper = 231;
-      break;
-    case 0350:
-      setascii = 104;
-      setlower = 232;
-      setupper = 232;
-      break;
-    case 0351:
-      setascii = 105;
-      setlower = 233;
-      setupper = 233;
-      break;
-    case 0352:
-      setascii = 106;
-      setlower = 234;
-      setupper = 234;
-      break;
-    case 0353:
-      setascii = 107;
-      setlower = 235;
-      setupper = 235;
-      break;
-    case 0354:
-      setascii = 108;
-      setlower = 236;
-      setupper = 236;
-      break;
-    case 0355:
-      setascii = 109;
-      setlower = 237;
-      setupper = 237;
-      break;
-    case 0356:
-      setascii = 110;
-      setlower = 238;
-      setupper = 238;
-      break;
-    case 0357:
-      setascii = 111;
-      setlower = 239;
-      setupper = 239;
-      break;
-    case 0360:
-      setascii = 112;
-      setlower = 240;
-      setupper = 240;
-      break;
-    case 0361:
-      setascii = 113;
-      setlower = 241;
-      setupper = 241;
-      break;
-    case 0362:
-      setascii = 114;
-      setlower = 242;
-      setupper = 242;
-      break;
-    case 0363:
-      setascii = 115;
-      setlower = 243;
-      setupper = 243;
-      break;
-    case 0364:
-      setascii = 116;
-      setlower = 244;
-      setupper = 244;
-      break;
-    case 0365:
-      setascii = 117;
-      setlower = 245;
-      setupper = 245;
-      break;
-    case 0366:
-      setascii = 118;
-      setlower = 246;
-      setupper = 246;
-      break;
-    case 0367:
-      setascii = 119;
-      setlower = 247;
-      setupper = 247;
-      break;
-    case 0370:
-      setascii = 120;
-      setlower = 248;
-      setupper = 248;
-      break;
-    case 0371:
-      setascii = 121;
-      setlower = 249;
-      setupper = 249;
-      break;
-    case 0372:
-      setascii = 122;
-      setlower = 250;
-      setupper = 250;
-      break;
-    case 0373:
-      setascii = 123;
-      setlower = 251;
-      setupper = 251;
-      break;
-    case 0374:
-      setascii = 124;
-      setlower = 252;
-      setupper = 252;
-      break;
-    case 0375:
-      setascii = 125;
-      setlower = 253;
-      setupper = 253;
-      break;
-    case 0376:
-      setascii = 126;
-      setlower = 254;
-      setupper = 254;
-      break;
-    case 0377:
-      setascii = 127;
-      setlower = 255;
-      setupper = 255;
-      break;
-    default:
-      abort();
-      
-    }
-
-}
-
-
-int _DEFUN(def_isascii,(i), int i) { return isascii(i); }
-int _DEFUN(def_iscntrl,(i), int i) { return iscntrl(i); }
-int _DEFUN(def_isspace,(i), int i) { return isspace(i); }
-int _DEFUN(def_isprint,(i), int i) { return isprint(i); }
-int _DEFUN(def_isalnum,(i), int i) { return isalnum(i); }
-int _DEFUN(def_isdigit,(i), int i) { return isdigit(i); }
-int _DEFUN(def_isxdigit,(i), int i) { return isxdigit(i); }
-int _DEFUN(def_isalpha,(i), int i) { return isalpha(i); }
-int _DEFUN(def_isupper,(i), int i) { return isupper(i); }
-int _DEFUN(def_islower,(i), int i) { return islower(i); }
-int _DEFUN(def_isgraph,(i), int i) { return isgraph(i); }
-int _DEFUN(def_ispunct,(i), int i) { return ispunct(i); }
-int _DEFUN(def_tolower,(i), int i) { return tolower(i); }
-int _DEFUN(def_toupper,(i), int i) { return toupper(i); }
-int _DEFUN(def_toascii,(i), int i) { return toascii(i); }
-int _DEFUN(def__tolower,(i), int i) { return _tolower(i); }
-int _DEFUN(def__toupper,(i), int i) { return _toupper(i); }
-
-extern int inacc;
-void
-_DEFUN(test_is_set,(func, name, p),
-       int (*func)() _AND
-       char *name _AND
-       int *p)
-{
-  int i;
-  newfunc(name);
-  for (i = 0; i < 255; i++) {
-    int r = func(i) != 0;
-    line(i);
-    test_is_single(i);
-    if (*p  != r) 
-      {
-	printf("%s:%d wrong result, is %d shouldbe %d\n", name, i, r,*p);
-	inacc++;
-      }
-  }
-}
-void
-_DEFUN(test_to_set,(func, name, p, low, high),
-       int (*func)() _AND
-       char *name _AND
-       int *p _AND
-       int low _AND
-       int high)
-{
-  int i;
-  newfunc(name);
-  for (i = low; i <= high; i++) {
-    int r = func(i) ;
-    line(i);
-    test_is_single(i);
-    if (*p  != r) 
-      {
-	printf("%s:%d wrong result, is %d shouldbe %d\n", name, i, r,*p);
-	inacc++;
-      }
-  }
-}
-
-
-#undef isascii
-#undef iscntrl
-#undef isspace
-#undef isprint
-#undef isalnum
-#undef isdigit
-#undef isxdigit
-#undef isalpha
-#undef isupper
-#undef islower
-#undef isgraph
-#undef ispunct
-#undef tolower
-#undef toupper
-#undef toascii
-#undef _tolower
-#undef _toupper
-
-void
-_DEFUN_VOID(test_is)
-{
-  test_is_set(def_isalnum, "isalnum define", &myalnum);
-  test_is_set(def_isalpha, "isalpha define", &myalpha);
-  test_is_set(def_isascii, "isascii define", &myascii);
-  test_is_set(def_iscntrl, "iscntrl define", &mycntrl);
-  test_is_set(def_isdigit, "isdigit define", &mydigit);
-  test_is_set(def_isgraph, "isgraph define", &mygraph);
-  test_is_set(def_islower, "islower define", &mylower);
-  test_is_set(def_isprint, "isprint define", &myprint);
-  test_is_set(def_ispunct, "ispunct define", &mypunct);
-  test_is_set(def_isspace, "isspace define", &myspace);
-  test_is_set(def_isupper, "isupper define", &myupper);
-  test_is_set(def_isxdigit, "isxdigit define", &myxdigit);
-  test_is_set(isalnum, "isalnum function", &myalnum);
-  test_is_set(isalpha, "isalpha function", &myalpha);
-  test_is_set(isascii, "isascii function", &myascii);
-  test_is_set(iscntrl, "iscntrl function", &mycntrl);
-  test_is_set(isgraph, "isgraph function", &mygraph);
-  test_is_set(islower, "islower function", &mylower);
-  test_is_set(isprint, "isprint function", &myprint);
-  test_is_set(ispunct, "ispunct function", &mypunct);
-  test_is_set(isspace, "isspace function", &myspace);
-  test_is_set(isupper, "isupper function", &myupper);
-  test_is_set(isxdigit, "isxdigit function", &myxdigit);
-  test_to_set(_tolower, "_tolower function", &setlower, 'A','Z');
-  test_to_set(_toupper, "_toupper function", &setupper, 'a','z');
-  test_to_set(def__tolower, "_tolower define", &setlower, 'A','Z');
-  test_to_set(def__toupper, "_toupper define", &setupper, 'a','z');
-  test_to_set(def_toascii, "toascii define", &setascii, 0,255);
-  test_to_set(def_tolower, "tolower define", &setlower, 0,255);
-  test_to_set(def_toupper, "toupper define", &setupper, 0,255);
-  test_to_set(toascii, "toascii function", &setascii, 0,255);
-  test_to_set(tolower, "tolower function", &setlower, 0,255);
-  test_to_set(toupper, "toupper function", &setupper, 0,255);
-}
diff -burN orig.newlib-1.15.0/newlib/libm/test/test_is_file.c newlib-1.15.0/newlib/libm/test/test_is_file.c
--- orig.newlib-1.15.0/newlib/libm/test/test_is_file.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/test_is_file.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,2031 @@
+#include "test.h"
+#include <ctype.h>
+
+int setascii;
+int setlower;
+int setupper;
+int myascii;
+int mycntrl;
+int myspace;
+int myprint;
+int myalnum;
+int mydigit;
+int myxdigit;
+int myalpha;
+int myupper;
+int mylower;
+int mygraph;
+int mypunct;
+
+void
+_DEFUN(test_is_single,(i),
+       int i)
+{
+  setascii = 0;
+  setlower = 0;
+  setupper = 0;
+
+  myascii = 0;
+  mycntrl = 0;
+  myspace = 0;
+  myprint = 0;
+  myalnum = 0;
+  mydigit = 0;
+  myxdigit = 0;
+  myalpha = 0;
+  myupper = 0;
+  mylower = 0;
+  mygraph = 0;
+  mypunct = 0;
+
+  switch (i) {
+    case 0000:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 0;
+      setlower = 0;
+      setupper = 0;
+      break;
+    case 0001:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 1;
+      setlower = 1;
+      setupper = 1;
+      break;
+    case 0002:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 2;
+      setlower = 2;
+      setupper = 2;
+      break;
+    case 0003:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 3;
+      setlower = 3;
+      setupper = 3;
+      break;
+    case 0004:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 4;
+      setlower = 4;
+      setupper = 4;
+      break;
+    case 0005:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 5;
+      setlower = 5;
+      setupper = 5;
+      break;
+    case 0006:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 6;
+      setlower = 6;
+      setupper = 6;
+      break;
+    case 0007:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 7;
+      setlower = 7;
+      setupper = 7;
+      break;
+    case 0010:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 8;
+      setlower = 8;
+      setupper = 8;
+      break;
+    case 0011:
+      myascii = 1;
+      mycntrl = 1;
+      myspace = 1;
+      setascii = 9;
+      setlower = 9;
+      setupper = 9;
+      break;
+    case 0012:
+      myascii = 1;
+      mycntrl = 1;
+      myspace = 1;
+      setascii = 10;
+      setlower = 10;
+      setupper = 10;
+      break;
+    case 0013:
+      myascii = 1;
+      mycntrl = 1;
+      myspace = 1;
+      setascii = 11;
+      setlower = 11;
+      setupper = 11;
+      break;
+    case 0014:
+      myascii = 1;
+      mycntrl = 1;
+      myspace = 1;
+      setascii = 12;
+      setlower = 12;
+      setupper = 12;
+      break;
+    case 0015:
+      myascii = 1;
+      mycntrl = 1;
+      myspace = 1;
+      setascii = 13;
+      setlower = 13;
+      setupper = 13;
+      break;
+    case 0016:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 14;
+      setlower = 14;
+      setupper = 14;
+      break;
+    case 0017:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 15;
+      setlower = 15;
+      setupper = 15;
+      break;
+    case 0020:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 16;
+      setlower = 16;
+      setupper = 16;
+      break;
+    case 0021:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 17;
+      setlower = 17;
+      setupper = 17;
+      break;
+    case 0022:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 18;
+      setlower = 18;
+      setupper = 18;
+      break;
+    case 0023:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 19;
+      setlower = 19;
+      setupper = 19;
+      break;
+    case 0024:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 20;
+      setlower = 20;
+      setupper = 20;
+      break;
+    case 0025:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 21;
+      setlower = 21;
+      setupper = 21;
+      break;
+    case 0026:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 22;
+      setlower = 22;
+      setupper = 22;
+      break;
+    case 0027:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 23;
+      setlower = 23;
+      setupper = 23;
+      break;
+    case 0030:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 24;
+      setlower = 24;
+      setupper = 24;
+      break;
+    case 0031:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 25;
+      setlower = 25;
+      setupper = 25;
+      break;
+    case 0032:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 26;
+      setlower = 26;
+      setupper = 26;
+      break;
+    case 0033:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 27;
+      setlower = 27;
+      setupper = 27;
+      break;
+    case 0034:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 28;
+      setlower = 28;
+      setupper = 28;
+      break;
+    case 0035:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 29;
+      setlower = 29;
+      setupper = 29;
+      break;
+    case 0036:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 30;
+      setlower = 30;
+      setupper = 30;
+      break;
+    case 0037:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 31;
+      setlower = 31;
+      setupper = 31;
+      break;
+    case ' ':
+      myascii = 1;
+      myprint = 1;
+      myspace = 1;
+      setascii = 32;
+      setlower = 32;
+      setupper = 32;
+      break;
+    case '!':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 33;
+      setlower = 33;
+      setupper = 33;
+      break;
+    case '"':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 34;
+      setlower = 34;
+      setupper = 34;
+      break;
+    case '#':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 35;
+      setlower = 35;
+      setupper = 35;
+      break;
+    case '$':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 36;
+      setlower = 36;
+      setupper = 36;
+      break;
+    case '%':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 37;
+      setlower = 37;
+      setupper = 37;
+      break;
+    case '&':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 38;
+      setlower = 38;
+      setupper = 38;
+      break;
+    case '\'':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 39;
+      setlower = 39;
+      setupper = 39;
+      break;
+    case '\(':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 40;
+      setlower = 40;
+      setupper = 40;
+      break;
+    case ')':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 41;
+      setlower = 41;
+      setupper = 41;
+      break;
+    case '*':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 42;
+      setlower = 42;
+      setupper = 42;
+      break;
+    case '+':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 43;
+      setlower = 43;
+      setupper = 43;
+      break;
+    case ',':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 44;
+      setlower = 44;
+      setupper = 44;
+      break;
+    case '-':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 45;
+      setlower = 45;
+      setupper = 45;
+      break;
+    case '.':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 46;
+      setlower = 46;
+      setupper = 46;
+      break;
+    case '/':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 47;
+      setlower = 47;
+      setupper = 47;
+      break;
+    case '0':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 48;
+      setlower = 48;
+      setupper = 48;
+      break;
+    case '1':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 49;
+      setlower = 49;
+      setupper = 49;
+      break;
+    case '2':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 50;
+      setlower = 50;
+      setupper = 50;
+      break;
+    case '3':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 51;
+      setlower = 51;
+      setupper = 51;
+      break;
+    case '4':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 52;
+      setlower = 52;
+      setupper = 52;
+      break;
+    case '5':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 53;
+      setlower = 53;
+      setupper = 53;
+      break;
+    case '6':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 54;
+      setlower = 54;
+      setupper = 54;
+      break;
+    case '7':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 55;
+      setlower = 55;
+      setupper = 55;
+      break;
+    case '8':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 56;
+      setlower = 56;
+      setupper = 56;
+      break;
+    case '9':
+      myalnum = 1;
+      myascii = 1;
+      mydigit = 1;
+      mygraph = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 57;
+      setlower = 57;
+      setupper = 57;
+      break;
+    case ':':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 58;
+      setlower = 58;
+      setupper = 58;
+      break;
+    case ';':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 59;
+      setlower = 59;
+      setupper = 59;
+      break;
+    case '<':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 60;
+      setlower = 60;
+      setupper = 60;
+      break;
+    case '=':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 61;
+      setlower = 61;
+      setupper = 61;
+      break;
+    case '>':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 62;
+      setlower = 62;
+      setupper = 62;
+      break;
+    case '?':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 63;
+      setlower = 63;
+      setupper = 63;
+      break;
+    case '@':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 64;
+      setlower = 64;
+      setupper = 64;
+      break;
+    case 'A':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      myxdigit = 1;
+      setascii = 65;
+      setlower = 97;
+      setupper = 65;
+      break;
+    case 'B':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      myxdigit = 1;
+      setascii = 66;
+      setlower = 98;
+      setupper = 66;
+      break;
+    case 'C':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      myxdigit = 1;
+      setascii = 67;
+      setlower = 99;
+      setupper = 67;
+      break;
+    case 'D':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      myxdigit = 1;
+      setascii = 68;
+      setlower = 100;
+      setupper = 68;
+      break;
+    case 'E':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      myxdigit = 1;
+      setascii = 69;
+      setlower = 101;
+      setupper = 69;
+      break;
+    case 'F':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      myxdigit = 1;
+      setascii = 70;
+      setlower = 102;
+      setupper = 70;
+      break;
+    case 'G':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 71;
+      setlower = 103;
+      setupper = 71;
+      break;
+    case 'H':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 72;
+      setlower = 104;
+      setupper = 72;
+      break;
+    case 'I':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 73;
+      setlower = 105;
+      setupper = 73;
+      break;
+    case 'J':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 74;
+      setlower = 106;
+      setupper = 74;
+      break;
+    case 'K':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 75;
+      setlower = 107;
+      setupper = 75;
+      break;
+    case 'L':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 76;
+      setlower = 108;
+      setupper = 76;
+      break;
+    case 'M':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 77;
+      setlower = 109;
+      setupper = 77;
+      break;
+    case 'N':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 78;
+      setlower = 110;
+      setupper = 78;
+      break;
+    case 'O':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 79;
+      setlower = 111;
+      setupper = 79;
+      break;
+    case 'P':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 80;
+      setlower = 112;
+      setupper = 80;
+      break;
+    case 'Q':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 81;
+      setlower = 113;
+      setupper = 81;
+      break;
+    case 'R':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 82;
+      setlower = 114;
+      setupper = 82;
+      break;
+    case 'S':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 83;
+      setlower = 115;
+      setupper = 83;
+      break;
+    case 'T':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 84;
+      setlower = 116;
+      setupper = 84;
+      break;
+    case 'U':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 85;
+      setlower = 117;
+      setupper = 85;
+      break;
+    case 'V':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 86;
+      setlower = 118;
+      setupper = 86;
+      break;
+    case 'W':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 87;
+      setlower = 119;
+      setupper = 87;
+      break;
+    case 'X':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 88;
+      setlower = 120;
+      setupper = 88;
+      break;
+    case 'Y':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 89;
+      setlower = 121;
+      setupper = 89;
+      break;
+    case 'Z':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      myupper = 1;
+      setascii = 90;
+      setlower = 122;
+      setupper = 90;
+      break;
+    case '[':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 91;
+      setlower = 91;
+      setupper = 91;
+      break;
+    case '\\':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 92;
+      setlower = 92;
+      setupper = 92;
+      break;
+    case ']':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 93;
+      setlower = 93;
+      setupper = 93;
+      break;
+    case '^':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 94;
+      setlower = 94;
+      setupper = 94;
+      break;
+    case '_':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 95;
+      setlower = 95;
+      setupper = 95;
+      break;
+    case '`':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 96;
+      setlower = 96;
+      setupper = 96;
+      break;
+    case 'a':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 97;
+      setlower = 97;
+      setupper = 65;
+      break;
+    case 'b':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 98;
+      setlower = 98;
+      setupper = 66;
+      break;
+    case 'c':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 99;
+      setlower = 99;
+      setupper = 67;
+      break;
+    case 'd':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 100;
+      setlower = 100;
+      setupper = 68;
+      break;
+    case 'e':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 101;
+      setlower = 101;
+      setupper = 69;
+      break;
+    case 'f':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      myxdigit = 1;
+      setascii = 102;
+      setlower = 102;
+      setupper = 70;
+      break;
+    case 'g':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 103;
+      setlower = 103;
+      setupper = 71;
+      break;
+    case 'h':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 104;
+      setlower = 104;
+      setupper = 72;
+      break;
+    case 'i':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 105;
+      setlower = 105;
+      setupper = 73;
+      break;
+    case 'j':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 106;
+      setlower = 106;
+      setupper = 74;
+      break;
+    case 'k':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 107;
+      setlower = 107;
+      setupper = 75;
+      break;
+    case 'l':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 108;
+      setlower = 108;
+      setupper = 76;
+      break;
+    case 'm':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 109;
+      setlower = 109;
+      setupper = 77;
+      break;
+    case 'n':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 110;
+      setlower = 110;
+      setupper = 78;
+      break;
+    case 'o':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 111;
+      setlower = 111;
+      setupper = 79;
+      break;
+    case 'p':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 112;
+      setlower = 112;
+      setupper = 80;
+      break;
+    case 'q':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 113;
+      setlower = 113;
+      setupper = 81;
+      break;
+    case 'r':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 114;
+      setlower = 114;
+      setupper = 82;
+      break;
+    case 's':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 115;
+      setlower = 115;
+      setupper = 83;
+      break;
+    case 't':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 116;
+      setlower = 116;
+      setupper = 84;
+      break;
+    case 'u':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 117;
+      setlower = 117;
+      setupper = 85;
+      break;
+    case 'v':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 118;
+      setlower = 118;
+      setupper = 86;
+      break;
+    case 'w':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 119;
+      setlower = 119;
+      setupper = 87;
+      break;
+    case 'x':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 120;
+      setlower = 120;
+      setupper = 88;
+      break;
+    case 'y':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 121;
+      setlower = 121;
+      setupper = 89;
+      break;
+    case 'z':
+      myalnum = 1;
+      myalpha = 1;
+      myascii = 1;
+      mygraph = 1;
+      mylower = 1;
+      myprint = 1;
+      setascii = 122;
+      setlower = 122;
+      setupper = 90;
+      break;
+    case '{':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 123;
+      setlower = 123;
+      setupper = 123;
+      break;
+    case '|':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 124;
+      setlower = 124;
+      setupper = 124;
+      break;
+    case '}':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 125;
+      setlower = 125;
+      setupper = 125;
+      break;
+    case '~':
+      myascii = 1;
+      mygraph = 1;
+      myprint = 1;
+      mypunct = 1;
+      setascii = 126;
+      setlower = 126;
+      setupper = 126;
+      break;
+    case 0177:
+      myascii = 1;
+      mycntrl = 1;
+      setascii = 127;
+      setlower = 127;
+      setupper = 127;
+      break;
+    case 0200:
+      setascii = 0;
+      setlower = 128;
+      setupper = 128;
+      break;
+    case 0201:
+      setascii = 1;
+      setlower = 129;
+      setupper = 129;
+      break;
+    case 0202:
+      setascii = 2;
+      setlower = 130;
+      setupper = 130;
+      break;
+    case 0203:
+      setascii = 3;
+      setlower = 131;
+      setupper = 131;
+      break;
+    case 0204:
+      setascii = 4;
+      setlower = 132;
+      setupper = 132;
+      break;
+    case 0205:
+      setascii = 5;
+      setlower = 133;
+      setupper = 133;
+      break;
+    case 0206:
+      setascii = 6;
+      setlower = 134;
+      setupper = 134;
+      break;
+    case 0207:
+      setascii = 7;
+      setlower = 135;
+      setupper = 135;
+      break;
+    case 0210:
+      setascii = 8;
+      setlower = 136;
+      setupper = 136;
+      break;
+    case 0211:
+      setascii = 9;
+      setlower = 137;
+      setupper = 137;
+      break;
+    case 0212:
+      setascii = 10;
+      setlower = 138;
+      setupper = 138;
+      break;
+    case 0213:
+      setascii = 11;
+      setlower = 139;
+      setupper = 139;
+      break;
+    case 0214:
+      setascii = 12;
+      setlower = 140;
+      setupper = 140;
+      break;
+    case 0215:
+      setascii = 13;
+      setlower = 141;
+      setupper = 141;
+      break;
+    case 0216:
+      setascii = 14;
+      setlower = 142;
+      setupper = 142;
+      break;
+    case 0217:
+      setascii = 15;
+      setlower = 143;
+      setupper = 143;
+      break;
+    case 0220:
+      setascii = 16;
+      setlower = 144;
+      setupper = 144;
+      break;
+    case 0221:
+      setascii = 17;
+      setlower = 145;
+      setupper = 145;
+      break;
+    case 0222:
+      setascii = 18;
+      setlower = 146;
+      setupper = 146;
+      break;
+    case 0223:
+      setascii = 19;
+      setlower = 147;
+      setupper = 147;
+      break;
+    case 0224:
+      setascii = 20;
+      setlower = 148;
+      setupper = 148;
+      break;
+    case 0225:
+      setascii = 21;
+      setlower = 149;
+      setupper = 149;
+      break;
+    case 0226:
+      setascii = 22;
+      setlower = 150;
+      setupper = 150;
+      break;
+    case 0227:
+      setascii = 23;
+      setlower = 151;
+      setupper = 151;
+      break;
+    case 0230:
+      setascii = 24;
+      setlower = 152;
+      setupper = 152;
+      break;
+    case 0231:
+      setascii = 25;
+      setlower = 153;
+      setupper = 153;
+      break;
+    case 0232:
+      setascii = 26;
+      setlower = 154;
+      setupper = 154;
+      break;
+    case 0233:
+      setascii = 27;
+      setlower = 155;
+      setupper = 155;
+      break;
+    case 0234:
+      setascii = 28;
+      setlower = 156;
+      setupper = 156;
+      break;
+    case 0235:
+      setascii = 29;
+      setlower = 157;
+      setupper = 157;
+      break;
+    case 0236:
+      setascii = 30;
+      setlower = 158;
+      setupper = 158;
+      break;
+    case 0237:
+      setascii = 31;
+      setlower = 159;
+      setupper = 159;
+      break;
+    case 0240:
+      setascii = 32;
+      setlower = 160;
+      setupper = 160;
+      break;
+    case 0241:
+      setascii = 33;
+      setlower = 161;
+      setupper = 161;
+      break;
+    case 0242:
+      setascii = 34;
+      setlower = 162;
+      setupper = 162;
+      break;
+    case 0243:
+      setascii = 35;
+      setlower = 163;
+      setupper = 163;
+      break;
+    case 0244:
+      setascii = 36;
+      setlower = 164;
+      setupper = 164;
+      break;
+    case 0245:
+      setascii = 37;
+      setlower = 165;
+      setupper = 165;
+      break;
+    case 0246:
+      setascii = 38;
+      setlower = 166;
+      setupper = 166;
+      break;
+    case 0247:
+      setascii = 39;
+      setlower = 167;
+      setupper = 167;
+      break;
+    case 0250:
+      setascii = 40;
+      setlower = 168;
+      setupper = 168;
+      break;
+    case 0251:
+      setascii = 41;
+      setlower = 169;
+      setupper = 169;
+      break;
+    case 0252:
+      setascii = 42;
+      setlower = 170;
+      setupper = 170;
+      break;
+    case 0253:
+      setascii = 43;
+      setlower = 171;
+      setupper = 171;
+      break;
+    case 0254:
+      setascii = 44;
+      setlower = 172;
+      setupper = 172;
+      break;
+    case 0255:
+      setascii = 45;
+      setlower = 173;
+      setupper = 173;
+      break;
+    case 0256:
+      setascii = 46;
+      setlower = 174;
+      setupper = 174;
+      break;
+    case 0257:
+      setascii = 47;
+      setlower = 175;
+      setupper = 175;
+      break;
+    case 0260:
+      setascii = 48;
+      setlower = 176;
+      setupper = 176;
+      break;
+    case 0261:
+      setascii = 49;
+      setlower = 177;
+      setupper = 177;
+      break;
+    case 0262:
+      setascii = 50;
+      setlower = 178;
+      setupper = 178;
+      break;
+    case 0263:
+      setascii = 51;
+      setlower = 179;
+      setupper = 179;
+      break;
+    case 0264:
+      setascii = 52;
+      setlower = 180;
+      setupper = 180;
+      break;
+    case 0265:
+      setascii = 53;
+      setlower = 181;
+      setupper = 181;
+      break;
+    case 0266:
+      setascii = 54;
+      setlower = 182;
+      setupper = 182;
+      break;
+    case 0267:
+      setascii = 55;
+      setlower = 183;
+      setupper = 183;
+      break;
+    case 0270:
+      setascii = 56;
+      setlower = 184;
+      setupper = 184;
+      break;
+    case 0271:
+      setascii = 57;
+      setlower = 185;
+      setupper = 185;
+      break;
+    case 0272:
+      setascii = 58;
+      setlower = 186;
+      setupper = 186;
+      break;
+    case 0273:
+      setascii = 59;
+      setlower = 187;
+      setupper = 187;
+      break;
+    case 0274:
+      setascii = 60;
+      setlower = 188;
+      setupper = 188;
+      break;
+    case 0275:
+      setascii = 61;
+      setlower = 189;
+      setupper = 189;
+      break;
+    case 0276:
+      setascii = 62;
+      setlower = 190;
+      setupper = 190;
+      break;
+    case 0277:
+      setascii = 63;
+      setlower = 191;
+      setupper = 191;
+      break;
+    case 0300:
+      setascii = 64;
+      setlower = 192;
+      setupper = 192;
+      break;
+    case 0301:
+      setascii = 65;
+      setlower = 193;
+      setupper = 193;
+      break;
+    case 0302:
+      setascii = 66;
+      setlower = 194;
+      setupper = 194;
+      break;
+    case 0303:
+      setascii = 67;
+      setlower = 195;
+      setupper = 195;
+      break;
+    case 0304:
+      setascii = 68;
+      setlower = 196;
+      setupper = 196;
+      break;
+    case 0305:
+      setascii = 69;
+      setlower = 197;
+      setupper = 197;
+      break;
+    case 0306:
+      setascii = 70;
+      setlower = 198;
+      setupper = 198;
+      break;
+    case 0307:
+      setascii = 71;
+      setlower = 199;
+      setupper = 199;
+      break;
+    case 0310:
+      setascii = 72;
+      setlower = 200;
+      setupper = 200;
+      break;
+    case 0311:
+      setascii = 73;
+      setlower = 201;
+      setupper = 201;
+      break;
+    case 0312:
+      setascii = 74;
+      setlower = 202;
+      setupper = 202;
+      break;
+    case 0313:
+      setascii = 75;
+      setlower = 203;
+      setupper = 203;
+      break;
+    case 0314:
+      setascii = 76;
+      setlower = 204;
+      setupper = 204;
+      break;
+    case 0315:
+      setascii = 77;
+      setlower = 205;
+      setupper = 205;
+      break;
+    case 0316:
+      setascii = 78;
+      setlower = 206;
+      setupper = 206;
+      break;
+    case 0317:
+      setascii = 79;
+      setlower = 207;
+      setupper = 207;
+      break;
+    case 0320:
+      setascii = 80;
+      setlower = 208;
+      setupper = 208;
+      break;
+    case 0321:
+      setascii = 81;
+      setlower = 209;
+      setupper = 209;
+      break;
+    case 0322:
+      setascii = 82;
+      setlower = 210;
+      setupper = 210;
+      break;
+    case 0323:
+      setascii = 83;
+      setlower = 211;
+      setupper = 211;
+      break;
+    case 0324:
+      setascii = 84;
+      setlower = 212;
+      setupper = 212;
+      break;
+    case 0325:
+      setascii = 85;
+      setlower = 213;
+      setupper = 213;
+      break;
+    case 0326:
+      setascii = 86;
+      setlower = 214;
+      setupper = 214;
+      break;
+    case 0327:
+      setascii = 87;
+      setlower = 215;
+      setupper = 215;
+      break;
+    case 0330:
+      setascii = 88;
+      setlower = 216;
+      setupper = 216;
+      break;
+    case 0331:
+      setascii = 89;
+      setlower = 217;
+      setupper = 217;
+      break;
+    case 0332:
+      setascii = 90;
+      setlower = 218;
+      setupper = 218;
+      break;
+    case 0333:
+      setascii = 91;
+      setlower = 219;
+      setupper = 219;
+      break;
+    case 0334:
+      setascii = 92;
+      setlower = 220;
+      setupper = 220;
+      break;
+    case 0335:
+      setascii = 93;
+      setlower = 221;
+      setupper = 221;
+      break;
+    case 0336:
+      setascii = 94;
+      setlower = 222;
+      setupper = 222;
+      break;
+    case 0337:
+      setascii = 95;
+      setlower = 223;
+      setupper = 223;
+      break;
+    case 0340:
+      setascii = 96;
+      setlower = 224;
+      setupper = 224;
+      break;
+    case 0341:
+      setascii = 97;
+      setlower = 225;
+      setupper = 225;
+      break;
+    case 0342:
+      setascii = 98;
+      setlower = 226;
+      setupper = 226;
+      break;
+    case 0343:
+      setascii = 99;
+      setlower = 227;
+      setupper = 227;
+      break;
+    case 0344:
+      setascii = 100;
+      setlower = 228;
+      setupper = 228;
+      break;
+    case 0345:
+      setascii = 101;
+      setlower = 229;
+      setupper = 229;
+      break;
+    case 0346:
+      setascii = 102;
+      setlower = 230;
+      setupper = 230;
+      break;
+    case 0347:
+      setascii = 103;
+      setlower = 231;
+      setupper = 231;
+      break;
+    case 0350:
+      setascii = 104;
+      setlower = 232;
+      setupper = 232;
+      break;
+    case 0351:
+      setascii = 105;
+      setlower = 233;
+      setupper = 233;
+      break;
+    case 0352:
+      setascii = 106;
+      setlower = 234;
+      setupper = 234;
+      break;
+    case 0353:
+      setascii = 107;
+      setlower = 235;
+      setupper = 235;
+      break;
+    case 0354:
+      setascii = 108;
+      setlower = 236;
+      setupper = 236;
+      break;
+    case 0355:
+      setascii = 109;
+      setlower = 237;
+      setupper = 237;
+      break;
+    case 0356:
+      setascii = 110;
+      setlower = 238;
+      setupper = 238;
+      break;
+    case 0357:
+      setascii = 111;
+      setlower = 239;
+      setupper = 239;
+      break;
+    case 0360:
+      setascii = 112;
+      setlower = 240;
+      setupper = 240;
+      break;
+    case 0361:
+      setascii = 113;
+      setlower = 241;
+      setupper = 241;
+      break;
+    case 0362:
+      setascii = 114;
+      setlower = 242;
+      setupper = 242;
+      break;
+    case 0363:
+      setascii = 115;
+      setlower = 243;
+      setupper = 243;
+      break;
+    case 0364:
+      setascii = 116;
+      setlower = 244;
+      setupper = 244;
+      break;
+    case 0365:
+      setascii = 117;
+      setlower = 245;
+      setupper = 245;
+      break;
+    case 0366:
+      setascii = 118;
+      setlower = 246;
+      setupper = 246;
+      break;
+    case 0367:
+      setascii = 119;
+      setlower = 247;
+      setupper = 247;
+      break;
+    case 0370:
+      setascii = 120;
+      setlower = 248;
+      setupper = 248;
+      break;
+    case 0371:
+      setascii = 121;
+      setlower = 249;
+      setupper = 249;
+      break;
+    case 0372:
+      setascii = 122;
+      setlower = 250;
+      setupper = 250;
+      break;
+    case 0373:
+      setascii = 123;
+      setlower = 251;
+      setupper = 251;
+      break;
+    case 0374:
+      setascii = 124;
+      setlower = 252;
+      setupper = 252;
+      break;
+    case 0375:
+      setascii = 125;
+      setlower = 253;
+      setupper = 253;
+      break;
+    case 0376:
+      setascii = 126;
+      setlower = 254;
+      setupper = 254;
+      break;
+    case 0377:
+      setascii = 127;
+      setlower = 255;
+      setupper = 255;
+      break;
+    default:
+      abort();
+      
+    }
+
+}
+
+
+int _DEFUN(def_isascii,(i), int i) { return isascii(i); }
+int _DEFUN(def_iscntrl,(i), int i) { return iscntrl(i); }
+int _DEFUN(def_isspace,(i), int i) { return isspace(i); }
+int _DEFUN(def_isprint,(i), int i) { return isprint(i); }
+int _DEFUN(def_isalnum,(i), int i) { return isalnum(i); }
+int _DEFUN(def_isdigit,(i), int i) { return isdigit(i); }
+int _DEFUN(def_isxdigit,(i), int i) { return isxdigit(i); }
+int _DEFUN(def_isalpha,(i), int i) { return isalpha(i); }
+int _DEFUN(def_isupper,(i), int i) { return isupper(i); }
+int _DEFUN(def_islower,(i), int i) { return islower(i); }
+int _DEFUN(def_isgraph,(i), int i) { return isgraph(i); }
+int _DEFUN(def_ispunct,(i), int i) { return ispunct(i); }
+int _DEFUN(def_tolower,(i), int i) { return tolower(i); }
+int _DEFUN(def_toupper,(i), int i) { return toupper(i); }
+int _DEFUN(def_toascii,(i), int i) { return toascii(i); }
+int _DEFUN(def__tolower,(i), int i) { return _tolower(i); }
+int _DEFUN(def__toupper,(i), int i) { return _toupper(i); }
+
+extern int inacc;
+void
+_DEFUN(test_is_set,(func, name, p),
+       int (*func)() _AND
+       char *name _AND
+       int *p)
+{
+  int i;
+  newfunc(name);
+  for (i = 0; i < 255; i++) {
+    int r = func(i) != 0;
+    line(i);
+    test_is_single(i);
+    if (*p  != r) 
+      {
+	printf("%s:%d wrong result, is %d shouldbe %d\n", name, i, r,*p);
+	inacc++;
+      }
+  }
+}
+void
+_DEFUN(test_to_set,(func, name, p, low, high),
+       int (*func)() _AND
+       char *name _AND
+       int *p _AND
+       int low _AND
+       int high)
+{
+  int i;
+  newfunc(name);
+  for (i = low; i <= high; i++) {
+    int r = func(i) ;
+    line(i);
+    test_is_single(i);
+    if (*p  != r) 
+      {
+	printf("%s:%d wrong result, is %d shouldbe %d\n", name, i, r,*p);
+	inacc++;
+      }
+  }
+}
+
+
+#undef isascii
+#undef iscntrl
+#undef isspace
+#undef isprint
+#undef isalnum
+#undef isdigit
+#undef isxdigit
+#undef isalpha
+#undef isupper
+#undef islower
+#undef isgraph
+#undef ispunct
+#undef tolower
+#undef toupper
+#undef toascii
+#undef _tolower
+#undef _toupper
+
+void
+_DEFUN_VOID(test_is)
+{
+  test_is_set(def_isalnum, "isalnum define", &myalnum);
+  test_is_set(def_isalpha, "isalpha define", &myalpha);
+  test_is_set(def_isascii, "isascii define", &myascii);
+  test_is_set(def_iscntrl, "iscntrl define", &mycntrl);
+  test_is_set(def_isdigit, "isdigit define", &mydigit);
+  test_is_set(def_isgraph, "isgraph define", &mygraph);
+  test_is_set(def_islower, "islower define", &mylower);
+  test_is_set(def_isprint, "isprint define", &myprint);
+  test_is_set(def_ispunct, "ispunct define", &mypunct);
+  test_is_set(def_isspace, "isspace define", &myspace);
+  test_is_set(def_isupper, "isupper define", &myupper);
+  test_is_set(def_isxdigit, "isxdigit define", &myxdigit);
+  test_is_set(isalnum, "isalnum function", &myalnum);
+  test_is_set(isalpha, "isalpha function", &myalpha);
+  test_is_set(isascii, "isascii function", &myascii);
+  test_is_set(iscntrl, "iscntrl function", &mycntrl);
+  test_is_set(isgraph, "isgraph function", &mygraph);
+  test_is_set(islower, "islower function", &mylower);
+  test_is_set(isprint, "isprint function", &myprint);
+  test_is_set(ispunct, "ispunct function", &mypunct);
+  test_is_set(isspace, "isspace function", &myspace);
+  test_is_set(isupper, "isupper function", &myupper);
+  test_is_set(isxdigit, "isxdigit function", &myxdigit);
+  test_to_set(_tolower, "_tolower function", &setlower, 'A','Z');
+  test_to_set(_toupper, "_toupper function", &setupper, 'a','z');
+  test_to_set(def__tolower, "_tolower define", &setlower, 'A','Z');
+  test_to_set(def__toupper, "_toupper define", &setupper, 'a','z');
+  test_to_set(def_toascii, "toascii define", &setascii, 0,255);
+  test_to_set(def_tolower, "tolower define", &setlower, 0,255);
+  test_to_set(def_toupper, "toupper define", &setupper, 0,255);
+  test_to_set(toascii, "toascii function", &setascii, 0,255);
+  test_to_set(tolower, "tolower function", &setlower, 0,255);
+  test_to_set(toupper, "toupper function", &setupper, 0,255);
+}
diff -burN orig.newlib-1.15.0/newlib/libm/test/test.mk newlib-1.15.0/newlib/libm/test/test.mk
--- orig.newlib-1.15.0/newlib/libm/test/test.mk	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/test.mk	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,169 @@
+#
+# Hacked makefile.
+#
+SPU_CC=spu-gcc
+CC=$(SPU_CC)
+SPU_AR=spu-ar
+CROSS_LD=spu-gcc
+
+LIBC=../../../spu/newlib/libc.a
+LIBM=../../../spu/newlib/libm.a
+#LIBC=
+#LIBM=-lm
+TESTLIB=testlib.a
+LIBS=$(TESTLIB) $(LIBC) $(LIBM)
+LDFLAGS=$(LIBS)
+
+# XXX log2 doesn't exist, maybe add it
+
+ORIG_OFILES=test.o  string.o  convert.o conv_vec.o iconv_vec.o test_is.o dvec.o sprint_vec.o sprint_ivec.o math2.o test_ieee.o
+
+OFILES=test.o  string.o  convert.o conv_vec.o iconv_vec.o test_is_file.o \
+	dvec.o sprint_vec.o sprint_ivec.o math2.o
+
+OMIT=log2_vec.o log2f_vec.o
+
+VEC_OFILES= \
+	math.o atan2_vec.o atan2f_vec.o jn_vec.o jnf_vec.o yn_vec.o \
+	ynf_vec.o acos_vec.o acosf_vec.o acosh_vec.o acoshf_vec.o \
+	asin_vec.o asinf_vec.o asinh_vec.o asinhf_vec.o atan_vec.o \
+	atanf_vec.o atanh_vec.o atanhf_vec.o ceil_vec.o ceilf_vec.o \
+	cos_vec.o cosf_vec.o cosh_vec.o coshf_vec.o erf_vec.o erfc_vec.o \
+	erfcf_vec.o erff_vec.o exp_vec.o expf_vec.o fabs_vec.o fabsf_vec.o \
+	floor_vec.o floorf_vec.o gamma_vec.o gammaf_vec.o j0_vec.o \
+	j0f_vec.o j1_vec.o j1f_vec.o log10_vec.o log10f_vec.o log1p_vec.o \
+	log1pf_vec.o log_vec.o logf_vec.o sin_vec.o sinf_vec.o sinh_vec.o \
+	sinhf_vec.o sqrt_vec.o sqrtf_vec.o tan_vec.o tanf_vec.o tanh_vec.o \
+	tanhf_vec.o y0_vec.o y0f_vec.o y1_vec.o y1f_vec.o hypotf_vec.o \
+	hypot_vec.o fmod_vec.o fmodf_vec.o
+
+TEST_OBJ1= test_cvt.o test_math2.o test_string.o test_is.o
+
+TEST_PROGS=$(TEST_OBJ1:.o=)
+
+TEST_OBJ=$(TEST_OBJ1) test_math.o
+
+MATH_TEST_OBJ= \
+	test_acos.o test_acosf.o test_acosh.o test_acoshf.o test_asin.o \
+	test_asinf.o test_asinh.o test_asinhf.o test_atan.o test_atan2.o \
+	test_atan2f.o test_atanf.o test_atanh.o test_atanhf.o test_ceil.o \
+	test_ceilf.o test_cos.o test_cosf.o test_cosh.o test_coshf.o \
+	test_erf.o test_erfc.o test_erfcf.o test_erff.o test_exp.o \
+	test_expf.o test_fabs.o test_fabsf.o test_floor.o test_floorf.o \
+	test_fmod.o test_fmodf.o test_gamma.o test_gammaf.o test_hypot.o \
+	test_hypotf.o test_j0.o test_j0f.o test_j1.o test_j1f.o test_jn.o \
+	test_jnf.o test_log.o test_log10.o test_log10f.o test_log1p.o \
+	test_log1pf.o test_logf.o test_sin.o \
+	test_sinf.o test_sinh.o test_sinhf.o test_sqrt.o test_sqrtf.o \
+	test_tan.o test_tanf.o test_tanh.o test_tanhf.o test_y0.o \
+	test_y0f.o test_y1.o test_y1f.o test_ynf.o
+
+# No test_log2.o or test_log2f.o in above
+
+MATH_TEST=$(MATH_TEST_OBJ:.o=)
+
+ALL_TESTS=$(MATH_TEST) $(TEST_PROGS)
+
+all: $(OFILES) $(TESTLIB) $(ALL_TESTS)
+
+run:
+	@for t in $(ALL_TESTS) ; do \
+		echo ============ $$t =========== ; \
+		elfspe $$t ; \
+	done
+
+$(TEST_OBJ): %.o: test_template.c
+	$(CC) -c -DTEST_NAME=$* test_template.c -o $(@F)
+
+$(TEST_PROGS):
+	$(CC) $(@F).o -o $(@F) $(LIBS)
+
+$(MATH_TEST): test_math.o
+	$(CC) $(@F).o test_math.o -o $(@F) $(LIBS)
+
+$(MATH_TEST_OBJ): %.o: math_template.c
+	$(CC) -c -DTEST_NAME=$* math_template.c -o $(@F)
+
+$(TESTLIB): $(VEC_OFILES)
+	rm -f $(TESTLIB)
+	$(SPU_AR) rc $(TESTLIB) $(VEC_OFILES) \
+		convert.o sprint_vec.o sprint_ivec.o dvec.o conv_vec.o \
+		iconv_vec.o math2.o string.o test_is_file.o \
+
+clean:
+	$(RM) $(TEST_OBJ) $(ALL_TESTS) $(MATH_TEST_OBJ) \
+		$(OFILES) $(VEC_OFILES) $(TESTLIB) *~
+
+# XXX can't figure out an automatic way to force these dependencies:
+# test_math:	test_math.o
+# test_math.o:
+test_cvt: test_cvt.o
+test_math2: test_math2.o
+test_string: test_string.o
+test_is: test_is.o
+
+test_acos:	test_acos.o
+test_acosf:	test_acosf.o
+test_acosh:	test_acosh.o
+test_acoshf:	test_acoshf.o
+test_asin:	test_asin.o
+test_asinf:	test_asinf.o
+test_asinh:	test_asinh.o
+test_asinhf:	test_asinhf.o
+test_atan:	test_atan.o
+test_atan2:	test_atan2.o
+test_atan2f:	test_atan2f.o
+test_atanf:	test_atanf.o
+test_atanh:	test_atanh.o
+test_atanhf:	test_atanhf.o
+test_ceil:	test_ceil.o
+test_ceilf:	test_ceilf.o
+test_cos:	test_cos.o
+test_cosf:	test_cosf.o
+test_cosh:	test_cosh.o
+test_coshf:	test_coshf.o
+test_erf:	test_erf.o
+test_erfc:	test_erfc.o
+test_erfcf:	test_erfcf.o
+test_erff:	test_erff.o
+test_exp:	test_exp.o
+test_expf:	test_expf.o
+test_fabs:	test_fabs.o
+test_fabsf:	test_fabsf.o
+test_floor:	test_floor.o
+test_floorf:	test_floorf.o
+test_fmod:	test_fmod.o
+test_fmodf:	test_fmodf.o
+test_gamma:	test_gamma.o
+test_gammaf:	test_gammaf.o
+test_hypot:	test_hypot.o
+test_hypotf:	test_hypotf.o
+test_j0:	test_j0.o
+test_j0f:	test_j0f.o
+test_j1:	test_j1.o
+test_j1f:	test_j1f.o
+test_jn:	test_jn.o
+test_jnf:	test_jnf.o
+test_log:	test_log.o
+test_log10:	test_log10.o
+test_log10f:	test_log10f.o
+test_log1p:	test_log1p.o
+test_log1pf:	test_log1pf.o
+# test_log2:	test_log2.o
+# test_log2f:	test_log2f.o
+test_logf:	test_logf.o
+test_sin:	test_sin.o
+test_sinf:	test_sinf.o
+test_sinh:	test_sinh.o
+test_sinhf:	test_sinhf.o
+test_sqrt:	test_sqrt.o
+test_sqrtf:	test_sqrtf.o
+test_tan:	test_tan.o
+test_tanf:	test_tanf.o
+test_tanh:	test_tanh.o
+test_tanhf:	test_tanhf.o
+test_y0:	test_y0.o
+test_y0f:	test_y0f.o
+test_y1:	test_y1.o
+test_y1f:	test_y1f.o
+test_ynf:	test_ynf.o
diff -burN orig.newlib-1.15.0/newlib/libm/test/test_template.c newlib-1.15.0/newlib/libm/test/test_template.c
--- orig.newlib-1.15.0/newlib/libm/test/test_template.c	1969-12-31 20:00:00.000000000 -0400
+++ newlib-1.15.0/newlib/libm/test/test_template.c	2007-06-12 16:59:18.000000000 -0300
@@ -0,0 +1,268 @@
+#include <signal.h>
+#include  "test.h"
+#include <math.h>
+#include <ieeefp.h>
+#include <string.h>
+int verbose;
+static int count;
+int inacc;
+
+
+int
+_DEFUN(main,(ac, av),
+       int ac _AND
+       char **av)
+{
+  int i;
+  int math2 = 1;
+  int string= 1;
+  int is = 1;
+  int math= 1;
+  int cvt = 1;
+  int ieee= 1;
+bt();
+  for (i = 1; i < ac; i++) 
+  {
+    if (strcmp(av[i],"-v")==0) 
+     verbose ++;
+  }
+  TEST_NAME();
+  printf("Tested %d functions, %d errors detected\n", count, inacc);
+  return 0;
+}
+
+
+static _CONST char *iname = "foo";
+void 
+_DEFUN(newfunc,(string),
+       _CONST char *string)
+{
+  if (strcmp(iname, string)) 
+  {
+    printf("testing %s\n", string);
+    fflush(stdout);
+    iname = string;
+  }
+  
+}
+
+
+static int theline;
+
+void line(li)
+int li;
+{
+  if (verbose)  
+  {
+    printf("  %d\n", li);
+  }
+  theline = li;
+  
+  count++;
+}
+
+
+
+int redo = 0;
+int reduce = 0;
+
+int strtod_vector = 0;
+
+int 
+_DEFUN(bigger,(a,b),
+	   __ieee_double_shape_type *a  _AND
+	   __ieee_double_shape_type *b)
+{
+
+  if (a->parts.msw > b->parts.msw) 
+    {
+
+      return 1;
+    } 
+  else if (a->parts.msw == b->parts.msw) 
+    {
+      if (a->parts.lsw > b->parts.lsw) 
+	{
+	  return 1;
+	}
+    }
+  return 0;
+}
+
+
+
+/* Return the first bit different between two double numbers */
+int 
+_DEFUN(mag_of_error,(is, shouldbe),
+       double is _AND
+       double shouldbe)
+{
+  __ieee_double_shape_type a,b;
+  int i;
+  int a_big;
+  unsigned  int mask;
+  unsigned long int __x;
+  unsigned long int msw, lsw;						  
+  a.value = is;
+  
+  b.value = shouldbe;
+  
+  if (a.parts.msw == b.parts.msw 
+      && a.parts.lsw== b.parts.lsw) return 64;
+
+
+  /* Subtract the larger from the smaller number */
+
+  a_big = bigger(&a, &b);
+
+  if (!a_big) {
+    int t;
+    t = a.parts.msw;
+    a.parts.msw = b.parts.msw;
+    b.parts.msw = t;
+
+    t = a.parts.lsw;
+    a.parts.lsw = b.parts.lsw;
+    b.parts.lsw = t;
+  }
+
+
+
+  __x = (a.parts.lsw) - (b.parts.lsw);							
+  msw = (a.parts.msw) - (b.parts.msw) - (__x > (a.parts.lsw));
+  lsw = __x;								
+
+  
+
+
+  /* Find out which bit the difference is in */
+  mask = 0x80000000;
+  for (i = 0; i < 32; i++)
+  {
+    if (((msw) & mask)!=0) return i;
+    mask >>=1;
+  }
+  
+  mask = 0x80000000;
+  for (i = 0; i < 32; i++)
+  {
+    
+    if (((lsw) & mask)!=0) return i+32;
+    mask >>=1;
+  }
+  
+  return 64;
+  
+}
+
+ int ok_mag;
+
+
+
+void
+_DEFUN(test_sok,(is, shouldbe),
+       char *is _AND
+       char *shouldbe)
+{
+  if (strcmp(is,shouldbe))
+    {
+    printf("%s:%d, inacurate answer: (%s should be %s)\n",
+	   iname, 
+	   theline,
+	   is, shouldbe);
+    inacc++;
+  }
+}
+void
+_DEFUN(test_iok,(is, shouldbe),
+       int is _AND
+       int shouldbe)
+{
+  if (is != shouldbe){
+    printf("%s:%d, inacurate answer: (%08x should be %08x)\n",
+	   iname, 
+	   theline,
+	   is, shouldbe);
+    inacc++;
+  }
+}
+
+
+/* Compare counted strings upto a certain length - useful to test single
+   prec float conversions against double results
+*/
+void 
+_DEFUN(test_scok,(is, shouldbe, count),
+       char *is _AND
+       char *shouldbe _AND
+       int count)
+{
+  if (strncmp(is,shouldbe, count))
+    {
+    printf("%s:%d, inacurate answer: (%s should be %s)\n",
+	   iname, 
+	   theline,
+	   is, shouldbe);
+    inacc++;
+  }
+}
+
+void
+_DEFUN(test_eok,(is, shouldbe),
+       int is _AND
+       int shouldbe)
+{
+  if (is != shouldbe){
+    printf("%s:%d, bad errno answer: (%d should be %d)\n",
+	   iname, 
+	   theline,
+	   is, shouldbe);
+    inacc++;
+  }
+}
+
+void
+_DEFUN(test_mok,(value, shouldbe, okmag),
+       double value _AND
+       double shouldbe _AND
+       int okmag)
+{
+  __ieee_double_shape_type a,b;
+  int mag = mag_of_error(value, shouldbe);
+  if (mag == 0) 
+  {
+    /* error in the first bit is ok if the numbers are both 0 */
+    if (value == 0.0 && shouldbe == 0.0)
+     return;
+    
+  }
+  a.value = shouldbe;
+  b.value = value;
+  
+  if (mag < okmag) 
+  {
+    printf("%s:%d, wrong answer: bit %d ",
+	   iname, 
+	   theline,
+	   mag);
+     printf("%08x%08x %08x%08x) ",
+	    a.parts.msw,	     a.parts.lsw,
+	    b.parts.msw,	     b.parts.lsw);
+    printf("(%g %g)\n",   a.value, b.value);
+    inacc++;
+  }
+}
+
+#ifdef __PCCNECV70__
+kill() {}
+getpid() {}
+#endif
+
+bt(){
+
+  double f1,f2;
+  f1 = 0.0;
+  f2 = 0.0/f1;
+  printf("(%g)\n", f2);
+
+}
